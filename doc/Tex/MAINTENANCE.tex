%^CFG COPYRIGHT UM
\documentclass[twoside,10pt]{article}

\title{Space Weather Modeling Framework Maintenance Manual \\ 
       \hfill \\
       \large Code Version \SWMFVERSION}
\author{G\'abor T\'oth, Darren De Zeeuw\\
        \hfill \\
       {\it Center for Space Environment Modeling}\\
       {\it The University of Michigan}}

\input HEADER

%%%
% Maintenance manual
%%%
\section{CVS}

Physics module and framework code is all maintained and developed
through a CVS repository at the University of Michigan.  A developer
can check out either the whole framework and all physics modules, or
any individual physics module and necessary common support code.  All
code changes must be tested (see TESTING.pdf) before committing back
into the CVS repository.  A complete description of changes must be
entered into the CVS logs when committing any change.

%%%
% New Modules
%%%
\section{How to Add a New Component}

\subsection{Requirements to Physics Modules and Components}

The SWMF compliance definitions, both for physics modules and components 
created from them, were formulated in the SWMF Interoperability Document. 
The minimal set of requirements regarding the source code of a physics 
module only, which is the part of the physics module compliance definition, 
is briefly repeated below:

\begin{itemize}
\item The parallelization mechanism must employ the MPI standard only
\item A module must have the structure permitting the following two 
      modes of execution:

   \begin{itemize}
   \item As a stand-alone executable
   \item As a library which could be linked to another executable
   \end{itemize}

\item A module must successfully run the test suite provided by its
developers at least  on SGI Origin 2000 and
Compaq ES45 machines, and
on Linux Beowulf clusters with the NAG F95 compiler.

\item The module must adhere to the following Input/Output requirements:

    \begin{itemize}
    \item Read input data from files only;
    \item Write output data to files only.
    \item The path to these files should be externally set
    \end{itemize}

\item A module must be implemented in the following languages only: 
    Fortran 77, Fortran 90, and C/C++.

\item The following is not permitted in the source code of the module:

    \begin{itemize}
    \item Lack of modularity and absence of point entry 
          for other software tools
    \item Input-output that cannot be turned off or redirected
    \item Absence of error handling in the code
    \item Pointers that do not return error conditions
    \end{itemize}

\item The source code of the module should be documented 
      at least through appropriate comments in source files.
\end{itemize}

The physics module should be converted to a SWMF component by constructing 
standard interfaces from programming blocks provided by the SWMF.
The first standard interface is a wrapper. 
In addition to that for each link with another component
the coupling interface must be constructed.
The standard interfaces must at least enable the following 
features of a component:
\begin{itemize}
\item To be registered by the Control Module;
\item To be initialized in parallel configuration;
\item To accept and check input parameters obtained from the Control Module;
\item To initialize for session execution and provide grid description to 
      Control Module;
\item To execute a time step, provide simulation time which cannot exceed
      a specified maximum simulation time
\item To receive and provide data to other components via the coupler in 
      the Control Module;
\item To write its state into a restart file when requested;
\item To finalize at the end of the execution;
\end{itemize}
There are restrictions regarding I/O operations and error handling:
\begin{itemize}
\item Input data must be read from the subdirectory with the component name
      in the directory \textbf{run};
\item Output data must be written into files in the subdirectory 
      with the component name in the directory \textbf{run};
\item Errors should call the {\tt CON\_stop} methods with an appropriate
      error message. No {\tt stop} statements are allowed;
\item Standard output should be prefixed with a string identifying the
      component and/or redirected into a file defined by the 
      Control Module.
\end{itemize}

The inclusion of a new physics code as  an alternative component 
for the physics domain, which is already covered by the SWMF, 
is a relatively simple task. The inclusion of the first component of 
the new physics domain is slightly more demanding task.

\subsection{New Physics Code as an Alternative Component}

To add new physics code as an alternative component which is already part of 
the SWMF, a user should perform the following steps:

\begin{itemize}
\item Add a subdirectory for this code in the directory of the 
appropriate physics model (i.e. in one of the GM, IH, IE etc.
directories).

\item Create a subdirectory \textbf{src} and put the physics code into 
      this directory.
 
\item Write the code top-level Makefile (you may use any of the
      existing component Makefile-s as an example),
      which should have the targets:

\begin{itemize}
\item install - creates Makefile.DEPEND and does the fine 
                tuning of the build scripts 
                for the component, for instance, sets the specific 
                compilation rules for files which 
                could not be compiled with the generic rules 
\item LIB - builds the component library
\item clean - cleans the \textbf{src} subdirectory
\item distclean - discards all the files created since installation
\item rundir - copies files and directories that are needed to run the 
               component into the directory \textbf{run}
\end{itemize}

\item Include the top level Makefile.conf into the top-level Makefile

\item Write a wrapper file for the new component. 
      This can be placed into src or a separate srcInterface directory.
      The wrapper is constructed as 
      a set of external subroutines which we will call methods below. 
      The method names must have the prefix 
      of the physics domain with underscore, for example GM\_, IE\_ and etc. 
      The following methods are required for a new version of the
      SP component, for example:

\begin{itemize}
\item SP\_set\_param
\item SP\_init\_session
\item SP\_run
\item SP\_save\_restart
\item SP\_finalize
\end{itemize}

\item Write a set of put and get routines for each component, 
      with which your component should be coupled.

\item Extend the couplers in {\tt CON/Interface/src} as necessary.

\item Provide a PARAM.XML file in the component version directory
      to describe all the input commands.

\item Provide a GridSize.pl script in the component version directory
      to show and change the grid size of the component.

\item Add the new component version in the main {\tt Makefile} and
      in {\tt CON/Makefile.def}

\end{itemize}

\subsection{Adding a new Physics Component}

To include a new physics component which covers a new physics domain
(for example Radiation Belt), it is necessary to perform the following steps:
\begin{itemize}
\item Create the subdirectory for this physics domain (e.g. RB/) 

\item Create version subdirectories
      for an empty and at least one working version 
      (e.g. RB/Rice/ and RB/Empty/)

\item Add entries for this physics domain to the 
      {\tt CON\_wrapper.f90} and {\tt CON\_couple\_all.f90}
      files in {\tt CON/Interface/src}.

\item Add the new component with all versions in the main {\tt Makefile}, in 
      {\tt CON/Makefile.def} and link it as a library in
      {\tt CON/Control/src/Makefile}.

\item Create the new coupling interfaces in {\tt CON/Interface/src}

\item Add the new component and the new couplings in all 
      input command definitions 
      which list the components or couplings explicitly in Param/PARAM.XML.

\item Add the new component into the \$ValidComp variable in
      SetSWMF.pl and in share/Scripts/CheckParam.pl

\item List the new component and the new couplings in a few 
      commands in Param/PARAM.XML

\item Do all the steps described in the previous section.
\end{itemize}
The files {\tt CON/Interface/src/CON\_wrapper.f90} and 
{\tt CON\_couple\_all.f90} play the role 
of switchboards for all wrappers and coupling interfaces, respectively. 
In other words these two files emulate dynamic dispatching or run-time 
polymorphism in Fortran 90 written code. They allow to use a single
subroutine name for a component method and resolve at run-time which 
particular component method was called.

\newpage
\section{Examples for Component Wrapper and Coupler}

\subsection{Example Wrapper for Component PM}

This subsection provides explicit interfaces and examples for
all the methods (subroutines) that must be defined by a component wrapper. 
The documentation is produced from the 
\begin{verbatim}
doc/Tex/PM_wrapper.f90
\end{verbatim}
file which can be used as a template for writing a new wrapper.

In this example the abbreviated name of the component (the component ID)
is {\tt PM} (which stands for Physics Module). 
If the file is used as a template for an actual wrapper, then
the file should be placed into the appropriate component version 
interface directory named analogous to
\begin{verbatim}
PM/PmVersion/srcInterface/PM_wrapper.f90
\end{verbatim}
Further the {\tt PM} string should be replaced with the two-character ID 
of the actual component and/or the module, variable and subroutine names 
that belong to the physics module (all start with {\tt PM\_} in this file)
should be replaced with the appropriate module, variable and subroutine 
names of the new physics module. For example if the component ID is 'IE'
then the subroutine {\tt PM\_init\_session} should be renamed to 
{\tt IE\_init\_session}, while the variable {\tt PM\_iProc} in 
module {\tt PM\_ModProc} may have a completely different name.

The PM component wrapper provides the following six subroutines
\begin{itemize}
\item PM\_set\_param
\item PM\_init\_session
\item PM\_run
\item PM\_save\_restart
\item PM\_finalize
\end{itemize}
which will be described in detail below. All these subroutines are 
called by the control module from {\tt CON/Insterface/src/CON\_wrapper}.

\input PM_wrapper.protex

\parskip 12pt

\newpage
\subsection{Example coupler between Components PM and XY}

This subsection provides an example for the component coupling interfaces. 
The documentation is produced from the
\begin{verbatim}
doc/Tex/PM_XY_coupler.f90
\end{verbatim}
file, which contains methods for coupling particular versions of the
componets PM and XY. It can be used as a starting point 
for writing new couplers.

The coupling interfaces are not standardized, but 
they follow a typical pattern in the SWMF. The coupler
between components PM and XY consists of three parts: 
\begin{itemize}
\item the {\tt PM\_put\_from\_xy} and {\tt PM\_get\_for\_xy} subroutines 
      in {\tt PM/PmVersion/srcInterface/}
\item the {\tt XY\_put\_from\_pm} and {\tt XY\_get\_for\_pm} subroutines 
      in {\tt XY/XyVersion/srcInterface/}
\item the {\tt CON\_couple\_pm\_xy} module in {\tt CON/Interface/src/}
\end{itemize}
If the coupling is one way only, for example if data is sent from 
the XY component to the PM component only, then 
the {\tt PM\_get\_for\_xy} and {\tt XY\_put\_from\_pm}
subroutines do not need to be implemented.

The {\tt get} and {\tt put} subroutines are specific for the component 
versions.
These subroutines provide access to the data in the physics modules. 
The {\tt PM\_get} and {\tt PM\_put} subroutines are executed
on the processors that belong to the PM component, while the {\tt XY\_put} and
{\tt XY\_get} subroutines are executed on the processors that belong to the 
XY component. In these subroutines only communication internal to the 
component can occur, if any. The {\tt get} subroutines are responsible for 
converting from the internal units of the sending component to SI units,
while the {\tt put} subroutines convert from SI units to the internal
units of the receiving component. If the coupler does not use the
SWMF coupling toolkit, the interpolation from the sending grid to the
requested positions occurs in the {\tt get} or the {\tt put} subroutines.
If the SWMF coupling toolkit is used, the mapping and interpolation
are done by the toolkit.

The {\tt CON\_couple\_pm\_xy} module 
should be specific to a pair of components,
but it should be general with respect to the component versions.
The methods in the {\tt CON\_couple\_pm\_xy} module implement both PM to XY
and XY to PM coupling if the components are coupled both ways.
These methods allocate and deallocate the data buffers and transfer the data 
between the PM and XY processors. 
If the coupler does not use the SWMF coupling toolkit,
the data transfer is implemented with plain MPI calls.
If the SWMF toolkit is used, the data transfer is done by the toolkit
based on the grid descriptors and the mapping information.

The following example shows a one way coupling with plain MPI calls.
For the use of the SWMF coupling toolkit, please see the appropriate
part of the reference manual and the examples in the SWMF source code.

\input PM_XY_coupler.protex

\parskip 12pt
\newpage
%%%
% Bug Reporting
%%%
\section{Documentation}

New source code should be documented with the Protex utility.
Examples for the protex style documentation can be found in the 
{\tt share/Prologs} directory. To get a description and examples
\begin{verbatim}
cd share/Prologs
make PDF
acroread README.pdf
\end{verbatim}
There are several F90 files in the {\tt share/Prologs} directory
that can be used as templates.
The source code documentation is turned into Latex documentation
by the {\tt share/Scripts/protex.pl} script.
The file containing the documented source code should be listed
in the appropriate part of the
\begin{verbatim}
doc/Tex/Makefile
\end{verbatim}

New or modified input parameters should be described in the XML files. 
For the control module parameters this file is
\begin{verbatim}
Param/PARAM.XML
\end{verbatim}
For the component versions the XML file is located in the top level
of the component version directory named like
\begin{verbatim}
PM/PmVersion/PARAM.XML
\end{verbatim}
A brief description of the syntax of the PARAM.XML files can be obtained
by running
\begin{verbatim}
Scripts/TestParam.pl -X
Scripts/TestParam.pl -H
\end{verbatim}
The XML files are used for parameter checking with the 
\begin{verbatim}
Scripts/TestParam.pl
\end{verbatim}
script. They are also read with a text editor by the users of the SWMF.
Finally the XML files are used for producing documentation with the
\begin{verbatim}
share/Scripts/XmlToTex
\end{verbatim}
script. The PARAM.XML file should be listed in the appropriate part of the
\begin{verbatim}
doc/Tex/Makefile
\end{verbatim}

\section{Reporting Bugs}

Bugzilla is the Center for Space Environment Modeling (CSEM)
bug-tracking system and is used to submit and review defects that have
been found in the Space Weather Modeling Framework (SWMF) and other
CSEM projects. Bugzilla is not an avenue for technical assistance or
support, but simply a bug tracking system. If you submit a defect,
please provide detailed information in your submission after you have
queried Bugzilla to ensure the defect has not been reported yet. 

\begin{itemize}
\item
Community members can use this system to file bugs and to perform
searches on the bug database. 
\item
Developers can use the system to obtain details of bugs assigned to
them, and to prioritize bug-fixing activities. 
\end{itemize}

The Bugzilla system is available here:

\begin{verbatim}
      http://csem.engin.umich.edu/bugzilla/
\end{verbatim}

%%%
% Known Issues
%%%
\section{Known Issues}
\input{../RELEASENOTES}


\end{document}
