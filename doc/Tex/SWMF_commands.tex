\section{Input Commands for CON}

CON reads input parameters from the PARAM.in file and the files
included into PARAM.in. All commands interpreted by CON start
with the \# character followed by capital letters and numbers.
The commands can have an arbitrary number of parameters, 
which are written into the lines following the command. 
Other lines are ignored, and can be used for remarks.
The general format of the parameter file is
\begin{verbatim}
remarks

#COMMANDNAME1
variable1
variable2

#COMMANDNAME2

#COMMANDNAME3
variable3
\end{verbatim}

\subsection{General commands}

\subsubsection{\#INCLUDE command}

The \#INCLUDE command can be used anywhere in the parameter file,
even in the sections which contain the component specific parameters.
It has one parameter, the name of the file to be included.
The file name may be followed with a trailing comment if it
is separated with at least 3 spaces or one TAB character.
For example the information in the {\tt RESTART.in} file can be
included with
\begin{verbatim}
#INCLUDE
RESTART.in
\end{verbatim}

\subsubsection{\#END command}

The \#END command signals the end of the included file or the
end of the PARAM.in file. Lines following the \#END command are
ignored. It is not required to use the \#END command. The end
of the included file or PARAM.in file is equivalent with an \#END command
in the last line.

\subsubsection{\#STRICT command}

The \#STRICT command has a single parameter, the logical UseStrict variable.
If it is set to true, the SWMF does not attempt to correct problems,
but it stops after the warning message. If it is set to false, SWMF
attempts to correct the problems after the warning message is issued.
It is possible to switch back and forth between strict and non-strict 
mode. The default is strict mode.

\subsubsection{\#DESCRIPTION command}

The \#DESCRIPTION command has a single parameter, the StringDescription
string. It can be used to describe the simulation for which the parameter
file is written. The \#DESCRIPTION command and the StringDescription
string are saved into the restart file, which helps in identifying the
restart files. 

\subsection{Time and session control}

The execution of SWMF is done in consequtive sessions. Each session is
executed with a set of parameters read from the parameter file.
After the session is finished, CON reads and distributes the parameters for 
the next session. Parameters from previous sessions are carried over,
so only the changes relative to the previous session need to be given.

\subsubsection{\#RUN command}

The \#RUN command does not have any parameters. It signals the end
of the current session, and makes CON execute the session with
the current set of parameters. The parameters for the next session
start after the \#RUN command. For the last session there is no
need to use the \#RUN command, since the \#END command or simply
the end of the PARAM.in file makes CON execute the last session.

\subsubsection{\#SESSION command}

The \#SESSION command has a single parameter, the TypeSession string,
which can be set to 'old', 'parallel' or 'general'. The value of 
TypeSession determines how the time looping is handled by CON.

If the default value 'old' is used, then CON mimics the behaviour
of the BATSRUS time loop control: the global magnetosphere (GM) is regarded
as the main component, and other components are coupled to it.
The simulation time is that of GM. The other components are ran in 
a serial manner, i.e. they wait for the coupling, and GM waits until
they finish their execution. This time loop control is mainly preserved
for backwards compatibility.

The 'parallel' session requires that all the processing elements (PE-s)
are used by exactly one component. The components are executed in parallel,
and coupled only when conditions for the actions of coupling, saving restart 
files, or stopping execution are met. This is possible because it is known
{\it in advance} by each component when these actions will occur.
The components are required to advance to the simulation time of the next 
action. Currently the 'parallel' session model works in the time accurate 
The 'general' session behaves exactly like the 'parallel' session,
but the components are allowed to overlap, i.e. share PE-s.
If more than one component uses a PE, they all have to run to their
next coupling time. Now the simulation time for the PE is defined
as the smallest simulation time of the active components on the PE.
Currently the 'general' session model works in the timeaccurate
mode only. Generalization to the steady-state mode willbe done soon.

The 'general' session behaves exactly like the 'parallel' session,
but the components are allowed to overlap, i.e. share PE-s. 
If more than one component uses a PE, they all have to run to their
next coupling time. Now the simulation time for the PE is defined
as the smallest simulation time of the active components on the PE.
Currently the 'general' session model works in the timeaccurate
mode only. Generalization to the steady-state mode willbe done soon.

Currently the default is the 'old' mode, but in the future it
will probably be replaced with the 'general' mode.
The 'parallel' mode is mainly used as a simpler version of 
the 'general' mode for development purposes.

\subsubsection{\#TIMEACCURATE command}

The \#TIMEACCURATE command has one parameter, the logical variable
DoTimeAccurate. If DoTimeAccurate is set to true, the SWMF is solving
a time dependent problem. If DoTimeAccurate is false, a steady-state
solution is sought for. It is possible to use steady-state mode 
in the first few sessions to obtain a steady state solution,
and then to switch to time accurate mode in the following sessions.
In time accurate mode the frequency of coupling, saving restart files,
or stopping conditions are taken in simulation time, which is the 
time relative to the initial time. In steady stae mode the simulation
time is not advanced at all, instead the time step or iteration number 
is used to control the frequencies of various actions.

The steady-state mode also allows the components to use various
accelaration techniques. For example the UofM MHD code (in the GM and IH
components) can use local time stepping to accelerate convergence
to steady state. It is also envisioned that in steady state mode
the various components will be allowed to use different number 
of iterations per global iteration, thus they can converge to steady state 
at the same rate and an optimal global convergence can be achieved.

The default value is the time accurate mode.

\subsubsection{\#STARTTIME command}

The \#STARTTIME command sets the initial date and time for the
simulation in Greenwich Mean Time (GMT) or Universal Time (UT). 
It has seven parameters: the integer variables 
iYear, iMonth, iDay, iHour, iMinute and iSecond, and a real variable 
FracSecond, which stores the fractional second. This time is stored in the 
restart files. The default values are 
\begin{verbatim}
#STARTTIME
2000                        iYear
   3                        iMonth
  21                        iDay
  10                        iHour
  45                        iMinute
   0                        iSecond
   0.0                      FracSecond
\end{verbatim}
which is a date and time when both the rotational and the magnetic axes 
have approximately zero tilt towards the Sun.

\subsubsection{\#TIMESIMULATION command}

The \#TIMESIMULATION command has one parameter, the real variable
tSimulation. The tSimulation variable contains the simulation time in seconds
relative to the initial time set by the \#STARTTIME command. 
The \#TIMESIMULATION command and tSimulation are saved into the restart
file, so that the simulatation can continue from the same time when
the restart was saved.

The default value is tSimulation=0. 

\subsubsection{\#NSTEP command}

The \#NSTEP command has a one parameter, the integer nStep variable.
The nStep variable contains the number of time steps since the 
beginning of the simulation (including all restarts). The \#NSTEP command
and the nStep variable  are saved into the restart
file, so that the simulatation can continue from the same time step when
the restart was saved.

The default value is nStep=0.

\subsubsection{\#STOP command}

The \#STOP command has two parameters, the integer MaxIteration and the
real tSimulationMax variables. The MaxIteration variable contains the
maximum number of iterations {\it since the beginning of the current run} 
(in case of a restart, the time steps done before the restart do not count).
If nIteration reaches this value the session is finished.
The tSimulationMax variable contains the maximum simulation time
relative to the initial time determined by the \#STARTTIME command.
If tSimulation reaches this value the session is finished.

Using a negative value for either variables means that the
corresponding condition is  not checked. The default values
are MaxIteration=0 and tSimulationMax = 0.0, so the \#STOP command
must be used in every session.

\subsubsection{\#CHECKSTOP command}

The \#CHECKSTOP command has one or three parameters: the logical variable
DoCheckStop, the integer variable DnCheckStop and the real variable
DtCheckStop. The DoCheckStop variable controls whether CON should
check the CPU time or the existence of the SWMF.STOP file in the
run directory. If it is set to false, there is no checking.
If it is set to true, the stop conditions are checked at the
frequencies given by the DnCheckStop and DtCheckStop variables.
The DnCheckStop variable determines the frequence in temrs of
the time step number nStep, while  DtCheckStop determines the
frequency in terms of the simulation time tSimulation.
Negative values for either variable mean that the corresponding condition 
is not checked. For time accurate mode DtCheckStop, for
steady-state mode DnCheckStop is the relevant frequency.

The default value is DoCheckStop=.false., because the checks require
synchronization of the components. The more frequent the checks
are the less efficient the execution is, on the other had the
less frequent the checks are, the less control the user has to stop
the code at a given time.

\subsubsection{\#CHECKSTOPFILE command}

The \#CHECKSTOPFILE command has a single parameter, the logical variable
DoCheckStopFile. If DoCheckStopFile is true (and DoCheckStop is set
to true in the \#CHECKSTOP command) then the code checks if the
SWMF.STOP file exists in the run directory. This file is deleted at
the beginning of the run, so the user must explicitly create the file
with e.g. the 
\begin{verbatim}
touch SWMF.STOP
\end{verbatim}
UNIX command. If the file is found in the run directory,
the execution stops in a graceful manner. 
Restart files and plot files are saved as required by the 
appropriate parameters.

The default is DoCheckStopFile=.true. (but the default for DoCheckStop
is .false.).

\subsubsection{\#CPUTIMEMAX command}

The \#CPUTIMEMAX command has a single parameter: the real variable CpuTimeMax.
The CpuTimeMax variable contains the maximum allowed CPU time (wall clock
time) for the execution of the current run. If the CPU time reaches
this time, the execution stops in a graceful manner. 
Restart files and plot files are saved as required by the 
appropriate parameters.
This command is very useful when the code is submitted to a batch
queue with a limited wall clock time.

The default value is -1.0, which means that the CPU time is not checked.
To do the check the CpuTimeMax variable has to be set to a positive
value and the DoCheckStop variable also must be set to .true. in the 
\#CHECKSTOP command.

\subsection{Testing and timing}

\subsubsection{\#TEST command}

The \#TEST command has a single parameter: the string variable StringTest.
The StringTest variable contains the names of the subroutines, functions,
or modules to be tested separated by spaces. 
It is mostly used for debugging purposes.

The default value is an empty string.

\subsubsection{\#VERBOSE command}

The \#VERBOSE command has a single parameter: the integer variable lVerbose.
The lVerbose variable sets the verbosity of CON. If lVerbose is 100 or more,
all subroutines and all processors which call the 
CON\_set\_do\_test subroutine will produce a line on the stdandard output
with the name of the subroutine, the iteration number and the
processor number. When lVerbose is less than 100 but at least 10 or more,
only the test processor will produce output from CON\_set\_do\_test.
For lVerbose=1 or more some useful information is printed in CON\_main and 
CON\_io. For lVerbose=0 the verbose information is minimized.

The default value is lVerbose=1.

\subsubsection{\#TIMING command}

The \#TIMING command has four parameters: the logical variable UseTiming,
the integer variables DnTiming and TimingDepth, and the string variable
TimingStyle. If the UseTiming variable is false, no timing report is 
produced. If UseTiming is true, the rest of the variables are read.
The DnTiming variable determines how often a timing report is produced
in terms of the number of time steps nStep. The TimingDepth variable
gives the maximum depth of timing for nested subroutine calls.
Finally the TimingStyle variable determines the style of the timing
report.

The default values are
\begin{verbatim}
#TIMING
T             UseTiming
-1            DnTiming
-1            TimingDepth
cumm          TimingStyle
\end{verbatim}

The current implementation of timing is rather simple. Only the root
processor of CON does the timing. 
In the future the root processors for all PE-s will do timings 
thus giving useful information about the
load balance and efficiency of the execution.

\subsubsection{\#PROGRESS command}

The \#PROGRESS command has two parameters: the integer variables
DnShowProgressShort and DnShowProgressLong. These variables determine
the frequency of showing short and long progress reports in terms
of the number of time steps nStep. 

The default values are DnShowProgressShort=10 and DnShowProgressLong=100.
Currently both the short and the long progress reports consist
of a single line. In the future the long progress report will give
more detailed information.

\subsubsection{\#PRECISION command}

The \#PRECISION command has a single parameter: the integer variable
nByteReal. The nByteReal variable gives the number of bytes in the
default real variable. Possible values are 4 and 8. This command
serves to check consistency with binary data, such as binary
restart files. The \#PRECISION command and the nByteReal variable
are saved into the restart file. There is no default value.
If the command is not used, the precision of the real numbers is not 
checked.

\subsubsection{\#VERSION command}

The \#VERSION command has a single parameter: the real variable Version.
The Version variable contains the version number of SWMF. This command
serves to check consistency for restarted runs. The \#VERSION command
and the Version variable are saved into the restart file.
There is no default value.  If the command is not used, the version
number is not checked.

\subsection{Component control}

\subsubsection{\#COMPONENT command}

The \#COMPONENT command has two parameters: the string variable 
NameComp and the logical variable UseComp. The NameComp variable
contains the two-character component ID, while the UseComp
variable defines if the component should be used in the current
session or not. It is possible that in the initial sessions
some components are not used, and they are turned on later.
Unused components should not be coupled, and they should not
be given any parameters.

The default is that all the components registered in the LAYOUT.in
file are used.

\subsubsection{\#BEGIN\_COMP ID and \#END\_COMP ID commands}

The \#BEGIN\_COMP ID and \#END\_COMP ID commands are exceptional in the sense 
that their parameters are written in the same line as the command itself.
This exception makes the parameter file more readable. The parameter
is the two-character component ID. There must be exactly one space
between the \#BEGIN\_COMP or \#END\_COMP string and the ID.

The lines between the \#BEGIN\_COMP ID and the matching 
\#END\_COMP ID commands are passed to the component with the
corresponding ID. For example 
\begin{verbatim}
#BEGIN_COMP GM

#AMR
-1

#END_COMP GM
\end{verbatim}
The parameters passed to the components can be of arbitrary format.
The only restriction is that the length of the lines cannot exceed
100 characters (extra characters will be ignored).

\subsection{Coupling control}

\subsubsection{\#COUPLEORDER command}

The \#COUPLEORDER command has one or more parameters: the integer
variable nCouple followed by nCouple string variables NameSourceTarget.
The nCouple variable determines the maximum number of couplings
among the components. The NameSourceTarget string contains the 
two-character ID for the source and target components separated by
spaces. The order of the couplings is most important for the
couplings done at the beginning of the session. Some components need
to get information from the others before they can initialize properly.

The default coupling order is based on the propagation of information
from component to component
\begin{verbatim}
#COUPLEORDER
8                 nCouple
IH GM             NameSourceTarget
GM IE             NameSourceTarget
GM IM             NameSourceTarget
UA IE             NameSourceTarget
IE IM             NameSourceTarget
IM GM             NameSourceTarget
IE UA             NameSourceTarget
IE GM             NameSourceTarget
\end{verbatim}
The order determined here is only taken into account by the 'parallel'
and 'general' time looping models, which can be selected in
the \#SESSION command. The 'old' time looping model uses its own
coupling order (which is similar to the default shown above).

\subsubsection{\#COUPLE1 command}

The \#COUPLE1 command has four parameters: the string variables
NameSource and NameTarget, the integer variable DnCouple
and the real variable DtCouple. The NameSource and NameTarget 
variables contain the two-character component ID-s for the source
and target components. The DnCouple variable determines the frequency
of couplings in terms of the number of time steps nStep for steady state
runs, while DtCouple defines the frequency in terms of the simulation
time tSimulation in seconds for time-accurate runs. Setting both
frequencies to a negative value means that there is no coupling.

The default is no coupling between the components.

\subsubsection{\#COUPLE2 command}

The \#COUPLE2 command has four parameters: the string variables
NameComp1 and NameComp2, the integer variable DnCouple
and the real variable DtCouple. The NameComp1 and NameComp2 
variables contain the two-character component ID-s for the two
components which are coupled both ways. 
The DnCouple variable determines the frequency
of couplings in terms of the number of time steps nStep for steady state
runs, while DtCouple defines the frequency in terms of the simulation
time tSimulation in seconds for time-accurate runs. Setting both
frequencies to a negative value means that there is no coupling.

The default is no coupling between the components.

\subsubsection{\#COUPLE1SHIFT command}

The \#COUPLE1SHIFT command has six parameters: the string variables
NameSource and NameTarget, the integer variable DnCouple,
the real variable DtCouple, the integer variable nNext12 and
the real variable tNext12. The NameSource and NameTarget 
variables contain the two-character component ID-s for the source
and target components. The DnCouple variable determines the frequency
of couplings in terms of the number of time steps nStep for steady state
runs, while DtCouple defines the frequency in terms of the simulation
time tSimulation in seconds for time-accurate runs. 

For steady-state simulations the nNext12 variable determines in which time 
step the first coupling occurs after the initial coupling, namely 
when $\mod(nStep,DnCouple)$ equals nNext12. For time accurate
simulations the tNext12 variable determines at what simulation
time the first coupling occurs after the initial coupling, namely
when $\mod(tSimulation,DtCouple)$ equals tNext12.

This command allows to shift the couplings relative to each other.
For example
\begin{verbatim}
#COUPLE1SHIFT
IH                 NameSource
GM                 NameTarget
-1                 DnCouple
10.0               DtCouple
-1                 nNext12
3.0                tNext12
\end{verbatim}
will couple IH to GM at simulation times 3, 13, 23, etc.

The default is no shifting.

\subsubsection{\#COUPLE2SHIFT command}

The \#COUPLE2SHIFT command has eight parameters: the string variables
NameComp1 and NameComp2, the integer variable DnCouple,
the real variable DtCouple, the integer variable nNext12,
the real variable tNext12, the integer variable nNext21 and
the real variable tNext21. The NameComp1 and NameComp2 
variables contain the two-character component ID-s for the two
components which are coupled both ways.
The DnCouple variable determines the frequency
of couplings in terms of the number of time steps nStep for steady state
runs, while DtCouple defines the frequency in terms of the simulation
time tSimulation in seconds for time-accurate runs. 

For steady-state simulations the nNext12 variable determines in which time 
step the first coupling occurs from NameComp1 to NameComp2
after the initial coupling, namely 
when $\mod(nStep,DnCouple)$ equals nNext12. For time accurate
simulations the tNext12 variable determines at what simulation
time the first coupling occurs from NameComp1 to NameComp2
after the initial coupling, namely
when $\mod(tSimulation,DtCouple)$ equatls tNext12.

The first coupling step and time for the NameComp2 to NameComp1
coupling is determined by the nNext21 and tNext21 variables
in a similar fashion. This command allows to shift the couplings 
relative to each other. For example
\begin{verbatim}
#COUPLE2SHIFT
GM                 NameComp1
IE                 NameComp2
-1                 DnCouple
10.0               DtCouple
-1                 nNext12
3.0                tNext12
-1                 nNext21
6.0                tNext21
\end{verbatim}
will couple GM to IE at simulation times 3, 13, 23, etc, while
IE will be coupled to GM at simulation times 6, 16, 26 etc.
This way IE can solve the potential problem while GM advances by 3 seconds.
That can improve the parallelization and efficiency.

The default is no shifting.

\subsection{Restart control}

CON needs to coordinate the saving of restart information for itself
and all the components. It is important that all components save
the necessary information at the same simulation time.

\subsubsection{\#SAVERESTART command}

The \#SAVERESTART command has one or three parameters: the logical variable
DoSaveRestart, the integer variable DnSaveRestart and the 
real variable DtSaveRestart. The DoSaveRestart variable determines
whether restart information should be saved or not. The rest of
the parameters are read only if DoSaveRestart is true. 
For steady state runs the frequency of saving restart information is given by
the DnSaveRestart variable in terms of the number of time steps nStep,
while for time accurate run, the DtSaveRestart variable determines
the frequency in terms of the simulation time tSimulation in seconds.
Negative frequencies mean that no restart file is saved during the run,
but they do not exclude the saving of the restart information at
the very end. In fact this is the default:
\begin{verbatim}
#SAVERESTART
T               DoSaveRestart
-1              DnSaveRestart
-1.0            DtSaveRestart
\end{verbatim}

\subsubsection{\#RESTARTFILE command}

The \#RESTARTFILE command has a single parameter: the string variable
NameRestartFile. The NameRestartFile variable contains the file name
for the restart file for CON itself. This file contains information
such as initial time, simulation time and time step, version number,
description of the simulation, name of the planet, etc. The file
is in the same format as PARAM.in, so it can be simply included
with the \#INCLUDE command. 

The default value for NameRestartFile is ``RESTART.in''.

\subsection{Output control}

\subsubsection{\#ECHO command}

The \#ECHO command has a single parameter: the logical variable DoEcho.
If the DoEcho variable is true, the input parameters are echoed back.
The echoing either goes to the standard output or into the log files
depending on the UseStdout variable, which can be set in the
\#STDOUT command.

The default value for DoEcho is .false., but it is a good idea to
set it to true at the beginning of the PARAM.in file.

\subsubsection{\#STDOUT command}

The \#STDOUT command has a single parameter: the logical variable UseStdout.
If the UseStdout variable is true, the echoed input parameters and other
verbose information produced by the components are written to the
standard output. To distinguish between the output produced by the
various components, a prefix string is written at the beginning 
of the lines. Usually the prefix string contains the component ID, the
processor number if the line is written by a processor which 
is not the root processor of the component, and a colon (for example
``GM0001:'').
Even with the prefix, it may be difficult to collect the output
from the various components and processors. The order of the output
depends on how the MPI library buffers that, which is platform
dependent. 

If the UseStdout variable is false, the echoed input parameters and other
verbose information produced by the components are written 
into separate files in the STDOUT directory (the name of
this directory can be changed by the \#STDOUTDIR command). 
The files are named similarly to the prefix string: 
the component ID is followed by the global processor number
and a ``.log'' extension is added. For example the root processor
of GM may write into ``STDOUT/GM0014.log'' if GM's root processor 
has global rank 14.

Note that warnings and error messages should always be written to
the standard output, and they should always have a prefix which
identifies the component issuing the warning or error.
CON itself always writes to the standard output and it does not
use a string prefix.

The default value for UseStdout is true.

\subsubsection{\#STDOUTDIR command}

The \#STDOUTDIR command has a single parameter: the string variable
NameStdoutDir. The NameStdoutDir variable contains the name of the
directory where the log files with the redirected standard output
of the components are written if UseStdout is set to .false. in
the \#STDOUT command. 

The default value of NameStdoutDir is ``STDOUT''.

\subsection{Planet parameters}

Several components share information about the planet for which the
simulation is done. It is important that the various components
use compatible information about the planet. It is also useful
for the couplers that they can globally access this information,
such as radius and orientation of the planet, or its magnetic
field. The SWMF is designed to work for an arbitrary planet.
It also allows to change some parameters of the planet relative
to the real values.

By default the SWMF works with Earth and its real parameters.
Another planet can be selected with the \#PLANET command.
The real planet parameters can be modified and simplified
with the other planet commands listed in this subsection.
These modifier commands {\it cannot preceed} the \#PLANET command!

\subsubsection{\#PLANET command}

The \#PLANET command has one or more parameters: the string
variable NamePlanet, and in case the name of the planet
is not recognized, the real variables RadiusPlanet,
MassPlanet, OmegaPlanet, TiltRotation, the string variable
TypeBField, which is followed by the real variables
MagAxisThetaGeo, MagAxisPhiGeo and DipoleStrength
in case the TypeBField is set to ``DIPOLE''.

Currently only ``EARTH'' is recognized, which is the default
value for NamePlanet.

\subsubsection{\#ROTATIONAXIS command}

The \#ROTATIONAXIS command has one or three parameters: the logical variable
IsRotAxisPrimary and the real variables RotAxisTheta and RotAxisPhi.
If the IsRotAxisPrimary variable is false, the rotational axis
is aligned with the magnetic axis. If it is true, the other two variables
are read, which give the position of the rotational axis at the
initial time in the GSE coordinate system. Both angles are read in degrees
and stored internally in radians.

The default is to use the true rotational axis determined by the 
date and time given by \#STARTTIME.

\subsubsection{\#ROTATION command}

The \#ROTATION command has one or two parameters: the logical variable
UseRotation and the real variable RotationPeriod. If UseRotation
is false, the planet is assumed to stand still, and the OmegaPlanet
variable is set to zero. If UseRotation is true, the RotationPeriod
variable is read in hours, and it is converted to the 
angular speed OmegaPlanet given in radians/second.
Note that OmegaPlanet is relative to an inertial coordinate system,
so the RotationPeriod is not 24 hours for the Earth, but the
length of the astronomical day.

The default is to use rotation with the real rotation period of the planet.

\subsubsection{\#MAGNETICAXIS command}

The \#MAGNETICAXIS command has one or three parameters: the logical variable
IsMagAxisPrimary and the real variables MagAxisTheta and MagAxisPhi.
If the IsMagAxisPrimary variable is false, the magnetic axis
is aligned with the rotational axis. If it is true, the other two variables
are read, which give the position of the magnetic axis at the
initial time in the GSE coordinate system. Both angles are read in degrees
and stored internally in radians.

The default is to use the true magnetic axis determined by the 
date and time given by \#STARTTIME.

\subsubsection{\#DIPOLE command}

The \#DIPOLE command has a single parameter: the real variable
DipoleStrength. The DipoleStrength variable contains the 
magnetic equatorial strength of the dipole magnetic field in Tesla.

The default value is the real dipole strength for the planet.
For the Earth it is taken to be $-3.11\times 10^{-5}\,$Tesla.
The sign is taken to be negative so that the magnetic axis can 
point northward as usual.

\subsubsection{\#NONDIPOLE command}

The \#NONDIPOLE command has one or more parameters: the logical
variable UseNonDipole and the real variables determining the
non-dipole terms of the magnetic field. If UseNonDipole is false,
the non-dipole terms of the magnetic field of the planet are neglected.
If it is true, the non-dipole terms can be overwritten. Currently
the SWMF is restricted to dipole fields for the planets.
In the future offset dipoles and quadrupole and octupole terms
will be implemented.

\subsubsection{\#UPDATEB0 command}

The \#UPDATEB0 command has a single parameter: the real variable
DtUpdateB0. This variable determines how often the position of
the magnetic axis is recalculated. A negative value indicates that
the motion of the magnetic axis during the course of the simulation
is neglected. This is an optimization parameter, since recalculating
the values which depend on the orientation of the magnetic
field can be costly. Since the magnetic field moves relatively
slowly as the planet rotates around, it may not be necessary
to continuously update the magnetic field orientation.

This feature is now implemented in a simplistic manner: GM
simply gets this value from CON and uses it for setting the frequency of
updating the magnetic field information, which is stored locally.
In the future the optimization should be done inside CON too.

The default value is 0.0001, which means that the magnetic axis
is continuously followed.

\subsubsection{\#IDEALAXES command}

The \#IDEALAXES command has no parameters. It sets both the rotational
and magnetic axes parallel with the ecliptic North direction. In fact
it is identical with 
\begin{verbatim}
#ROTATIONAXIS
T               IsRotAxisPrimary
0.0             RotAxisTheta
0.0             RotAxisPhi

#MAGNETICAXIS
F               IsMagAxisPrimary
\end{verbatim}
but much shorter.

\subsection{Command for the stub components}

If SWMF is compiled with the interface in {\tt srcCON/Stubs},
the stub components recognize only one command {\tt \#TIMESTEP}.
This command has two real parameters: the real variables
DtRun and DtCpu. The DtRun variable defines the typical time step of 
the component in terms of simulation time. The DtCpu variable 
determines the CPU time needed to execute one time step for the component.
Both variables are given in seconds. For example:
\begin{verbatim}

#BEGIN_COMP GM ------------------------------------------------

#TIMESTEP
0.01       DtRun (the typical time step of the component)
0.12       DtCpu (the CPU time needed for 1 time step)

#END_COMP GM --------------------------------------------------

#BEGIN_COMP IH ------------------------------------------------

#TIMESTEP
10.0       DtRun (the typical time step of the component)
0.15       DtCpu (the CPU time needed for 1 time step)

#END_COMP IH --------------------------------------------------

#BEGIN_COMP IM ------------------------------------------------

#TIMESTEP
5.0       DtRun (the typical time step of the component)
3.0       DtCpu (the CPU time needed for 1 time step)

#END_COMP IM --------------------------------------------------

\end{verbatim}
Of course it is not necessary to put in the actual CPU times.
One can take the same fraction for all components to accelerate
the run.
