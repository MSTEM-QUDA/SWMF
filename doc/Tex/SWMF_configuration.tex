\section{Configuration of SWMF}

SWMF will be configurable via the GUI and/or with the Configure.pl script.
In the current prototype these advanced configurations have not been 
implemented yet.

The configuration for SWMF now consists of setting compiler flags,
selecting the appropriate components and the configuration
of the individual components.

\subsection{Setting compiler flags}

The compiler flags can be modified by editing
\begin{verbatim}
Common/Makefile.conf
\end{verbatim}
This makefile is created during installation, and it contains the
platform and compiler specific part of the makefile system.
Depending on the platform and compiler, one can change the
precision of real numbers by setting the {\tt PRECISION} variable,
the optimization level by setting the {\tt Cflag0...Cflag4},
and the debug flags by setting the {\tt DEBUG} variable.
For example, on a Linux machine with Nag F95 compiler, a single
precision, zero optimization level, debugging run can be done
with the following settings:
\begin{verbatim}
#PRECISION = -r8
PRECISION =
...
#DEBUG   = -dusty -w -maxcontin=50
DEBUG   = -dusty -w -C -gline -maxcontin=50

Cflag0  = ${SEARCH} -c -O0 ${PRECISION} ${DEBUG}
Cflag1  = ${SEARCH} -c -O0 ${PRECISION} ${DEBUG}
Cflag2  = ${SEARCH} -c -O0 ${PRECISION} ${DEBUG}
Cflag3  = ${SEARCH} -c -O0 ${PRECISION} ${DEBUG}
Cflag4  = ${SEARCH} -c -O0 ${PRECISION} ${DEBUG}
\end{verbatim}
Note that not all the components take into account the selected
compiler flags. For example the IM/RCM component cannot be 
compiled with double precision, thus it uses the flags
defined in the {\tt CFLAGS} variable. Also some of the files
do not work if compiled with high optimization level.
Such exceptions are described in the makefile of the 
components.

\subsection{Selecting component versions}

The component versions reside in the directories GM, IE, IH, IM, and UA.
Most components have only one working version and one empty version.
The empty version consist of a single wrapper file, which contains 
empty subroutines required by CON\_wrapper and the couplers.
These empty subroutines are needed for the compilation of the code,
and they also show the interface of the working versions.

The appropriate version can be selected by editing the
\begin{verbatim}
Common/Makefile.COMP
\end{verbatim}
file. To select a version, simply comment out and uncomment the
appropriate lines. For example, to select the UofM version
for GM and the empty version for IH the file should be edited 
like this
\begin{verbatim}
GM_VERSION = UofM
#GM_VERSION = Empty

#IH_VERSION = UofM_share
#IH_VERSION = UofM
IH_VERSION = Empty
...
\end{verbatim}
The IH component is special, as it has three versions: the empty version,
the UofM\_share version, and the UofM version. The UofM\_share version
contains a working wrapper file but otherwise it shares the source code
with the GM/UofM component. Since the source codes are shared, the
IH and GM components cannot run on the same PE-s, and they cannot be
configured separately. On the other hand they use the same variables,
so no memory is wasted.

The IH/UofM version is also based on the GM/UofM version, however
the source code is copied over and all modules, common blocks,
and external subroutines and functions are renamed. 
These steps are all automated and can be performed by typing
\begin{verbatim}
make IHUOFM
\end{verbatim}
in the main directory. To use this version, it needs to be selected
in {\tt Common/Makefile.COMP} and compiled. With the renamed
IH/UofM version it is allowed to run IH and GM on the same PE,
and they can be configured differently.

\subsection{Configuration of components}

Some of the components can be configured individually. 
The Configure.pl script can configure the GM/UofM and IH/UofM codes,
however this has not been tested for the SWMF yet. 

Currently the configuration consists of selecting the 
appropriate user file and setting the number and size of the
adaptive blocks. The user file contains specialized
source terms, boundary and initial conditions. It can be 
selected by copying the appropriate file into {\tt user\_routines.f90}.
For example
\begin{verbatim}
cd GM/UofM
cp user/user_routines.f90.something user_routines.f90
cd IH/UofM
cp user/user_routines_helio.f90 user_routines.f90
\end{verbatim}
For sake of convenient testing the heliosphere user routine is
the default one now, so there is no need to copy the user files.

The block size and the number of blocks can be set by editing the
\begin{verbatim}
GM/UofM/ModSize.f90
IH/UofM/ModSize.f90
\end{verbatim}
files. On machines with limited memory it is especially important to
set the number of blocks correctly. The file contains the {\tt nBLK}
variable, which is the number of blocks per processor, and the
{\tt MaxImplBLK} variable, which is the maximum number of blocks
advanced with the implicit time stepping algorithm, which is a
rather expensive algorithm in terms of memory usage. In case the
component does not use the implicit time stepping, it is best to set
\begin{verbatim}
integer, parameter :: MaxImplBLK = min(MaxBlock, 1)
\end{verbatim}
The number of blocks per processor should be set such that the total
number of blocks (which is {\tt nBLK} times the number of PE-s
assigned to the component) is sufficient for the whole simulation,
including AMR refinements. 

\subsection{Using stubs for all components}

It is possible to compile and run SWMF without the physics components.
This can be used as a test tool for the CON component, but it may
also serve as an inexpensive testbed for getting the optimal layout
and coupling schedule for a simulation. To configure SWMF with 
stub components, edit {\tt Common/Makefile.COMP} such that it
uses the Empty version for all the physics components, and select
\begin{verbatim}
#INT_VERSION = Interface
INT_VERSION = Stubs
\end{verbatim}
for the interface so that the real interface in {\tt srcCON/Interface}
is replaced with {\tt srcCON/Stubs}.
The resulting executable will run CON with 
the stubs for the physics components. For the stubs one can
specify the time step size in terms of simulation time and the
CPU time needed for the time step. The stub components communicate
at the coupling time, so the PE-s need to synchronize, but 
(at least in the current implementation) there is no net time taken
for the coupling itself. 

% The stub IE component behaves the same way as the real IE component.
