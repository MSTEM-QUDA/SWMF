\section{Configuration of SWMF}

The SWMF is configurable at various levels:
\begin{itemize}
\item The whole software package can be configured %^CMP IF CONFIGURE
      with a subset of the components.             %^CMP IF CONFIGURE
\item A particular version, including the Empty version,
      of the component can be selected
\item A subset of the non-empty components can be registered in 
      the LAYOUT.in file.
\item Registered components can be turned off and on with the \#COMPONENT
      command in the PARAM.in file.
\item Some of the components can be configured individually.
\end{itemize}
Each of these options have their useful application.

%^CMP IF CONFIGURE BEGIN
The Configure.pl script can build a new software package which
contains only a subset of the components. The whole
component directory and all references to the component 
in the source code, in the scripts and the Makefiles are removed.
This type of configuration results in a smaller software package.
The main use of this type of configuration is to distribute
a part of SWMF to users. For example one can create a 
software distribution which includes GM, IE and UA only by typing
\begin{verbatim}
  Configure.pl -on=GM,IE,UA -off=SC,IH,SP,IM,RB
\end{verbatim}
The configured package will be in the Build directory.
\begin{verbatim}
  Configure.pl -h
\end{verbatim}
to get complete usage information and/or read the reference manual.
%^CMP END CONFIGURE

Selecting the Empty version for unused components reduces
compilation time and memory usage during run time.
It may also improve performance slightly.
This is achieved with the {\tt -v} flag of the SetSWMF.pl script. 
For example the Empty UA component can be selected with
\begin{verbatim}
  SetSWMF.pl -v=UA/Empty
\end{verbatim}
Components can also be excluded from a run by omitting them from the LAYOUT.in 
file, which means that the component is not 'registered' at run time.
Note that empty component versions cannot be registered at all.
Component registration allows to run the same executable with different 
subsets of the components. For example the GM and IE components 
can be selected with the following LAYOUT.in file
\begin{verbatim}
ID   proc0 last  stride
#COMPONENTMAP
GM     0    999     1
IE     0      1     1
#END
\end{verbatim}
The first column contains the component ID, the second is the
root processor for the component, the third column is the
last processor and the last column contains the stride.
In the example GM will run on all available PE-s, while IE
will run on the first 2 PE-s. 

Finally components can be switched on and off during a run
with the \#COMPONENT command in the PARAM.in file. 
This approach allows the component to be switched on in a later 
'session' of the run. For example, in the first session only GM 
is running, while in the second session it is coupled to IE. 
In this example the IE component can be switched off with the
\begin{verbatim}
#COMPONENT
IE              NameComp
F               UseComp
\end{verbatim}
in the first session and it can be switched on with the
\begin{verbatim}
#COMPONENT
IE              NameComp
T               UseComp
\end{verbatim}
command in the second session.

\subsection{Selecting component versions}

The component versions reside in the directories GM, IE, IH, IM, RB, SC,
SP and UA.
Most components have only one working version and one empty version.
The empty version consists of a single wrapper file, which contains 
empty subroutines required by CON\_wrapper and the couplers.
These empty subroutines are needed for the compilation of the code,
and they also show the interface of the working versions.

The appropriate version can be selected with the {\tt -v} flag
of the {\tt SetSWMF.pl} script, which edits the
\begin{verbatim}
  Makefile.def
\end{verbatim}
file. The IH/BATSRUS and SC/BATSRUS components are special, since they use the
same source code as GM/BATSRUS. The IH component has three versions: 
the empty version, the BATSRUS\_share version, and the BATSRUS version. 
The BATSRUS\_share version contains a working wrapper file but otherwise 
it shares the source code
with the GM/BATSRUS component. Since the source codes are shared, the
IH and GM components cannot run on the same PE-s, and they cannot be
configured separately. On the other hand they use the same variables,
so no compilation time and memory are wasted.

The IH/BATSRUS version is also based on the GM/BATSRUS version, however
the source code is copied over and all modules, common blocks,
and external subroutines and functions are renamed. 
These steps are all automated and can be performed by typing
\begin{verbatim}
SetSWMF.pl -v=IH/BATSRUS
\end{verbatim}
in the main directory. With the renamed IH/BATSRUS version it is allowed 
to run IH and GM on the same PE, and they can be configured differently.
The SC/BATSRUS component is also derived from the GM/BATRUS source code,
but it is configured differently so the source code is always copied
and renamed. This can be achievd by
\begin{verbatim}
SetSWMF.pl -v=SC/BATSRUS
\end{verbatim}
The copied and renamed source code is removed fully when SWMF is
uninstalled with the
\begin{verbatim}
SetSWMF.pl -uninstall
\end{verbatim}
command. If the SC/BATSRUS or IH/BATSRUS source codes need to be
refreshed, the following steps should be done
\begin{verbatim}
cd SC/BATSRUS
make veryclean
cd ../..
make SCBATSRUS
\end{verbatim}
and similarly
\begin{verbatim}
cd IH/BATSRUS
make veryclean
cd ../..
make IHBATSRUS
\end{verbatim}

\subsection{Setting compiler flags}

The compiler flags can be modified by editing
\begin{verbatim}
  Makefile.conf
\end{verbatim}
This makefile is created during installation, and it contains the
platform and compiler specific part of the makefile system.
Depending on the platform and compiler, one can change the
precision of real numbers by setting the {\tt PRECISION} variable,
the optimization level by setting the {\tt Cflag0...Cflag4},
and the debug flags by setting the {\tt DEBUG} variable.
For example, on a Linux machine with Nag F95 compiler, a single
precision, zero optimization level, debugging run can be done
with the following settings:
\begin{verbatim}
#PRECISION = -r8
PRECISION =
...
#DEBUG   = -dusty -w -maxcontin=50
DEBUG   = -dusty -w -C -gline -maxcontin=50

Cflag0  = ${SEARCH} -c -O0 ${PRECISION} ${DEBUG}
Cflag1  = ${SEARCH} -c -O0 ${PRECISION} ${DEBUG}
Cflag2  = ${SEARCH} -c -O0 ${PRECISION} ${DEBUG}
Cflag3  = ${SEARCH} -c -O0 ${PRECISION} ${DEBUG}
Cflag4  = ${SEARCH} -c -O0 ${PRECISION} ${DEBUG}
\end{verbatim}
Note that not all the components take into account the selected
compiler flags. For example the IM/RCM component cannot be 
compiled with double precision, thus it uses the flags
defined in the {\tt CFLAGS} variable. Also some of the files
do not work if compiled with high optimization level.
Such exceptions are described in the makefiles of the 
components. 

The PRECISION variable can be conveniently changed with the
{\tt -p} flag of the SetSWMF.pl script. For example single
precision can be selected with
\begin{verbatim}
  SetSWMF.pl -p=single
\end{verbatim}
If the precision is modified with the SetSWMF.pl script,
the distribution will be automatically cleaned with 
{\tt make clean}, which has to be done before recompiling the
code with a different precision. 

\subsection{Configuration of components}

Some of the components can be configured individually. 
The Configure.pl script can configure the {\tt GM/BATSRUS} code, for example.
The configured code can be linked to {\tt GM/BATSRUS\_conf}, which can
be selected as the GM component.

The configuration also consists of selecting the 
appropriate user file and setting the number and size of the
adaptive blocks. The user file contains specialized
source terms, boundary and initial conditions. It can be 
selected by copying the appropriate file into {\tt user\_routines.f90}.
For example
\begin{verbatim}
cd GM/BATSRUS
cp user/user_routines.f90.something user_routines.f90
cd IH/BATSRUS
cp user/user_routines.f90.heliosphere user_routines.f90
\end{verbatim}
For sake of convenient testing the heliosphere user routine is
the default one now, so there is no need to copy the user files.

The block size and the number of blocks can be set with the 
{\tt -g} flag of the {\tt SetSWMF.pl} script.
For example the
\begin{verbatim}
  SetSWMF.pl -g=UA:36,36,50,4,4
\end{verbatim}
will et the blocks size to $36\times 36\times 50$ and the number of blocks to 
$4\times 4$ for the UA component. This command runs the {\tt GridSize.pl}
script of the UA component. To get more detailed information, one can
check the {\tt GridSize.pl} script directly, e.g.
\begin{verbatim}
  cd GM/BATSRUS
  GridSize.pl -h
  GridSize.pl -s
\end{verbatim}
On machines with limited memory it is especially important to
set the number of blocks correctly. 

Another way of reducing the total memory usage is to use dynamic
allocation. For example the BATSRUS code can use either static or
dynamic allocation of the largest variables. The default is static
for sake of fast execution. To switch to dynamic allocation type
for example
\begin{verbatim}
  cd GM/BATSRUS/src
  make DYNAMIC
\end{verbatim}
Of course the SWMF code has to be recompiled.

\subsection{Using stubs for all components}

It is possible to compile and run SWMF without the physics components.
This can be used as a test tool for the CON component, but it may
also serve as an inexpensive testbed for getting the optimal layout
and coupling schedule for a simulation. To configure SWMF with 
stub components, select the Empty version for all physics components
(with SetSWMF.pl -v=...) and edit the {\tt Makefile.def} file to
contain
\begin{verbatim}
#INT_VERSION = Interface
INT_VERSION = Stubs
\end{verbatim}
for the interface so that the real interface in {\tt CON/Interface}
is replaced with {\tt CON/Stubs}.
The resulting executable will run CON with 
the stubs for the physics components. For the stubs one can
specify the time step size in terms of simulation time and the
CPU time needed for the time step. The stub components communicate
at the coupling time, so the PE-s need to synchronize, but 
(at least in the current implementation) there is no net time taken
for the coupling itself. 

The stub components help development of the SWMF core, but it also
allows an efficient optimization of the LAYOUT and coupling
schedules for an actual run, where the physical time steps
and the CPU time needed by the components is approximately known.
In the test runs with the Stubs, one can reduce the CPU times by 
a fixed factor, so it takes less CPU time to see the efficiency of the 
SWMF for a given layout and coupling scheme.
