%  Copyright (C) 2002 Regents of the University of Michigan, portions used with permission 
%  For more information, see http://csem.engin.umich.edu/tools/swmf
\section{Configuration of SWMF}

Configuration refers to several different ways of controlling how the 
SWMF is compiled and run.  The most obvious is the setting of
compiler flags specific to the machine and version of FORTRAN
compiler.  The other methods refer to ways in which different physics
components are chosen to participate in or not participate in a run.
Inclusion of components can be controlled using one of several methods:

\begin{itemize}
\item The source code can modified so that all references %^CMP IF CONFIGURE
      to a subset of the components is removed. %^CMP IF CONFIGURE
      This method uses the Scripts/Configure.pl script. %^CMP IF CONFIGURE
      In a similar way, some physics components can be individually
      configured.
\item The user may select which version of a physics component,
      including the Empty version,
      should be compiled.  This is controlled using the Config.pl script.
\item When submitting a run, a subset of the non-empty (compiled) 
      components can be
      registered to participate in the run in the LAYOUT.in file.
\item Registered components can be turned off and on with the \#COMPONENT
      command in the PARAM.in file.
\end{itemize}
Each of these options have their useful application.

Finally, each physics component may have some settings which need to
(or can) be individually
configured, such as selecting user routines for the IH/BATSRUS or
GM/BATSRUS components.

%^CMP IF CONFIGURE BEGIN
\subsection{Scripts/Configure.pl}

The Scripts/Configure.pl script can build a new software package which
contains only a subset of the components. It is a simple interface
for the general share/Scripts/Configure.pl script. The configuration
can remove a whole component directory and all references to the component 
in the source code, in the scripts and the Makefiles.
This type of configuration results in a smaller software package.
The main use of this type of configuration is to distribute
a part of SWMF to users. For example one can create a 
software distribution which includes GM, IE and UA only by typing
\begin{verbatim}
  Scripts/Configure.pl -on=GM,IE,UA -off=SC,IH,SP,IM,PW,RB
\end{verbatim}
The configured package will be in the Build directory.  Type
\begin{verbatim}
  Scripts/Configure.pl -h
\end{verbatim}
to get complete usage information or read about this script 
in the reference manual.
%^CMP END CONFIGURE

\subsection{Selecting component versions to compile with Config.pl}

The physics component versions reside in the directories 
GM, IE, IH, IM, RB, PW, SC, SP and UA.
Most components have only one working version and one empty version.
The empty version consists of a single wrapper file, which contains 
empty subroutines required by CON\_wrapper and the couplers.
These empty subroutines are needed for the compilation of the code,
and they also show the interface of the working versions.

The appropriate version can be selected with the {\tt -v} flag
of the {\tt Config.pl} script, which edits the
\begin{verbatim}
  Makefile.def
\end{verbatim}
file. The IH/BATSRUS and SC/BATSRUS components are special, since they use the
same source code as GM/BATSRUS. The IH component has three versions: 
the empty version, the BATSRUS\_share version, and the BATSRUS version. 
The BATSRUS\_share version contains a working wrapper file but otherwise 
it shares the source code
with the GM/BATSRUS component. Since the source codes are shared, the
IH and GM components cannot run on the same PE-s, and they cannot be
configured separately. On the other hand they use the same variables,
so no compilation time and memory are wasted.

The IH/BATSRUS version is also based on the GM/BATSRUS version, however
the source code is copied over and all modules, common blocks,
and external subroutines and functions are renamed. 
These steps are all automated and can be performed by typing
\begin{verbatim}
Config.pl -v=IH/BATSRUS
\end{verbatim}
in the main directory. With the renamed IH/BATSRUS version it is allowed 
to run IH and GM on the same PE, and they can be configured differently.
The SC/BATSRUS component is also derived from the GM/BATSRUS source code,
but it is configured differently so the source code is always copied
and renamed. This can be achieved by
\begin{verbatim}
Config.pl -v=SC/BATSRUS
\end{verbatim}
The copied and renamed source code is removed fully when SWMF is
uninstalled with the
\begin{verbatim}
Config.pl -uninstall
\end{verbatim}
command. If the SC/BATSRUS or IH/BATSRUS source codes need to be
refreshed, the following steps should be done
\begin{verbatim}
cd SC/BATSRUS
make distclean
cd ../..
make SCBATSRUS
\end{verbatim}
and similarly
\begin{verbatim}
cd IH/BATSRUS
make distclean
cd ../..
make IHBATSRUS
\end{verbatim}

\subsection{Selecting Empty component versions with Config.pl}

If a physics component is not needed for run, an Empty version of the
component can be compiled.
Selecting the Empty version for unused components reduces
compilation time and memory usage during run time.
It may also improve performance slightly.
This is achieved with the {\tt -v} flag of the Config.pl script. 
For example the Empty UA component can be selected with
\begin{verbatim}
  Config.pl -v=UA/Empty
\end{verbatim}
It is also possuble to select the Empty version for all components
with a few exceptions. For example
\begin{verbatim}
  Config.pl -v=Empty,GM/BATSRUS,IE/Ridley_serial
\end{verbatim}
will select the empty version for all components except for GM and IE.
Note that the 'Empty' item has to be the first one.

\subsection{Registering components using LAYOUT.in}

Components can also be excluded from a run by omitting them from the LAYOUT.in 
file, which means that the component is not 'registered' at run time.
Note that empty component versions cannot be registered at all.
Component registration allows to run the same executable with different 
subsets of the components. For example the GM and IE components 
can be selected with the following LAYOUT.in file
\begin{verbatim}
ID   proc0 last  stride
#COMPONENTMAP
GM     0    999     1
IE     0      1     1
#END
\end{verbatim}
The first column contains the component ID, the second is the
root processor for the component, the third column is the
last processor and the last column contains the stride.
In the example GM will run on all available PE-s, while IE
will run on the first 2 PE-s.  Changing the file to
\begin{verbatim}
ID   proc0 last  stride
#COMPONENTMAP
GM     0    999     1
#END
\end{verbatim}
will still use the same executable, but will not allow the IE 
physics component to participate in the run.

\subsection{Controlling physics components with PARAM.in}

Finally components can be switched on and off during a run
with the \#COMPONENT command in the PARAM.in file. 
This approach allows the component to be switched on in a later 
'session' of the run. For example, in the first session only GM 
is running, while in the second session it is coupled to IE. 
In this example the IE component can be switched off with the
\begin{verbatim}
#COMPONENT
IE              NameComp
F               UseComp
\end{verbatim}
in the first session and it can be switched on with the
\begin{verbatim}
#COMPONENT
IE              NameComp
T               UseComp
\end{verbatim}
command in the second session.

\subsection{Setting compiler flags}

The debugging flags can be switched on and off with
\begin{verbatim}
  Config.pl -debug
\end{verbatim}
and
\begin{verbatim}
  Config.pl -nodebug
\end{verbatim}
respectively. The maximum optimization level can be set to -O2 with
\begin{verbatim}
  Config.pl -O2
\end{verbatim}
The minimum level is 0, the maximum is 5. Note that not all compilers support
level 5 optimization.

Note that not all the components take into account the selected
compiler flags. For example the IM/RCM2 component has to be compiled 
with the -save (or similar) flag, thus it uses the flags defined in the 
{\tt CFLAGS} variable. Also some of the compiler produce incorrect
code if they compile certain source files with high optimization level.
Such exceptions are described in the 
\begin{verbatim}
  Makefile.RULES.all
\end{verbatim}
files in the source code directories. The content of this file
is processed by {\tt Config.pl} into {\tt Makefile.RULES}
(according to the selected compiler and other parameters),  
which is then included into the main Makefile. 

\subsection{Configuration of individual components}

Some of the components can be configured individually. 
The {\tt GM/BATSRUS} code, for example, can be configure to
use specific equation and user modules.
For example
\begin{verbatim}
cd GM/BATSRUS
Config.pl -e=MhdIonsPe
\end{verbatim}
will select the equation module for multiple ion fluids and separate
electron pressure. The same can be done with the {\tt Config.pl} script
in the main SWMF directory
\begin{verbatim}
Config.pl -o=GM:e=MhdIonsPe
\end{verbatim}
The grid sizes of the various components can be set with the 
{\tt -g} flag of the {\tt Config.pl} script.
For example the
\begin{verbatim}
  Config.pl -g=UA:36,36,50,16
\end{verbatim}
will set the blocks size to $36\times 36\times 50$ and the number of blocks to 
16 for the UA/GITM2 component. This command runs the {\tt Config.pl}
script of the selected UA component. 
On machines with limited memory it is especially important to
set the number of blocks correctly. 

Of course, the SWMF code has to be recompiled after any of these changes.

\subsection{Using stubs for all components}

It is possible to compile and run SWMF without the physics components
but with place holders (stubs) for them that mimic their behavior.
This can be used as a test tool for the CON component, but it may
also serve as an inexpensive testbed for getting the optimal layout
and coupling schedule for a simulation. To configure SWMF with 
stub components, select the Empty version for all physics components
(with Config.pl -v=...) and edit the {\tt Makefile.def} file to
contain
\begin{verbatim}
#INT_VERSION = Interface
INT_VERSION = Stubs
\end{verbatim}
for the interface so that the real interface in {\tt CON/Interface}
is replaced with {\tt CON/Stubs}.
The resulting executable will run CON with 
the stubs for the physics components. For the stubs one can
specify the time step size in terms of simulation time and the
CPU time needed for the time step. The stub components communicate
at the coupling time, so the PE-s need to synchronize, but 
(at least in the current implementation) there is no net time taken
for the coupling itself. 

The stub components help development of the SWMF core, but it also
allows an efficient optimization of the LAYOUT and coupling
schedules for an actual run, where the physical time steps
and the CPU time needed by the components is approximately known.
In the test runs with the Stubs, one can reduce the CPU times by 
a fixed factor, so it takes less CPU time to see the efficiency of the 
SWMF for a given layout and coupling scheme.

An alternative way to test performance with different configurations is
to use the Scripts/Performance.pl script.
