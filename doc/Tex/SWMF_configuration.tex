\section{Configuration of SWMF}

SWMF is configurable via the GUI and/or with the 
Configure.pl script and                             %^CMP IF CONFIGURE
SetSWMF.pl script.

The configuration for SWMF now consists of setting compiler flags,
selecting the appropriate components and the configuration
of the individual components.

\subsection{Setting compiler flags}

The compiler flags can be modified by editing
\begin{verbatim}
Makefile.conf
\end{verbatim}
This makefile is created during installation, and it contains the
platform and compiler specific part of the makefile system.
Depending on the platform and compiler, one can change the
precision of real numbers by setting the {\tt PRECISION} variable,
the optimization level by setting the {\tt Cflag0...Cflag4},
and the debug flags by setting the {\tt DEBUG} variable.
For example, on a Linux machine with Nag F95 compiler, a single
precision, zero optimization level, debugging run can be done
with the following settings:
\begin{verbatim}
#PRECISION = -r8
PRECISION =
...
#DEBUG   = -dusty -w -maxcontin=50
DEBUG   = -dusty -w -C -gline -maxcontin=50

Cflag0  = ${SEARCH} -c -O0 ${PRECISION} ${DEBUG}
Cflag1  = ${SEARCH} -c -O0 ${PRECISION} ${DEBUG}
Cflag2  = ${SEARCH} -c -O0 ${PRECISION} ${DEBUG}
Cflag3  = ${SEARCH} -c -O0 ${PRECISION} ${DEBUG}
Cflag4  = ${SEARCH} -c -O0 ${PRECISION} ${DEBUG}
\end{verbatim}
Note that not all the components take into account the selected
compiler flags. For example the IM/RCM component cannot be 
compiled with double precision, thus it uses the flags
defined in the {\tt CFLAGS} variable. Also some of the files
do not work if compiled with high optimization level.
Such exceptions are described in the makefiles of the 
components.

\subsection{Selecting component versions}

The component versions reside in the directories GM, IE, IH, IM, RB, SC,
SP and UA.
Most components have only one working version and one empty version.
The empty version consists of a single wrapper file, which contains 
empty subroutines required by CON\_wrapper and the couplers.
These empty subroutines are needed for the compilation of the code,
and they also show the interface of the working versions.

The appropriate version can be selected with the {\tt -v} flag
of the {\tt SetSWMF.pl} script, which edits the
\begin{verbatim}
Makefile.def
\end{verbatim}
file. The IH/BATSRUS and SC/BATSRUS components are special, since they use the
same source code as GM/BATSRUS. The IH component has three versions: 
the empty version, the BATSRUS\_share version, and the BATSRUS version. 
The BATSRUS\_share version contains a working wrapper file but otherwise 
it shares the source code
with the GM/BATSRUS component. Since the source codes are shared, the
IH and GM components cannot run on the same PE-s, and they cannot be
configured separately. On the other hand they use the same variables,
so no compilation time and memory are wasted.

The IH/BATSRUS version is also based on the GM/BATSRUS version, however
the source code is copied over and all modules, common blocks,
and external subroutines and functions are renamed. 
These steps are all automated and can be performed by typing
\begin{verbatim}
SetSWMF.pl -v=IH/BATSRUS
\end{verbatim}
in the main directory. With the renamed IH/BATSRUS version it is allowed 
to run IH and GM on the same PE, and they can be configured differently.
The SC/BATSRUS component is also derived from the GM/BATRUS source code,
but it is configured differently so the source code is always copied
and renamed. This can be achievd by
\begin{verbatim}
SetSWMF.pl -v=SC/BATSRUS
\end{verbatim}
The copied and renamed source code is removed fully when SWMF is
uninstalled with the
\begin{verbatim}
SetSWMF.pl -uninstall
\end{verbatim}
command. If the SC/BATSRUS or IH/BATSRUS source codes need to be
refreshed, the following steps should be done
\begin{verbatim}
cd SC/BATSRUS
make veryclean
cd ../..
make SCBATSRUS
\end{verbatim}
and similarly
\begin{verbatim}
cd IH/BATSRUS
make veryclean
cd ../..
make IHBATSRUS
\end{verbatim}

\subsection{Configuration of components}

Some of the components can be configured individually. 
The Configure.pl script can configure the {\tt GM/BATSRUS} code, for example.
The configured code can be linked to {\tt GM/BATSRUS\_conf}, which can
be selected as the GM component.

The configuration also consists of selecting the 
appropriate user file and setting the number and size of the
adaptive blocks. The user file contains specialized
source terms, boundary and initial conditions. It can be 
selected by copying the appropriate file into {\tt user\_routines.f90}.
For example
\begin{verbatim}
cd GM/BATSRUS
cp user/user_routines.f90.something user_routines.f90
cd IH/BATSRUS
cp user/user_routines.f90.heliosphere user_routines.f90
\end{verbatim}
For sake of convenient testing the heliosphere user routine is
the default one now, so there is no need to copy the user files.

The block size and the number of blocks can be set with the 
{\tt -g} flag of the {\tt SetSWMF.pl} script.
For example the
\begin{verbatim}
SetSWMF.pl -g=UA:36,36,50,4,4
\end{verbatim}
will et the blocks size to $36\times 36\times 50$ and the number of blocks to 
$4\times 4$ for the UA component. This command runs the {\tt GridSize.pl}
script of the UA component. To get more detailed information, one can
check the {\tt GridSize.pl} script directly, e.g.
\begin{verbatim}
cd GM/BATSRUS
GridSize.pl -h
GridSize.pl -s
\end{verbatim}
On machines with limited memory it is especially important to
set the number of blocks correctly. 

Another way of reducing the total memory usage is to use dynamic
allocation. For example the BATSRUS code can use either static or
dynamic allocation of the largest variables. The default is static
for sake of fast execution. To switch to dynamic allocation type
for example
\begin{verbatim}
cd GM/BATSRUS/src
make DYNAMIC
\end{verbatim}
Of course the SWMF code has to be recompiled.

\subsection{Using stubs for all components}

It is possible to compile and run SWMF without the physics components.
This can be used as a test tool for the CON component, but it may
also serve as an inexpensive testbed for getting the optimal layout
and coupling schedule for a simulation. To configure SWMF with 
stub components, select the Empty version for all physics components
(with SetSWMF.pl -v=...) and edit the {\tt Makefile.def} file to
contain
\begin{verbatim}
#INT_VERSION = Interface
INT_VERSION = Stubs
\end{verbatim}
for the interface so that the real interface in {\tt CON/Interface}
is replaced with {\tt CON/Stubs}.
The resulting executable will run CON with 
the stubs for the physics components. For the stubs one can
specify the time step size in terms of simulation time and the
CPU time needed for the time step. The stub components communicate
at the coupling time, so the PE-s need to synchronize, but 
(at least in the current implementation) there is no net time taken
for the coupling itself. 

The stub components help development of the SWMF core, but it also
allows an efficient optimization of the LAYOUT and coupling
schedules for an actual run, where the physical time steps
and the CPU time needed by the components is approximately known.
In the test runs with the Stubs, one can reduce the CPU times by 
a fixed factor, so it takes less CPU time to see the efficiency of the 
SWMF for a given layout and coupling scheme.
