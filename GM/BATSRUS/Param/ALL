<commandList>

List of commands used in the PARAM.in file
This is the structure of the XML tags.
The tags are shown with parentheses (instead of less and greater signs).

(commandlist)
(set name=... type=... value=.../)
(set name=... type=... value=.../)
...
(commandgroup name=...)
(command name=... [if=...] [required="T"])
	(parameter name=... type="logical" default=.../)
	(parameter name=... type="integer" [min=...] [max=...] [default=...]/)
	(parameter name=... type="real" [min=...] [max=...] [default=...]/)
	(parameter name=... type="string" length=.../)
	(parameter name=... type="integer|real|string" input="select"
							[multiple="T"])
		(option name=... [value=...] [default="T"] 
					[exclusive="T"] [if=...]/)
		(optioninput name=... type=... [min=...] [max=...] [length=...]
						[default=...] [if=...]/)
	(parameter/)
	(parameter name=... type="strings" min="..." max="..."
					[ordered="T"] [duplicate="T"])
		(part name=... type="string" input="select"
					[required="T"] [multiple="T"])
			(option name=... [value=...] [default="T"] 
					[exclusive="T"] [if=...]/)
		(/part)
	(/parameter)
	(if expr=...)
		(parameter name=... type="real" [min=...] [max=...] 
							default=... /)
	(/if)
	(foreach name=... values=...)
		(parameter name=... type="logical" default=.../)
		...
	(/foreach)
	(for [index=] from=... to=...)
		(parameter name=... type="integer" [min=...] [max=...]
							default=.../)
		...
	(/for)
	(set name=... type=... value=.../)
	(rule expr=...)
	... error message for command rule ...
	(/rule)
verbal description of command
...
(/command)
(command name=... [required="T"] [if=...])
...
(/command)
...
(/commandgroup)
(commandgroup name=...)
...
...
...
(/commandgroup)
...
...
...
...
...
...
(rule expr=...)
... error message for global rule ...
(/rule)
(rule expr=...)
... error message for global rule ...
(/rule)
(commandlist)

<!-- Initial defaults that influence the parameter fields -->
<set name="IsFirstSession" type="logical" value="T" />
<set name="IsNewSession"   type="logical" value="F" />
<set name="Done"           type="logical" value="F" />
<set name="DoTimeAccurate" type="logical" value="F" />

<commandgroup name="TESTING AND TIMING">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!  TESTING AND TIMING PARAMETERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="TEST">
	<parameter name="TestString" type="string" length="100"/>
#TEST
read_inputs

! A space separated list of subroutine names. Default is empty string.
!
! Examples:
!   read_inputs  - echo the input parameters following the #TEST line
!   ionosphere   - info on the ionosphere      <!-- ^CFG IF IONOSPHERE -->
!   project_B    - info on projection scheme   <!-- ^CFG IF PROJECTION -->
!   implicit     - info on implicit scheme     <!-- ^CFG IF IMPLICIT   -->
!   krylov       - info on the Krylov solver   <!-- ^CFG IF IMPLICIT   -->
!   message_count- count messages
!   initial_refinement
!   ...
! Check the subroutines for call setoktest("...",oktest,oktest_me) to
! see the appropriate strings.
</command>

<command name="TESTIJK">
	<parameter name="iTest"      type="integer" min="-2" 
		max="$nI+2"/>
	<parameter name="jTest"      type="integer" min="-2" 
		max="$nJ+2"/>
	<parameter name="kTest"      type="integer" min="-2" 
		max="$nK+2"/>
	<parameter name="iBlockTest" type="integer" min="1"
		max="$MaxBlock" />
	<parameter name="iProcTest"  type="integer" min="0" />
#TESTIJK
1                       iTest           (cell index for testing)
1                       jTest           (cell index for testing)
1                       kTest           (cell index for testing)
1                       BlockTest       (block index for testing)
0                       ProcTest        (processor index for testing)

! The location of test info in terms of indices, block and processor number.
! Note that the user should set #TESTIJK or #TESTXYZ, not both.  If both
! are set, the final one in the session will set the test point.
</command>

<command name="TESTXYZ">
	<parameter name="xTest" type="real" 
				min="$xMin" max="$xMax" />
	<parameter name="yTest" type="real" 
				min="$yMin" max="$yMax" />
	<parameter name="zTest" type="real" 
				min="$zMin" max="$zMax" />
#TESTXYZ
1.5                     xTest           (X coordinate of cell for testing)
-10.5                   yTest           (Y coordinate of cell for testing)
-10.                    zTest           (Z coordinate of cell for testing)

! The location of test info in terms of coordinates.
! Note that the user should set #TESTIJK or #TESTXYZ, not both.  If both
! are set, the final one in the session will set the test point.
</command>

<command name="TESTTIME">
	<parameter name="nIterTest" type="integer" min="-1" default="-1"   />
	<parameter name="TimeTest"  type="real"    min="-1" default="1e30" 
		if="$DoTimeAccurate" />
#TESTTIME
-1                      nIterTest       (iteration number to start testing)
10.5                    TimeTest        (time to start testing in seconds)
                                                Only read if timeaccurate!

! The time step and physical time to start testing.
</command>

<command name="TESTVAR">
	<parameter name="iVarTest" type="integer" input="select">
		<option name="Rho"   value="1" default="T" />
		<option name="RhoUx" value="2" />
		<option name="RhoUy" value="3" />
		<option name="RhoUz" value="4" />
		<option name="Bx"    value="5" />
		<option name="By"    value="6" />
		<option name="Bz"    value="7" />
		<option name="e"     value="8" />
		<option name="p"     value="9" />
        </parameter>
#TESTVAR
1                       iVarTest

! Index of variable to be tested. Default is rho_="1", ie. density.
</command>

<command name="TESTDIM">
	<parameter name="iVarTest" type="integer" input="select">
		<option name="all" value="0" />
		<option name="x"   value="1" default="T" />
		<option name="y"   value="2" />
		<option name="z"   value="3" />
        </parameter>
#TESTDIM
1                       iDimTest

! Index of dimension/direction to be tested. Default is X dimension.
</command>

<command name="STRICT">
	<parameter name="UseStrict" type="logical" default="T" />
#STRICT
T                       UseStrict

! If true then stop when parameters are incompatible. If false, try to
! correct parameters and continue. Default is true, ie. strict mode
</command>

<command name="VERBOSE">
	<parameter name="iVarTest" type="integer" input="select">
		<option name="errors and warnings only"  value="-1" />
		<option name="start and end of sessions" value="0"  />
		<option name="normal"                   value="1" default="T"/>
		<option name="calls on test processor"   value="10" />
		<option name="calls on all processors"   value="100" />
        </parameter>
#VERBOSE
-1                      lVerbose

! Verbosity level controls the amount of output to STDOUT. Default level is 1.
!   lVerbose .le. -1 only warnings and error messages are shown.
!   lVerbose .ge.  0 start and end of sessions is shown.
!   lVerbose .ge.  1 a lot of extra information is given.
!   lVerbose .ge. 10 all calls of set_oktest are shown for the test processor.
!   lVerbose .ge.100 all calls of set_oktest are shown for all processors.
</command>

<command name="DEBUG">
	<parameter name="DoDebug"      type="logical" default="F" />
	<parameter name="DoDebugGhost" type="logical" default="F" />
#DEBUG
F                       DoDebug         (use it as if(okdebug.and.oktest)...)
F                       DoDebugGhost    (parameter for show_BLK in library.f90)

! Excessive debug output can be controlled by the global okdebug parameter
</command>

<command name="CODEVERSION" if="$IsFirstSession">
	<parameter name="CodeVersion" min="0" default="7.50" type="real" />
#CODEVERSION
7.50                    CodeVersion

! Cheks CodeVersion. Prints a WARNING if it differs from the CodeVersion
! defined in ModMain. Used in newer restart header files. 
! Should be given in PARAM.in when reading old restart files, 
! which do not have version info in the header file.
</command>

<command name="PRECISION" if="$IsFirstSession">
	<parameter name="nByteReal" type="integer" input="select">
		<option name="single precision (4)" value="4" 
			default="not $doublePrecision"	/>
		<option name="double precision (8)" value="8"
			default="$doublePrecision"	/>
	</parameter>
#PRECISION
8                       nByteReal

! Define the number of bytes in a real number. If it does not agree
! with the value determined by the code, BATSRUS stops with an error.
! This is a check, the internal value is calculated in parallel_setup.
! Used in latest restart header files to check binary compatibility.
! May be given in PARAM.in to enforce a certain precision.
</command>

<command name="CHECKGRIDSIZE" if="$IsFirstSession">
	<parameter name="nI" type="integer" 
		min="$nI" max="$nI" default="$nI" />
	<parameter name="nJ" type="integer" 
		min="$nJ" max="$nJ" default="$nJ" />
	<parameter name="nK" type="integer" 
		min="$nK" max="$nK" default="$nK" />
	<parameter name="MinBlockALL" type="integer" min="1" />
#CHECKGRIDSIZE
       4                        nI
       4                        nJ
       4                        nK
     576                        MinBlockALL

! Checks block size, and number of blocks. Stops with an error message,
! if nI, nJ, or nK differ from those set in ModSize. 
! Also stops if number_of_blocks exceeds nBLK*numprocs, where nBLK 
! is defined in ModSize and numprocs is the number of processors.
! This command is used in the restart headerfile to check consistency,
! and it is also useful to check if the executable is consistent with the 
! requirements of the problem described in the PARAM.in file.
</command>

<command name="BLOCKLEVELSRELOADED">
#BLOCKLEVELSRELOADED
This command means that the restart file contains the information about
the minimum and maximum allowed refinement levels for each block.
This command is only used in the restart header file.
</command>

<command name="TIMING">
	<parameter name="UseTiming" type="logical" default="T" />
	<if expr="$UseTiming">
		<parameter name="Frequency" type="integer" input="select">
			<option name="none"              value="-3" />
			<option name="final only"        value="-2" 
								default="T" />
	                <option name="end of sessions"   value="-1" />
			<optioninput name="every X steps" min="1" 
							default="100" />
		</parameter>
		<parameter name="nDepthTiming" type="integer" min="-1" 
							default="-1" />
		<parameter name="TypeTimingReport" type="string" 
							input="select">
			<option name="cummulative" value="cumm" default="1" />
			<option name="list" />
			<option name="tree" />
		</parameter>
	</if>
#TIMING
T                       UseTiming      (rest of parameters read if true)
-2                      DnTiming       (-3 none, -2 final, -1 each session/AMR)
-1                      nDepthTiming   (-1 for arbitrary depth)
cumm                    TypeTimingReport   ('cumm', 'list', or 'tree')

! The default values are shown.
!
! If UseTiming=.true., the TIMING module must be on.
! If UseTiming=.false., the execution is not timed.
!
! Dntiming determines the frequency of timing reports.
! If DnTiming .ge.  1, a timing report is produced every dn_timing step.
! If DnTiming .eq. -1, a timing report is shown at the end of each session,
!                    before each AMR, and at the end of the whole run.
! If DnTiming .eq. -2, a timing report is shown at the end of the whole run.
! If DnTiming .eq. -3, no timing report is shown.
!
! nDepthTiming determines the depth of the timing tree. A negative number
! means unlimited depth. If TimingDepth is 1, only the full BATSRUS execution
! is timed.
!
! TypeTimingReport determines the format of the timing reports:
! 'cumm' - cummulative list sorted by timings
! 'list' - list based on caller and sorted by timings
! 'tree' - tree based on calling sequence
</command>

<command name="SPEEDFILES">
	<parameter name="DoWriteSpeedFile" type="logical" default="F" />
#SPEEDFILES
F                       DoWriteSpeedFile

! controls the writing of speed_ files.  These have been used mostly on the
! cray to do timing tests.  The default is .false.
</command>

<command name="PROGRESS">
	<parameter name="DnProgressShort" type="integer" min="-1" 
		default="10"  />
	<parameter name="DnProgressLong"  type="integer" min="-1" 
		default="100" />
#PROGRESS
10                      DnProgressShort (frequency of short reports to STDOUT)
100                     DnProgressLong  (frequency of long summaries to STDOUT)

! These are the defaults. Set -1-s for no progress reports.
</command>

</commandgroup>
<commandgroup name="INITIAL AND BOUNDARY CONDITIONS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!! MAIN INITIAL AND BOUNDARY CONDITION PARAMETERS  !!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="PROBLEMTYPE" required="T" if="$IsFirstSession">
	<parameter name="iProblem" type="integer" input="select">
		<option name="Uniform"		value="1"		/>
		<option name="Shock tube" 	value="2"		/>
		<option name="Heliosphere"	value="3"		/>
		<option name="Comet"		value="5"		/>
		<option name="Rotation"		value="6"		/>
		<option name="Diffusion"	value="7"		/>
		<option name="Earth"		value="11" default="T"	/>
		<option name="Saturn"		value="12"		/>
		<option name="Jupiter"		value="13" 		/>
		<option name="Venus"		value="14" 		/>
		<option name="Cylinder"		value="21" 		/>
		<option name="Sphere"		value="22" 		/>
		<option name="Arcade"		value="25" 		/>
		<option name="CME"		value="26" 		/>
		<option name="Dissipation"	value="30"		/>
	</parameter>
	<parameter name="TypeDissipation" type="string" length="20"
						if="$iProblem==30"	/>
#PROBLEMTYPE
30			iProblem
heat_test1		TypeProblemDiss

! select a problem type which defines defaults for a lot of parameters
!
! Problem type has to be defined as the first item after #TEST..#DEBUG items!
!
!                           iProblem: 1=MHD Uniform Flow
!                                     2=Shock tube
!                                     3=Solar Wind and Inner Heliosphere
!                                     5=Mass-Loaded Comet
!                                     6=Rotation test
!                                     7=Diffusion test
!                                    11=Earth Magnetosphere
!                                    12=Saturn Magnetosphere
!                                    13=Jupiter Magnetosphere
!                                    14=Venus Ionosphere
!                                    21=Conducting Cylinder (2-D)
!                                    22=Conducting Sphere   (3-D)
!                                    25=Arcade
!                                    26=CME
!				     30=Test Dissipative MHD
</command>

<command name="RESTART" if="$IsFirstSession">
	<parameter name="DoRestart" type="logical" default="F" />

	<if expr="$DoRestart">
		<defined name="CODEVERSION"   />
		<defined name="CHECKGRIDSIZE" />
		<defined name="PRECISION"     />
		<defined name="PROBLEMTYPE"   />
		<defined name="NEWRESTART"    />
		<defined name="NSTEP"         />
		<defined name="STARTTIME"	    />
		<defined name="GRID"          />
		<defined name="SOLARWIND"     />
		<defined name="BODY"          />
		<defined name="SECONDBODY"    />
	</if>
#RESTART
T               DoRestart

! Default is DoRestart=.false.
! If true, read restartIN/restart.H file as an include file and the
! restartIN/blk* and restartIN/octree files to initialize the run. 
! For restart files created by old (prior to 6.07) version of the code,
! the content of restart.H is ignored.
! For newly created restart files it is equivalent with
!
!  #INCLUDE
!  restartIN/restart.H
!
! Note that this command should be near the very start of the PARAM.in
! file because the reading of the restartIN/restart.H include file
! sets several test parameters.
</command>

<!-- ^CFG IF CONSTRAINB BEGIN -->
<command name="NEWRESTART" if="$IsFirstSession">
	<parameter name="IsRestartBFace" type="logical" default="F" />
! The restartIN/restart.H file always contains the #NEWRESTART command.
! This command is really used only in the restart headerfile.  Generally
! it is not inserted in a PARAM.in file by the user.
!
! Other than setting RestartBFace (used by the Constrained Transport scheme)
! The #NEWRESTART command also sets the following global variables:
!   DoRestart=.true.          read restart files
!   DoRestartGhost=.false.    no ghost cells are saved into restart file
!   DoRestartReals=.true.     only real numbers are saved in blk*.rst files
</command>
<!-- ^CFG END CONSTRAINB -->

<command name="GRID" required="T" if="$IsFirstSession">
	<parameter name="nRootX" type="integer" min="1"  default="2" />
	<parameter name="nRootY" type="integer" min="1"  default="1" />
	<parameter name="nRootZ" type="integer" min="1"  default="1" />
	<parameter name="xMin"   type="real"             default="-192.0" />
	<parameter name="xMax"   type="real" min="$xMin" default="  64.0" />
	<parameter name="yMin"   type="real"             default=" -64.0" />
	<parameter name="yMax"   type="real" min="$yMin" default="  64.0" />
	<parameter name="zMin"   type="real"             default=" -64.0" />
	<parameter name="zMax"   type="real" min="$zMin" default="  64.0" />
#GRID
2                       nIRoot_D(1)
1                       nJRoot_D(2)
1                       nKRoot_D(3)
-224.                   xMinALL
 32.                    xMaxALL
-64.                    yMinALL
 64.                    yMaxALL
-64.                    zMinALL
 64.                    zMaxALL

! Grid size should always be set.
! nRootX, nRootY, nRootZ define the number of blocks of the base grid, ie.
! the roots of the octree. Each root block must be on a differenet PE.
</command>

<command name="OUTERBOUNDARY">
	<foreach name="Side" values=
	"TypeBcEast,TypeBcWest,TypeBcSouth,TypeBcNorth,TypeBcBot,TypeBcTop">
		<parameter name="$Side" type="string" input="select">
			<option name="fixed/inflow"  />
			<option name="float/outflow" />
			<option name="reflect"/>
			<option name="periodic"/>
			<option name="vary"/>
			<option name="shear"/>
			<option name="linetied"/>
			<option name="raeder"/>
			<option name="arcadetop"/>
			<option name="arcadebot"/>
			<option name="arcadebotcont"/>
		</parameter>
	</foreach>
	<rule
	expr="not($TypeBcEast eq 'periodic' xor $TypeBcWest eq 'periodic')">
	! East and west BCs must be both periodic or neither
	</rule>
	<rule
	expr="not($TypeBcSouth eq 'periodic' xor $TypeBcNorth eq 'periodic')">
	! South and North BCs must be both periodic or neither
	</rule>
	<rule
	expr="not($TypeBcBot eq 'periodic' xor $TypeBcTop eq 'periodic')">
	! Bottom and top BCs must be both periodic or neither
	</rule>
#OUTERBOUNDARY
outflow                 TypeBcOuter_E(East_)
inflow                  TypeBcOuter_E(West_)
float                   TypeBcOuter_E(South_)
float                   TypeBcOuter_E(North_)
float                   TypeBcOuter_E(Bot_)
float                   TypeBcOuter_E(Top_)

! Default depends on problem type.
! Possible values:
! fixed/inflow  - fixed solarwind values
! fixedB1       - fixed solarwind values without correction for the dipole B0
! float/outflow - zero gradient
! linetied      - float P, rho, and B, reflect all components of U
! raeder        - Jimmy Raeder's BC
! reflect       - reflective
! periodic      - periodic
! vary          - time dependent BC (same as fixed for non time_accurate)
! shear         - sheared (intended for shock tube problem only)
! arcadetop     - intended for arcade problem only
! arcadebot     - intended for arcade problem only
! arcadebotcont - intended for arcade problem only
</command>

<command name="INNERBOUNDARY">
! Inner boundary types for body 1 and body 2
	<parameter name="TypeInnerBc" type="string" input="select">
		<option name="reflect"				/>
		<option name="float"				/>
		<option name="fixed"				/>
		<option name="ionosphere"	default="T"	/>
		<option name="ionosphereB0" value="ionosphereB0/ionosphereb0"/>
		<option name="ionospherefloat"			/>
	</parameter>
<!-- ^CFG IF SECONDBODY BEGIN -->
	<if expr="$UseBody2">
		<parameter name="TypeInnerBcBody2" type="string" 
							input="select">
			<option name="reflect"		default="T"	/>
			<option name="float"				/>
			<option name="fixed"				/>
			<option name="ionosphere"			/>
			<option name="ionosphereB0"			/>
			<option name="ionospherefloat"			/>
		</parameter>
	</if>
	<rule
	expr="not($TypeInnerBcBody2 =~ /ionosphere/)">
! Note: for the second body COROTATION AND AN IONOSPHERIC BOUNDARY DO NOT WORK.
	</rule>
<!-- ^CFG END SECONDBODY -->
#INNERBOUNDARY
ionosphere              InnerBCType
<!-- ^CFG IF SECONDBODY BEGIN -->
ionosphere              InnerBCTypeBody2  !read only if UseBody2=.true. 
!This command should appear after the #SECONDBODY command if using 2 bodies
! Note:  for the second body COROTATION AND AN IONOSPHERIC BOUNDARY DO NOT
!        WORK.
! Default boundary for the second body is reflect.
<!-- ^CFG END SECONDBODY -->


! Default is ionosphere for Earth, Saturn, Jupiter, and problem_rotation.
! For all other problems with an inner boundary the default is 'reflect'.
! If UseIonosphere=.true., velocity is determined by the coupled ionosphere
! model.
!
! Possible values for TypeBcInner are
!
! 'reflect'     - reflect Vr, reflect Vphi to rotation, float Vtheta,
!                 reflect Br, float Bphi, float Btheta, float rho, float P
! 'float'       - float Vr, reflect Vphi to rotation, float Vtheta,
!                 float B, float rho, float P
! 'fixed'       - Vr=0, Vphi=rotation, Vtheta=0
!                 B=B0 (ie B1=0), fix rho, fix P
! 'ionosphere'  - set V as if ionosphere gave V_iono=0
!                 float B, fix rho, fix P
! 'ionospherefloat'-set V as if ionosphere gave V_iono=0
!                 float B, float rho, float P
</command>

<command name="EXTRABOUNDARY">
	<parameter name="UseExtraBoundary" type="logical" default="F"/>
	<if expr="$UseExtraBoundary">
		<parameter name="TypeBcExtra" type="string"/>
		<parameter name="DoFixExtraboundary" type="logical" 
							default="F"/>
	</if>
</command>

<command name="FACEOUTERBC">
	<parameter name="MaxBoundary" type="integer" min="0" max="6"
							default="0" />
	<if expr="$MaxBoundary >= 1">
		<parameter name="DoFixOuterBoundary" type="logical" 
							default="F"/>
	</if>
#FACEOUTERBC
0              MaxBoundary            
F              DoFixOuterBoundary)    !read only for MaxBoundary>=East_(=1).
! if MaxBoundary>=East_(=1) then the outer boundaries with
! the number of boundary being between East_ and MaxBoundary
! are treated using set_BCs.f90 subroutines instead of set_outerBCs.f90 
! if DoFixOuterBoundary==.true., there is no resolution
! change along the outer boundaries with the number of
! of boundary being between East_ and MaxBoundary
</command>
</commandgroup>
<commandgroup name="INITIAL TIME">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!! INITIAL TIME AND STEP !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="STARTTIME" alias="SETREALTIME" if="$IsFirstSession">
	<parameter name="year"   type="integer" default="2000" />
	<parameter name="month"  type="integer" min="1" max="12" default="3"/>
	<parameter name="day"    type="integer" min="1" max="31" default="21"/>
	<parameter name="hour"   type="integer" min="0" max="23" default="0" />
	<parameter name="minute" type="integer" min="0" max="59" default="0" />
	<parameter name="second" type="integer" min="0" max="59" default="0" />
#STARTTIME
2000                    StartTime_i(1)=year
3                       StartTime_i(2)=month
21                      StartTime_i(3)=day
0                       StartTime_i(4)=hour
0                       StartTime_i(5)=minute
0                       StartTime_i(6)=second

! These are the default values. Obsolete command name was #SETREALTIME.
</command>

<command name="NSTEP" if="$IsFirstSession">
	<parameter name="nStep" type="integer" min="0" default="0" />
#NSTEP
100                     nStep

! Set nStep. Typically used in the restart.H header file.
! The default is nStep=0 as the starting time step with no restart
! This file is really used only in the restart headerfile.  Generally
! it is not inserted in a PARAM.in file by the user.
</command>
</commandgroup>
<commandgroup name="TIME INTEGRATION">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!  TIME INTEGRATION PARAMETERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="TIMESTEPPING">
	<parameter name="DoTimeAccurate" type="logical" default="F" />
	<parameter name="nStage" type="integer" input="select">
		<option value="1" default="T" />
		<option value="2" />
	</parameter>
	<parameter name="CflExpl" type="real" min="0" max="1" default="0.8" />
#TIMESTEPPING
T                       DoTimeAccurate         (default is false)
2                       nStage                 (default is 1 stage)
0.80                    CflExpl                (default is 0.8)

! Parameters for explicit time integration
! Default is NOT time accurate with 1 stage and CflExpl=0.8
! For time accurate runs define this item before any of the items below
</command>

<command name="FIXEDTIMESTEP">
	<parameter name="UseDtFixed" type="logical" default="F" />
	<parameter name="DtFixedDim" type="real" min="0" default="1.0" />
#FIXEDTIMESTEP
T                       UseDtFixed
10.                     DtFixedDim [sec] (read if UseDtFixed is true)

! Default is UseDtFixed=.false. Effective only if time_accurate is true.
! If UseDtFixed is true, the time step is fixed to DtFixedDim.
!
! This is useful for debugging explicit schemes.
<!-- ^CFG IF IMPLICIT BEGIN -->
! The real application is, however, for implicit and partially
! implicit/local schemes.
<!-- ^CFG END IMPLICIT -->
</command>

<!-- ^CFG IF IMPLICIT BEGIN -->
<command name="PARTLOCAL">
	<parameter name="UsePartLocal" type="logical" default="F" />
#PARTLOCAL
T               UsePartLocal

! Default is UsePartLocal=.false. If UsePartLocal is true and the
! run is time accurate, then the blocks selected as "implicit"
! by the criteria defined in #STEPPINGCRITERIA are not used to
! calculate the time step, and all cells are advanced with the
! smaller of the stable and the global time steps.
</command>

<command name="IMPLICIT">
	<parameter name="UsePointImplicit" type="logical" default="F"/> <!-- ^CFG IF POINTIMPLICIT -->
	<parameter name="UsePartImplicit" type="logical" default="F"/>
	<parameter name="UseFullImplicit" type="logical" default="F"/>
	<rule
	expr="$UsePointImplicit + $UsePartImplicit + $UseFullImplicit &lt;= 1">
	At most one of these logicals can be true!
	</rule>
#IMPLICIT
F               UsePointImplicit   <!-- ^CFG IF POINTIMPLICIT -->
F               UsePartImplicit
F               UseFullImplicit
100.0           CflImpl

! Default is false for all logicals. Only one of them can be set to true!
! The CFL number is used in the implicit blocks of the fully or partially
! implicit schemes. Ignored if UseDtFixed is true.
</command>
<!-- ^CFG END IMPLICIT -->
</commandgroup>

<!-- ^CFG IF IMPLICIT BEGIN -->
<commandgroup name="IMPLICIT PARAMETERS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!! PARAMETERS FOR FULL AND PART IMPLICIT TIME INTEGRATION !!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="IMPLICITCRITERIA" alias="STEPPINGCRITERIA">
	<parameter name="TypeImplCrit" type="string" input="select">
		<option name="Time step"	value="dt" default="T"	/>
		<option name="Radial distance"	value="r/R"		/>
		<option name="Test block"	value="test"		/>
	</parameter>
	<parameter name="rImplicit" type="real" min="0"
		if="$TypeImplCrit eq 'R'" />
! Both #IMPLICITCRITERIA and #STEPPINGCRITERIA are acceptable.
! Only effective if PartImplicit or PartLocal is true in a time accurate run.
! Default value is ImplCritType='dt'.
!
! The options are
!
! If     (TypeImplCrit =='dt'  ) then blocks with DtBLK .gt. DtFixed
! ElseIf (TypeImplCrit =='R'   ) then blocks with rMinBLK .lt. rImplicit
! ElseIf (TypeImplCrit =='test') then block iBlockTest on processor iProcTest
!
! are handled with local/implicit scheme.
! DtFixed must be defined in #FIXEDTIMESTEP
</command>

<command name="IMPLSTEP">
	<parameter name="ImplCoeff" type="real" min="0" max="1" default="1"/>
	<parameter name="UseBdf2"   type="logical" default="$DoTimeAccurate" />
	<parameter name="UseSourceImpl" type="logical" default="F" />
! For steady state run the default values are shown. For second order
! time accurate run the default is UseBdf2=T, since
! BDF2 is a 3 level second order stable implicit scheme.
! This can be overwritten with #IMPLSTEP after the #TIMESTEPPING command.
! For example one could use the 2-level trapezoid scheme with
! ImplCoeff=0.5 and UseBDF2=F. ImplCoeff is the coefficient for R^{n+1}.
! For BDF2 scheme ImplCoeff is used in the first time step only, later on it
! is overwritten by the BDF2 scheme.
! UseSourceImpl true means that the preconditioner should take point
! source terms into account. Default is false.
</command>

<command name="IMPLSCHEME">
	<parameter name="nOrderImpl" type="integer" input="select">
		<option name="1" default="T"	/>
		<option name="2"		/>
	</parameter>
	<parameter name="TypeFluxImpl" type="string" input="select">
	    <option name="Roe"     value="Roe/roe/1"/>   							<!--^CFG IF ROEFLUX-->
	    <option name="Rusanov" value="Rusanov/rusanov/2/TVDLF"				 default="T"/>	<!--^CFG IF RUSANOVFLUX-->
	    <option name="Linde"   value="Linde/linde/3/HLLEL"/>						<!--^CFG IF LINDEFLUX-->
	    <option name="Sokolov" value="Sokolov/sokolov/4/AW"/>						<!--^CFG IF AWFLUX   -->
	</parameter>
#IMPLSCHEME
1               nOrderImpl
Rusanov         TypeFluxImpl

! Default values are shown, ie. first order Rusanov scheme.
! This defines the scheme used in the implicit part.
</command>

<command name="NEWTON">
	<parameter name="UseNewton" type="logical" default="F"/>
	<if expr="$UseNewton">
		<parameter name="UseNewMatrix" type="logical" default="T"/>
		<parameter name="MaxIterNewton" type="integer" min="1"
							   default="10" />
	</if>
#NEWTON
T               UseNewton
F               UseNewMatrix  (only read if UseNewton is true)
10              MaxIterNewton (only read if UseNewton is true)

! Default is UseNewton=F, ie. only one "Newton" iteration is done.
! UseNewMatrix decides whether the Jacobian should be recalculated
! for every Newton iteration. MaxIterNewton is the maximum number
! of Newton iterations before giving up.
</command>

<command name="JACOBIAN">
	<parameter name="TypeJacobian" type="string" input="select">
		<option name="Preconditioned" value="prec" default="T"	/>
		<option name="No preconditioning" value="free"		/>
	</parameter>
	<parameter name="JacobianEps" type="real" min="0" max="1.e-5" 
		default="$doublePrecision ? 1.e-12 : 1.e-6" />
#JACOBIAN
prec            TypeJacobian (prec, free)
1.E-12          JacobianEps

! The Jacobian matrix is always calculated with a matrix free approach,
! however it can be preconditioned  ('prec'), or not ('free')
! Default value is TypeJacobian='prec'.
! JacobianEps contains the machine round off error for numerical derivatives.
! The default value is 1.E-12 for 8 byte reals and 1.E-6 for 4 byte reals.
</command>

<command name="PRECONDITIONER">
	<parameter name="TypePrecondSide" type="string" input="select">
		<option name="left"			/>
		<option name="symmetric" default="T"	/>
		<option name="right"			/>
	</parameter>
	<parameter name="TypePrecond" type="string" input="select">
		<option name="MBILU" default="T" />
	</parameter>
	<parameter name="GustafssonPar" type="real" min="0" max="1" 
							default="0.5" />
#PRECONDITIONER
symmetric       TypePrecondSide (left, symmetric, right)
MBILU           TypePrecond (MBILU)
0.5             GustafssonPar (0. no modification, 1. full modification)

! Default parameters are shown. Right preconditioning does not affect
! the normalization of the residual. The Gustafsson parameter determines
! how much the MBILU preconditioner is modified. The default 0.5 value
! means a relaxed modification.
</command>

<command name="KRYLOV">
	<parameter name="TypeKrylov" type="string" input="select">
		<option name="gmres"	default="T"	/>
		<option name="bicgstab" 		/>
	</parameter>
	<parameter name="TypeInitKrylov" type="string" input="select">
                <option name="0" 	value="nul" default="T"	/>
                <option name="previous" value="old"		/>
                <option name="explicit"				/>
                <option name="scaled explicit" value="explicit"	/>
	</parameter>
	<parameter name="ErrorMaxKrylov" type="real" min="0" max="0.1"
							default="0.001" />
	<parameter name="MaxMatvecKrylov" type="integer" min="1"
							default="100" />
#KRYLOV
gmres           TypeKrylov  (gmres, bicgstab)
nul             TypeInitKrylov (nul, old, explicit, scaled)
0.001           ErrorMaxKrylov
100             MaxMatvecKrylov

! Default values are shown. Initial guess for the Krylov type iterative scheme
! can be 0 ('nul'), the previous solution ('old'), the explicit solution
! ('explicit'), or the scaled explicit solution ('scaled'). The iterative
! scheme stops if the required accuracy is achieved or the maximum number
! of matrix-vector multiplications is exceeded.
</command>
<command name="KRYLOVSIZE">
	<parameter name="nKrylovVector" type="integer" min="1" 
						default="MaxMatvecKrylov"/>
#KRYLOVSIZE
10		nKrylovVector

! The number of Krylov vectors only matters for GMRES (TypeKrylov='gmres').
! If GMRES does not converge within nKrylovVector iterations, it needs
! a restart, which usually degrade its convergence rate and robustness.
! So nKrylovVector should exceed the number of iterations, on the other
! hand it should not exceed the maximum number of iterations MaxMatvecKrylov.
! On the other hand the dynamically allocated memory is also proportional 
! to nKrylovVector. The default is nKrylovVector=MaxMatvecKrylov (in #KRYLOV)
! which can be overwritten by #KRYLOVSIZE after the #KRYLOV command (if any).
</command>
</commandgroup>
<!-- ^CFG END IMPLICIT -->
<commandgroup name="STOPPING CRITERIA">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!! STOPPING CRITERIA !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="STOP" required="T">
	<parameter name="MaxIter" type="integer" min="-1" default="1000"/>
	<parameter name="TimeMax" type="real" min="-1" default="-1"
							if="$DoTimeAccurate" />
#STOP
100                     MaxIter Last/maximum iteration_number for this session.
10.                     TimeMax (in seconds) Only read if time_accurate is set!

! Notes: iteration_number does NOT include the iterations of the restart file
!        but it DOES include all iterations in previous sessions of the run.
</command>

<command name="CPUTIMEMAX">
	<parameter name="CpuTimeMax" type="real" min="-1" default="-1" />
#CPUTIMEMAX
3600                    CpuTimeMax (in seconds)

! Default is -1., which means that there is no maximum.
</command>

<command name="CHECKSTOPFILE">
	<parameter name="DoCheckStopfile" type="logical" default="T" />
#CHECKSTOPFILE
T                       DoCheckStopfile

! Default is .true., i.e. check for the BATSRUS.STOP file
! and stop running if BATSRUS.STOP exists in the
! same directory where BATSRUS is running. Plot and restart files
! will be saved if they were requested.
</command>
</commandgroup>
<commandgroup name="OUTPUT PARAMETERS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!  OUTPUT PARAMETERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="SAVELOGFILE">
	<parameter name="DoSaveLogfile" type="logical" default="F" />
	<if expr="$DoSaveLogfile">
		<parameter name="StringLog" type="strings" min="1" max="4">
			<part name="TypeLogVar" type="string" input="select"
							required="T">
				<option name="MHD vars. dimensional" 
					value="MHD" default="T" />
				<option name="Flux vars. dimensional"
					value="FLX" />
				<option name="Raw vars. dimensional"
					value="RAW" />
				<option name="Set vars. dimensional"
					value="VAR" />
				<option name="MHD vars. scaled" 
					value="mhd" default="T" />
				<option name="Flux vars. scaled"
					value="flx" />
				<option name="Raw vars. scaled"
					value="raw" />
				<option name="Set vars. scaled"
					value="var" />
			</part>
			<part name="TypeTime" type="string" input="select"
				required="F" multiple="T">
				<option name="none" exclusive="T" />
				<option name="step" 		/>
				<option name="date" 		/>
				<option name="time" 		/>
			</part>
		</parameter>
		<parameter name="DnOutput" type="integer" min="-1" 
					default="1" 			 />
		<parameter name="DtOutput" type="real"    min="-1"
					default="-1" if="$DoTimeAccurate"/>
		<parameter name="NameLogVars" type="string" length="100"
			if="$TypeLogVar =~ /var/i" />
		<parameter name="StringLogRadii" type="strings" 
			min="1" max="10" length="100"
			if="($TypeLogVar=~/flx/i or $NameLogVars=~/flx/i)">
			<part name="LogRadii" type="real" min="$rBody" 
								multiple="T"/>
		</parameter>
	</if>
#SAVELOGFILE
T                       DoSaveLogfile, rest of parameters read if true
VAR step date           StringLog
100                     DnOutput_i(logfile_)
-1.                     DtOutput_i(logfile_) in sec. Read only if time accurate
rho p rhoflx            NameLogVars (variable to write) Read for 'var' or 'VAR'
4.0  10.0               rLog  !radii where flx is calc. Read if vars inc. flx.

! Default is save_logfile=.false.
! The logfile can contain averages or point values and other scalar
! quantities.  It is written into an ASCII file named as
!
! IO2/log_timestep.log
!
! The StringLog can contain two groups of information in arbitrary order.
! The first is LogVar which is a single 3 character string that indicates
! the type of variables that are to be writen.  The second group indicates
! the type of time/iteration output format to use.  This second group is
! not required and defaults to something standard for each logvar case.
! Any of the identifiers for the timetype can be includec in arbitrary order.
!
! logvar  = 'mhd', 'raw', 'flx' or 'var' - unitless output
! logvar  = 'MHD', 'RAW', 'FLX' or 'VAR' - dimensional output
! timetype = 'none', 'step', 'time', 'date'
!
! The logvar string is not optional and must be found on the line.
! The timetype is optional - when not specified a logical choice is made
!       by the code
!
! The log_var string defines the variables to print in the log file
! It also controls whether or not the variables will come out in
! dimensional or non-dimensional form by the capatilization of the log_var
! string.
!
! ALL CAPS  - dimensional
! all lower - dimensionless
!
! 'raw' - vars: dt rho rhoUx rhoUy rhoUz Bx By Bz E Pmin Pmax
!       - time: step time
! 'mhd' - vars: rho rhoUx rhoUy rhoUz Bx By Bz E Pmin Pmax
!       - time: step date time
! 'flx' - vars: rho Pmin Pmax rhoflx pvecflx e2dflx
!       - time: step date time
! 'var' - vars: READ FROM PARAMETER FILE
!       - time: step time
!
! log_vars is read only when the log_string contains var or VAR.  The choices
! for variables are currently:
!
! Average value on grid: rho rhoUx rhoUy rhoUz Ux Uy Uz Bx By Bz P E
! Value at the test point: rhopnt rhoUxpnt rhoUypnt rhoUxpnt Uxpnt Uypnt Uzpnt
!                          Bxpnt Bypnt Bzpnt B1xpnt B1ypnt B1zpnt
!                          Epnt Ppnt Jxpnt Jypnt Jzpnt
!                          theta1pnt theta2pnt phi1pnt phi2pnt statuspnt
! Ionosphere values:  cpcpn cpcps                  <!-- ^CFG IF IONOSPHERE -->
!
! Max or Min on grid:    Pmin Pmax
! Flux values:           Aflx rhoflx Bflx B2flx pvecflx e2dflx
! Other variables:     dt
!
! timetype values mean the following:
!  none  = there will be no indication of time in the logfile (not even an
!                # of steps)
!  step  = # of time steps (n_steps)
!  date  = time is given as an array of 7 integers:  year mo dy hr mn sc msc
!  time  = time is given as a real number - elapsed time since the start of
!          the run.  Units are determined by log_var and unitUSER_t
!
!  these can be listed in any combination in the log_string line
!
! R_log is read only when one of the variables used is a 'flx' variable.  R_log
! is a list of radii at which to calculate the flux through a sphere.
</command>

<command name="SATELLITE" if="$IsFirstSession">
	<parameter name="nSatellite" type="integer" min="0" default="0" />
	<for from="1" to="$nSatellite">
		<parameter name="StringSatellite" type="strings"
							min="1" max="5">
			<part name="TypeSatelliteVar" type="string" 
						 input="select" required="T">
				<option name="MHD vars. dimensional" 
					value="MHD" default="T" />
				<option name="All vars. dimensional"
					value="FUL" />
				<option name="Set vars. dimensional"
					value="VAR" />
				<option name="MHD vars. scaled" 
					value="mhd" />
				<option name="All vars. scaled"
					value="ful" />
				<option name="Set vars. scaled"
					value="var" />
			</part>
			<part name="TypeTrajectory" type="string" 
						input="select" required="F">
				<option name="file" default="T"		/>
				<option name="equation" value="eqn"	/>
			</part>
			<part name="TypeTime" type="string" input="select"
						required="F" multiple="T">
				<option name="none" exclusive="T"/>
				<option name="step" />
				<option name="date" />
				<option name="time" />
			</part>
		</parameter>
		<parameter name="DnOutput" type="integer" min="-1" 
							default="1" />
		<parameter name="DtOutput" type="real"    min="-1"
							default="-1" />
		<parameter name="NameSatellite" type="string" length="100" />
		<parameter name="NameSatelliteVars" type="string" length="100"
			if="$TypeSatelliteVar =~ /\bvar\b/i" />
	</for>
#SATELLITE
2                       nSatellite
MHD file                StringSatellite (variables and traj type)
100                     DnOutput_i(satellite_)
-1.                     DtOutput_i(satellite_) in sec. ALWAYS READ!
satellite1.dat          Filename or satellite name (Satellite_name(satellite_))
VAR eqn step date       StringSatellite
100                     DnOutput_i(satellite_)
-1.                     DtOutput_i(satellite_) in sec. ALWAYS READ!
satellite2.dat          NameSatellite_i(satellite_)
rho p                   NameSatelliteVars Read if satellitevar='var' or 'VAR'

! satellite_string can contain the following 3 parts in arbitrary order
!
! satellitevar  = 'mhd', 'ful' or 'var' - unitless output
! satellitevar  = 'MHD', 'FUL' or 'VAR' - dimensional output
! trajectory_type = 'file' or 'eqn'
! timetype = 'none', 'step', 'time', 'date'
!
! satellitevar -> REQUIRED
! trajectory_type -> not required - defaults to 'file'
! time_type -> not required - a logical default is used
!
! The satellitevar string defines the variables to print in the satellite
! output file.  It also controls whether or not the variables will come out in
! dimensional or non-dimensional form by the capatilization of the
! satellite_vars string.
!
! ALL CAPS  - dimensional
! all lower - dimensionless
!
! 'mhd' - vars: rho Ux Uy Uz Bx By Bz P Jx Jy Jz
! 'ful' - vars: rho Ux Uy Uz Bx By Bz P Jx Jy Jz theta1 phi1 theta2 phi2 status
! 'var' - vars: READ FROM PARAMETER FILE
!
! satellite_vars is read only when the satellite_string is var or VAR.  The
! choices for variables are currently:
!
! rho, rho, rhouy, rhouz, ux, uy, uz
! Bx, By, Bz, B1x, B1y, B1z
! E, P, Jx, Jy, Jz
! theta1,theta2,phi1,phi2,status
!
!
! timetype values mean the following:
!  none  = there will be no indication of time in the logfile (not even an
!                # of steps)
!  step  = # of time steps (n_steps)
!  date  = time is given as an array of 7 integers:  year mo dy hr mn sc msc
!  time  = time is given as a real number - elapsed time since the start of
!          the run.  Units are determined by satellitevar and unitUSER_t
!
!  More than one of these can be listed.  They can be put together in any
!  combination.
</command>

<command name="SAVEPLOT">
! plot_string must contain the following 3 parts in arbitrary order
...
	<parameter name="nPlotFile" type="integer" min="0" max="100"
		default="0" />
	<for from="1" to="$nPlotFile">
		<parameter name="plotString" type="strings" min="3" max="3">
			<part name="plotform" type="string" input="select" 
								required="T">
				<option value="tec" name="TECPLOT"/>
				<option value="idl" name="IDL"    />
			</part>
			<part name="plotarea" type="string" input="select"
								required="T">
				<option value="3d"  />
				<option value="x=0" />
				<option value="y=0" default="T" />
				<option value="z=0" />
				<option value="x=y" 
					if="$plotform =~ /\btec\b/"/>
				<option value="sph" />
				<option value="ion" />
				<option value="los" />
				<option value="cut" 
					if="$plotform =~ /\bidl\b/"/>
			</part>
			<part name="plotvar" type="string" input="select" 
							required="T">
				<option name="min" value="min/mhd/MHD" 
                                                    if="$plotarea=~/\bion\b/"/>
				<option value="max" if="$plotarea=~/\bion\b/"/>
				<option value="aur" if="$plotarea=~/\bion\b/"/>
				<option value="uam" if="$plotarea=~/\bion\b/"/>
				<option name="MHD vars. dimensional"
					value="MHD" if="$plotarea!~/\bion\b/"/>
				<option name="All vars. dimensional"
					value="FUL" if="$plotarea!~/\bion\b/"/>
				<option name="Raw vars. dimensional"
					value="RAW" if="$plotarea!~/\bion\b/"/>
				<option name="Ray tracing vars. dim."
					value="RAY" if="$plotarea!~/\bion\b/"/>
				<option name="Flux vars. dimensional"
					value="FLX" if="$plotarea!~/\bion\b/"/>
				<option name="Solar vars. dimensional"
					value="SOL" if="$plotarea!~/\bion\b/"/>
				<option name="Select dimensional vars."
					value="VAR" if="$plotarea!~/\bion\b/"/>
				<option name="MHD vars. scaled"
					value="mhd" if="$plotarea!~/\bion\b/"/>
				<option name="All vars. scaled"
					value="ful" if="$plotarea!~/\bion\b/"/>
				<option name="Raw vars. scaled"
					value="raw" if="$plotarea!~/\bion\b/"/>
				<option name="Ray tracing vars. dim."
					value="ray" if="$plotarea!~/\bion\b/"/>
				<option name="Flux vars. scaled"
					value="flx" if="$plotarea!~/\bion\b/"/>
				<option name="Solar vars. scaled"
					value="sol" if="$plotarea!~/\bion\b/"/>
				<option name="Select scaled vars."
					value="var" if="$plotarea!~/\bion\b/"/>
			</part>
		</parameter>
		<parameter name="DnOutput" type="integer" min="-1" />
		<parameter name="DtOutput" type="real"    min="-1" 
							if="$DoTimeAccurate" />
		<if expr="$plotarea =~ /\bcut\b/">
			<parameter name="xMinCut" type="real" />
			<parameter name="xMaxCut" type="real" min="$xMinCut"/>
			<parameter name="yMinCut" type="real" />
			<parameter name="yMaxCut" type="real" min="$yMinCut"/>
			<parameter name="zMinCut" type="real" />
			<parameter name="zMaxCut" type="real" min="$zMinCut"/>
		</if>
		<parameter name="radius" type="real" min="0" default="10"
			if="$plotarea =~ /\bsph\b/" />
		<parameter name="plotDx" type="integer" min="-1" default="-1"
			if="($plotform =~ /\bidl\b/ and
			     $plotarea !~ /\b(ion|sph|los)\b/)" />
		<if expr="$plotvar =~ /\bvar\b/i">
			<parameter name="plotVars" type="string" length="100"/>
			<parameter name="plotPars" type="string" length="100"/>
		</if>
	</for>
#SAVEPLOT
6			nPlotfile
3d MHD tec		plotString ! 3d MHD data
100			DnOutput_i(1)
-1.			DtOutput_i(1) (in s) Read only if time_accurate is set!
y=0 VAR idl		plotString ! y=0 cut
-1			DnOutput_i(2)
100.			DtOutput_i(2)  Read only if time_accurate is set!
2.			plotDx_di(1,2) Read only for format 'idl'
jx jy jz		plotVars_i(2)  Read only for content 'var'
g unitx unitv unitn	plotPars_i(2)  Read only for content 'var'
cut ray idl		plotString  ! ray tracing plot
1			DnOutput_i(3)
-1.			DtOutput_i(3) (in s) Read only if time_accurate is set!
-10.			plotRange_ei(x1,3) Read only for area 'cut'
10.			plotRange_ei(x2,3) Read only for area 'cut'
-10.			plotRange_ei(y1,3) Read only for area 'cut'
10.			plotRange_ei(y2,3) Read only for area 'cut'
-10.			plotRange_ei(z1,3) Read only for area 'cut'
10.			plotRange_ei(z2,3) Read only for area 'cut'
1.			plotDx_di(1,3)     Read only for format 'idl'
sph flx idl		plotString  ! spherical plot
-1			DnOutput_i(4)
100.			DtOutput_i(4)  Read only if time_accurate is set!
4.			rPlot - R of spherical cut, Read only for area 'sph'
ion min idl		plotString  ! ionosphere plot
100			DnOutput_i(5)
100.			DtOutput_i(5)  Read only if time_accurate is set!
los sol idl             PlotString  ! line of sight plot
-1			dnOutput_i(6)
100.			dtOutput_i(6)  Read only if time_accurate is set!
1.			LosVector_i(1)
0.			LosVector_i(2)
0.			LosVector_i(3)
30.			xSizeImage
50.			ySizeImage
10.			xOffset
20.			yOffset
5.			rOccult
256			nPixX
256			nPixY

! Default is nplotfile=0
! plot_string must contain the following 3 parts in arbitrary order
!
! plotarea plotvar plotform
!
! plotarea = '3d',  'x=0', 'y=0', 'z=0', 'x=y', 'cut', 'sph', 'ion', 'los'
! plotvar  = 'mhd', 'ful','raw', 'ray', 'flx', 'sol', 'var' - unitless output
! plotvar  = 'MHD', 'FUL','RAW', 'RAY', 'FLX', 'SOL', 'VAR' - dimensional
! plotvar  = 'min', 'max' - for ion plots only, always dimensional
! plotform = 'tec' or 'idl'
!
! NOTES: Combinations 'x=y idl' and 'cut tec' are not implemented, 
!        The plotvar option 'sol' is only valid for plotarea 'los'.
<!-- ^CFG IF IONOSPHERE BEGIN -->
!        Ionosphere plots are called in ionosphere.f90 using completely
!               seperate routines, 'var' option does not work. 
!	        'min','max','aur','uam' work only with plotarea 'ion'
<!-- ^CFG END IONOSPHERE -->
!
! The plotarea string defines the 1, 2, or 3D volume of the plotting area:
!
! x=0	- full x=0 plane: xmin=-0.001, xmax=0.001, average for symmetry plane
! y=0	- full y=0 plane: ymin=-0.001, ymax=0.001, average for symmetry plane
! z=0	- full z=0 plane: zmin=-0.001, zmax=0.001, average for symmetry plane
! x=y	- full x=y plane, only works for plotform='tec'
! 3d	- full 3D volume
! cut	- READ PLOTRANGE FROM PARAM.in, only works for plotform='idl'
! sph   - spherical cut at radius R_plot, READ FROM PARAM.in
! ion   - ionosphere plots                        <!-- ^CFG IF IONOSPHERE -->
! los   - line of sight integrated plot
!
! The plotvar string defines the plot variables and the equation parameters.
! It also controls whether or not the variables will be plotted in dimensional
! values or as non-dimensional values:
!
! ALL CAPS  - dimensional
! all lower - dimensionless
!
! 'mhd' - vars: rho Ux Uy Uz E Bx By Bz P Jx Jy Jz
!         pars: g eta
! 'ful' - vars: rho Ux Uy Uz E Bx By Bz B1x B1y B1z P Jx Jy Jz
!         pars: g eta
! 'raw' - vars: rho rhoUx rhoUy rhoUz E Bx By Bz P b1x b1y b1z divb
!         pars: g eta
! 'ray' - vars: bx by bz theta1 phi1 theta2 phi2 status blk
!         pars: R_ray
! 'flx' - vars: rho rhoUr Br jr pvecr
!         pars: g eta
! 'var' - vars: READ FROM PARAMETER FILE
!         pars: READ FROM PARAMETER FILE
! 'sol' - vars: e_scat
<!-- ^CFG IF IONOSPHERE BEGIN -->
! 'min' - vars: Theta Psi SigmaH SigmaP Jr Phi
! 'max' - vars: X Y Z Theta Psi SigmaH SigmaP Jr Phi Ex Ey Ez Jx Jy Jz Ux Uy Uz
! 'aur' - vars: Theta Psi SigmaH SigmaP Jr Phi AveE TotE
! 'uam' - vars: Theta Psi SigmaH SigmaP Jr Phi JrUAM
<!-- ^CFG END IONOSPHERE -->
!
! The plot_string is always followed by the plotting frequency
! DnOutput and for time accurate runs by DtOutput.
!
! Depending on plot_string, further information is read from the parameter file
! in this order:
!
! plotRange		if plotarea is 'cut'
! plotDx		if plotform is 'idl' and plotarea is not sph, ion, los
! rPlot			if plotarea is 'sph'
! plotVars		if plotform is 'var'
! plotPars		if plotform is 'var'
!
! The plot_range is described by 6 coordinates. If the width in one or two 
! dimensions is less than the smallest cell size within the plotarea, 
! then the plot file will be 2 or 1 dimensional. If the range is thin but
! symmetric about one of the x=0, y=0, or z=0 planes, data will be averaged
! in the postprocessing.
!
! Possible values for plotDx (for IDL files):
!
!  0.5	- fixed resolution (any positive value)
!  0.	- fixed resolution based on the smallest cell in the plotting area
! -1.	- unstructured grid will be produced by PostIDL.exe
!
! rPlot is the radius of the spherical cut for plotarea='sph'
!
!
! plot_vars should not be set for plotarea 'ion' 
!       they are unimplemented.
! The possible values for plot_vars with plotarea 'los' 
!       are listed in subroutine set_plotvar_los in write_plot_los.f90.
! The possible values for plot_vars for other plot areas
!       are listed in subroutine set_plotvar in write_plot_common.f90.
!
! The possible values for plot_pars 
!       are listed in subroutine set_eqpar in write_plot_common.f90
!
! A plot file is produced by each processor.  This file is ASCII in 'tec'
! format and can be either binary or ASCII in 'idl' format as chosen under
! the #SAVEBINARY flag.  The name of the files are
!
! IO2/plotarea_plotvar_plotnumber_timestep_PEnumber.extenstion 
!
! where extension is 'tec' for the TEC and 'idl' for the IDL file formats.
! The plotnumber goes from 1 to nplot in the order of the files in PARAM.in.
! After all processors wrote their plot files, processor 0 writes a small 
! ASCII header file named as
!
! IO2/plotarea_plotvar_plotnumber_timestep.headextension
!
! where headextension is:
!           'H' for TEC file format       'HH' for TEC and plot_area 'sph' 
!           'h' for IDL file format       
</command>

<command name="SAVEBINARY">
	<parameter name="DoSaveBinary" type="logical" default="T" />
#SAVEBINARY
T			DoSaveBinary   used only for 'idl' plot file

! Default is .true. Saves unformatted IO2/*.idl files if true. 
! This is the recommended method, because it is fast and accurate.
! The only advantage of saving IO2/*.idl in formatted text files is
! that it can be processed on another machine or with a different 
! (lower) precision. For example PostIDL.exe may be compiled with 
! single precision to make IO2/*.out files smaller, while BATSRUS.exe is 
! compiled in double precision, to make results more accurate.
</command>

<command name="SAVERESTART">
	<parameter name="SaveRestart" type="logical" default="T" />
	<if expr="$SaveRestart">
		<parameter name="DnRestart" type="integer" min="-1" 
					default="-1" 			 />
		<parameter name="DtRestart" type="real"    min="-1" 
					default="-1" if="$DoTimeAccurate"/>
	</if>
#SAVERESTART
T			saveRestartFile  Rest of parameters read if true
100			DnOutput_i(restart_)
-1.			DtOutput_i(restart_) in seconds. Read if time_accurate!

! Default is save_restartfile=.true. with DnOutput(restart_)=-1, 
! DtOutput(restart_)=-1. This results in the restart file being 
! saved only at the end.  A binary restart file is produced for every 
! block and named as
!
! restartOUT/blkGLOBALBLKNUMBER.rst
!
! In addition the grid is described by
!
! restartOUT/octree.rst
!
! and an ASCII header file is produced with timestep and time info:
!
! restartOUT/restart.H
!
! The restart files are overwritten every time a new restart is done.
</command>

<command name="SAVEPLOTSAMR">
	<parameter name="SavePlotsAmr" type="logical" default="F" />
#SAVEPLOTSAMR
F			savePlotsAMR to save plots before each AMR

! Default is save_plots_amr=.false.
</command>
</commandgroup>
<commandgroup name="AMR PARAMETERS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!  AMR PARAMETERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="AMRINIT" if="$IsFirstSession">
	<parameter name="InitialRefineType" type="string" input="select">
		<option name="default" default="1"	/>
		<option name="all"		/>
		<option name="none"		/>
		<option name="3Dbodyfocus"	/>
		<option name="spherefocus"	/>
		<option name="magnetosphere"	/>
		<option name="points"		/>
		<option name="helio_init"	/>
		<option name="helio_z=4"	/>
		<option name="all_then_focus"	/>
		<option name="cme"		/>
		<option name="points"		/>
		<option name="mag_new"		/>
		<option name="magnetosphere"	/>
		<option name="magneto_fine"	/>
		<option name="magnetosaturn"	/>
		<option name="magnetojupiter"	/>
		<option name="paleo"		/>
		<option name="comet"		/>
	</parameter>
	<parameter name="InitialRefineLevel" type="integer" min="0" 
							default="4" />
#AMRINIT
default			InitialRefineType
4			InitialRefineLevel

! These are the default values for the initial refinement.

! Possible values for InitialRefineType:
! Default depends on problem_type. 
! 'none'		- Refine no blocks
! 'all' 		- Refine all blocks
! '3Dbodyfocus'		- Refinement focusing on body
! 'spherefocus'		- Refinement focusing on the orgin, does not require 
!                           a body
! 'points'      	- Refine around given points
! 'magnetosphere'	- Refine for generic magnetosphere
! *			- any other value will use default value by ProblemType
</command>

<command name="AMRINITPHYSICS" if="$IsFirstSession">
	<parameter name="nRefineLevelIC" type="integer" min="0" default="0" />
#AMRINITPHYSICS
3			nRefineLevelIC

! Defines number of physics (initial condition) based AMR-s AFTER the 
! geometry based initial AMR-s defined by #AMRINIT were done.
! Only useful if the initial condition has a non-trivial analytic form.
</command>

<command name="AMRLEVELS">
	<parameter name="minBlockLevel" type="integer" min="-1" default="0" />
	<parameter name="maxBlockLevel" type="integer" min="-1" default="99" />
	<parameter name="FixBodyLevel"  type="logical" default="F" />
#AMRLEVELS
0			minBlockLevel
99			maxBlockLevel
F			fixBodyLevel

! Set the minimum/maximum levels that can be affected by AMR.  The usage is as
! follows:
!
! minBlockLevel .ge.0 Cells can be coarsened up to the listed level but not
!                       further.
! minBlockLevel .lt.0 The current grid is ``frozen'' for coarsening such that
!                       blocks are not allowed to be coarsened to a size
!                       larger than their current one.
! maxBlockLevel .ge.0 Any cell at a level greater than or equal to
!                       maxBlockLevel is uneffected by AMR (cannot be coarsened
!                       or refined).
! maxBlockLevel .lt.0 The current grid is ``frozen'' for refinement such that
!                       blocks are not allowed to be refined to a size
!                       smaller than their current one.
! fixBodyLevel = T    Blocks touching the body cannot be coarsened or refined.
!
! This command has no effect when automatic_refinement is .false.
!
! Note that the user can set either #AMRLEVELS or #AMRRESOLUTION but not
! both.  If both are set, the final one in the session will set the values
! for AMR.
</command>

<command name="AMRRESOLUTION">
	<parameter name="minCellDx" type="real" min="-1" default="0"     />
	<parameter name="maxCellDx" type="real" min="-1" default="99999" />
#AMRRESOLUTION
0.			minCellDx
99999.			maxCellDx
F			fixBodyLevel

! Serves the same function as AMRLEVELS. min_block_dx and max_block_dx are
! converted into minBlockLevel and maxBlockLevel when they are read.
! Note that minBlockLevel corresponds to maxCellDx and maxBlockLevel
! corresponds to minCellDx.  See details above.
!
! This command has no effect when automatic_refinement is .false.
!
! Note that the user can set either #AMRLEVELS or #AMRRESOLUTION but not
! both.  If both are set, the final one in the session will set the values
! for AMR.
</command>

<command name="AMR">
	<parameter name="DnRefine" type="integer" min="-1" default="-1" />
	<if expr="$DnRefine>0">
		<parameter name="DoAutoRefine" type="logical" default="F" />
		<if expr="$DoAutoRefine">
			<parameter name="percentCoarsen" type="real" 
				min="0" max="100" default="20" />
			<parameter name="percentRefine" type="real" 
				min="0" max="100" default="20" />
			<parameter name="maxTotalBlocks" type="integer"
				min="1" default="99999" />
		</if>
	</if>
#AMR
2001			dnRefine (frequency in terms of total steps n_step)
T			DoAutoRefine 
0.			percentCoarsen
0.			percentRefine
99999			maxTotalBlocks

! Default for dn_refine is -1, ie. no run time refinement.
</command>

<command name="AMRCRITERIA">
	<parameter name="nRefineCrit" type="integer" input="select">
		<option name="1" />
		<option name="2" />
		<option name="3" default="1" />
	</parameter>
	<for from="1" to="$nRefineCrit">
		<parameter name="TypeRefine" type="string" 	input="select">
			<option name="grad T"		value="gradt/gradT"  />
			<option name="grad P"		value="gradp/gradP"  />
			<option name="grad log(Rho)"	value="gradlogrho"   />
			<option name="grad log(p)" value="gradlogP/gradlogp" />
			<option name="grad E"		value="gradE"	     />
			<option name="curl U" value="curlV/curlv/curlU/curlu"/>
			<option name="curl B"		value="curlB/curlb"  />
			<option name="div U"  value="divU/divu/divV/divv"    />
			<option name="divB"		value="divb/divB"    />
			<option name="vAlfven"
					     value="Valfven/vAlfven/valfven" />
			<option name="heliospheric beta" value="heliobeta"   />
			<option name="flux"				     />
			<option name="heliospheric current sheet"
						 value="heliocurrentsheet"   />
			<option name="rCurrents" value="rcurrents/Rcurrents" />
			<option name="Transient" value="transient/Transient" />
		</parameter>
		<if expr="$TypeRefine =~ /transient/i">
			<parameter name="TypeTransient" type="string"
							input="select">
				<option name='P_dot' value='p_dot/P_dot'/>
				<option name='T_dot' value='t_dot/T_dot'/>
				<option name='Rho_dot' 		default="T"
						value='rho_dot/Rho_dot'/>
				<option name='RhoU_dot' 
						value='RhoU_dot/rhou_dot'/>
				<option name='Rho_2nd_1'
						value='Rho_2nd_1/rho_2nd_1'/>
				<option name='Rho_2nd_2'
						value='Rho_2nd_2/rho_2nd_2'/>
			</parameter>
			<parameter name="UseSunEarth"   type="logical" 
						default="F"/>
			<if expr="$UseSunEarth">
				<parameter name="xEarth"   type="real"/>
				<parameter name="yEarth"   type="real"/>
				<parameter name="zEarth"   type="real"/>
				<parameter name="InvD2Ray" type="real"/>
			</if>
		</if>
	</for>
#AMRCRITERIA
3			nRefineCrit (number of refinement criteria: 1,2 or 3)
gradlogP		RefineCrit_i(1)
divB			RefineCrit_i(2)
Transient		RefineCrit_i(3)
Rho_dot			TypeTransient_I(i) ! Only if 'Transient' or 'transient'
T			UseSunEarth 	   ! Only if 'Transient'
0.00E+00		xEarth		   ! Only if UseSunEarth
2.56E+02 		yEarth		   ! Only if UseSunEarth
0.00E+00		zEarth		   ! Only if UseSunEarth
5.00E-01		InvD2Ray	   ! Only if UseSunEarth

! The default values depend on problem_type. 
! At most three criteria can be given. Possible criteria:
!
! 'gradT'		- gradient of temperature
! 'gradP'		- gradient of pressure
! 'gradlogrho'		- gradient of log(rho)
! 'gradlogP'		- gradient of log(P)
! 'gradE'		- gradient of electric field magnitude
! 'curlV','curlU' 	- magnitude of curl of velocity
! 'curlB'		- magnitude of current
! 'divU', 'divV'	- divergence of velocity
! 'divB'		- div B
! 'vAlfven','Valfven'	- Alfven speed
! 'heliobeta' 		- special function for heliosphere R^2*B^2/rho??
! 'flux'		- radial mass flux
! 'heliocurrentsheet'	- refinement in the currentsheet of the heliosphere
! 'Rcurrents'		- refinement near Rcurrents value
!
! All the names can also be spelled with all small case letters.
!
! The possible choices for TypeTransient_I 
!
! 'P_dot' (same as 'p_dot')
! 'T_dot' (same as 't_dot')
! 'Rho_dot' (same as 'rho_dot')
! 'RhoU_dot' (same as 'rhou_dot')
! 'B_dot' (same as 'b_dot')
! 'Rho_2nd_1' (same as 'rho_2nd_1')
! 'Rho_2nd_2' (same as 'rho_2nd_2')
! 
! Also, (xEarth,yEarth,zEarth) are the coordinates of the Earth. InvD2Ray is
! a factor that defines how close to the ray Sun-Earth to refine the grid.
! Note that the AMR occurs in a cylinder around the ray.
! Example:: for InvD2Ray = 
!   1 - refine_profile = 0.3679 at distance Rsun/10 from the ray
!   2 - refine_profile = 0.0183 at distance Rsun/10 from the ray
!   3 - refine_profile = 0.0001 at distance Rsun/10 from the ray
</command>
</commandgroup>
<commandgroup name="SCHEME PARAMETERS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!  SCHEME PARAMETERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="SCHEME">
	<parameter name="nOrder" type="integer" input="select">
		<option name="1" default="T"	/>
		<option name="2"		/>
	</parameter>
	<parameter name="TypeFlux" type="string" input="select">
	    <option name="Roe"     value="Roe/roe/1"/>   							<!--^CFG IF ROEFLUX-->
	    <option name="Rusanov" value="Rusanov/rusanov/2/TVDLF"				 default="T"/>	<!--^CFG IF RUSANOVFLUX-->
	    <option name="Linde"   value="Linde/linde/3/HLLEL"/>						<!--^CFG IF LINDEFLUX-->
	    <option name="Sokolov" value="Sokolov/sokolov/4/AW"/>						<!--^CFG IF AWFLUX   -->
	</parameter>
	<if expr="$nOrder == 2">
		<parameter name="TypeLimiter" type="string" input="select">
			<option name="minmod" default="T" 	/>
			<option name="beta"			/>
			<option name="mc"			/>
			<option name="LSG"			/>
		</parameter>
		<parameter name="LimiterBeta" type="real" min="1" max="2"
			default="1.2" if="$TypeLimiter eq 'beta'"/>
	</if>
#SCHEME
2			nOrder (1 or 2)
Rusanov			TypeFlux
minmod			TypeLimiter ! Only for nOrder=2
1.2			LimiterBeta ! Only for LimiterType='beta'

! Default values are shown above.
!
! Possible values for TypeFlux:
! 'Rusanov'     - Rusanov or Lax-Friedrichs flux     <!--^CFG IF RUSANOVFLUX-->
! 'Linde        - Linde's HLLEL flux                   <!--^CFG IF LINDEFLUX-->
! 'Sokolov'     - Sokolov's Local Artificial Wind flux <!--^CFG IF AWFLUX   -->
! 'Roe'         - Roe's approximate Riemann flux       <!--^CFG IF ROEFLUX  -->
!
! Possible values for TypeLimiter:
! 'minmod'	- minmod limiter is the most robust 1D limiter
! 'mc'		- Monotonized Central limiter is sharper but less robust
! 'LSG'		- Least Squares Gradient: robust but expensive multiD limiter 
! 'beta'        - Beta limiter
!
! Possible values for LimiterBeta are between 1.0 and 2.0 : 
!  LimiterBeta = 1.0 is the same as the minmod limiter
!  LimiterBeta = 2.0 is the same as the superbee limiter
!  LimiterBeta = 1.2 is the recommended value
</command>

<command name="NONCONSERVATIVE">
	<parameter name="rConservative" type="real" default = "2*$rBody"/>
#NONCONSERVATIVE
6.		rConservative

! Default value is 2*Rbody, where Rbody has a problem dependent default.
! Outside radius Rconservative the conservative energy equation is used
! inside the nonconservative pressure equation. Use a negative number
! (e.g. -1.0) for a fully conservative scheme.
</command>

<command name="UPDATECHECK">
	<parameter name="UseUpdateCheck" type="logical" default="T" />
	<if expr="$UseUpdateCheck">
		<parameter name="rhoMin" type="real" min="0" max="100"
			default="40" />
		<parameter name="rhoMax" type="real" min="100"
			default="400" />
		<parameter name="pMin" type="real" min="0" max="100"
			default="40" />
		<parameter name="pMax" type="real" min="100"
			default="400" />
	</if>
#UPDATECHECK
T			UseUpdateCheck
40.			rhoMin[%]
400.			rhoMax[%]
40.			pMin[%]
400.			pMax[%]

! Default values are shown.  This will adjust the timestep so that
! density and pressure cannot change by more than the given percentages
! in a single timestep.
</command>

<command name="PROLONGATION">
	<parameter name="nOrderProlong" type="integer" input="select">
		<option name="1" default="T"	/>
		<option name="2"		/>
	</parameter>
	<parameter name="TypeProlong" type="string" input="select"
						if="$nOrderProlong==2">
		<option name="left-right" value="lr" default="T"	/>
		<option name="central"					/>
		<option name="minmod"					/>
		<option name="left-right extrapolate"	value="lr2"	/>
		<option name="central    extrapolate"	value="central2"/>
		<option name="minmod     extrapolate"	value="minmod2" />
	</parameter>
#PROLONGATION
2			nOrderProlong (1 or 2 for ghost cells)
lr			TypeProlong  ! Only for nOrderProlong=2

! Default is prolong_order=1. 
! Possible values for prolong_type:
! 1. in message_pass_dir (used if limiter_type is not 'LSG')
! 'lr'		- interpolate only with left and right slopes 
! 'central'	- interpolate only with central difference slope
! 'minmod' 	- interpolate only with minmod limited slope
! 'lr2'		- like 'lr' but extrapolate when necessary
! 'central2'	- like 'central' but extrapolate when necessary
! 'minmod2'	- like 'minmod' but extrapolate when necessary
! 'lr3'		- only experimental
!
! 2. in messagepass_all (used if limiter_type is 'LSG')
! 'lr','lr2'		- left and right slopes (all interpolation)
! 'central','central2'	- central differences (all interpolation)
! 'minmod','minmod2'	- to be implemented
</command>

<command name="MESSAGEPASS" alias="OPTIMIZE">
	<parameter name="TypeMessagePass" type="string" input="select">
		<option value="allopt" name="m_p_cell FACES ONLY" default="T"/>
		<option value="all"    name="m_p_cell"	                     />
		<option value="opt"    name="m_p_dir FACES ONLY"	     />
		<option value="dir"    name="m_p_dir group by directions"    />
		<option value="face"   name="m_p_dir group by faces     "    />
		<option value="min"    name="m_p_dir group by kind and face" />
		<option value="allold" name="m_p_all"			     />
		<option value="oldopt" name="m_p_old FACES ONLY"	     />
	</parameter>
#MESSAGEPASS
allopt			TypeMessagePass

! Default value is shown above.
! Possible values for optimize_message_pass
!
! 'dir'		- message_pass_dir: group messages direction by direction
! 'face'	- message_pass_dir: group messages face by face
! 'min'		- message_pass_dir: send equal, restricted and prolonged 
!				    messages face by face
!
! 'opt'		- message_pass_dir: do not send corners, send one layer for
!				    first order, send direction by direction
!
! 'all'		- message_pass_cell: corners, edges and faces in single message
!
! 'allopt'      - message_pass_cell:  faces only in a single message
!
! 'allold'      - messagepass_all: corners, edges and faces in many messages
!
! 'oldopt'	- message_pass_equal_opt:     equal
!		  message_pass_reschange_opt: restricted and prolonged
!					  no corners, all variables together
!
! Constrained transport requires corners, default is 'all'! <!--^CFG IF CONSTRAINB-->
! Diffusive control requires corners, default is 'all'!<!--^CFG IF DIVBDIFFUSE-->
! Projection uses message_pass_dir for efficiency!<!--^CFG IF PROJECTION-->
</command>

<!-- ^CFG IF BORISCORR BEGIN -->
<command name="BORIS">
	<parameter name="UseBorisCorrection" type="logical" default="F"/>
	<parameter name="BorisClightFactor" type="real" min="0" max="1"
					default="1" if="$UseBorisCorrection" />
#BORIS
T			UseBorisCorrection
1.0			BorisClightFactor !Only if UseBorisCorrection is true

! Default is boris_correction=.false.
! Use semi-relativistic MHD equations with speed of light reduced by
! the BorisClightFactor. Set BorisClightFactor=1.0 for true semi-relativistic
! MHD. Gives the same steady state as normal MHD analytically, but there
! can be differences due to discretization errors. 
! You can use either Boris or BorisSimple but not both. ^CFG IF SIMPLEBORIS
</command>
<!-- ^CFG END BORISCORR -->

<!-- ^CFG IF SIMPLEBORIS BEGIN -->
<command name="BORISSIMPLE">
	<parameter name="UseBorisSimple" type="logical" default="F"/>
	<parameter name="BorisClightFactor" type="real" min="0" max="1"
					default="1" if="$UseBorisSimple" />
#BORISSIMPLE
T			UseBorisSimple
0.05			BorisClightFactor !Only if UseBorisSimple is true

! Default is UseBorisSimple=.false. 
! Use simplified semi-relativistic MHD with speed of light reduced by the
! BorisClightFactor. This is only useful with BorisClightFactor less than 1.
! Should give the same steady state as normal MHD, but there can be a
! difference due to discretization errors.
! You can use either Boris or BorisSimple but not both. ^CFG IF BORISCORR
</command>
<!-- ^CFG END SIMPLEBORIS -->

<command name="DIVB">
	<parameter name="UseDivbSource"    type="logical" default="T"/>
	<parameter name="UseDivbDiffusion" type="logical" default="F"/><!--^CFG IF DIVBDIFFUSE -->
	<parameter name="UseProjection"    type="logical" default="F"/><!--^CFG IF PROJECTION -->
	<parameter name="UseConstrainB"    type="logical" default="F"/><!--^CFG IF CONSTRAINB -->
	<rule
	expr="$UseDivbSource or $UseDivbDiffusion or $UseProjection or $UseConstrainB">
	! At least one of the options should be true.
	</rule>
	<!-- ^CFG IF PROJECTION BEGIN -->
	<rule 
	expr="not($UseProjection and ($UseDivbSource or $UseDivbDiffusion or $UseConstrainB))">
	! If UseProjection is true, all others should be false.
	</rule>
	<!-- ^CFG END PROJECTION -->
	<!-- ^CFG IF CONSTRAINB BEGIN -->
	<rule
	expr="not($UseConstrainB and ($UseDivbSource or $UseDivbDiffusion or $UseProjection))">
	! If UseConstrainB is true, all others should be false.
	</rule>
	<!-- ^CFG END CONSTRAINB -->
#DIVB
T			UseDivbSource
F			UseDivbDiffusion	<!-- ^CFG IF DIVBDIFFUSE-->
F			UseProjection           <!-- ^CFG IF PROJECTION -->
F			UseConstrainB           <!-- ^CFG IF CONSTRAINB -->

! Default values are shown above.
! If UseProjection is true, all others should be false.<!--^CFG IF PROJECTION-->
! If UseConstrainB is true, all others should be false.<!--^CFG IF CONSTRAINB-->
! At least one of the options should be true.
</command>

<command name="DIVBSOURCE">
	<parameter name="UseB0Source"       type="logical" default="T"/>
#DIVBSOURCE
T			UseB0Source

! Add extra source terms related to the non-zero divergence and curl of B0.
! Default is true.
</command>

<!-- ^CFG IF DIVBDIFFUSE BEGIN -->
<command name="DIVBDIFFUSION">
	<parameter name="DivbDiffCoeff" type="real" min="0" max="1"
							default="0.1666667"/>
#DIVBDIFFUSION
0.1666667		DivbDiffCoeff

! Default value is shown above. 1.0/6.0
! If divb_diffcoeff .gt. 0.5 then cfl .lt. 0.5/DivbDiffCoeff is required!
</command>
<!-- ^CFG END DIVBDIFFUSE -->

<!-- ^CFG IF PROJECTION BEGIN -->
<command name="PROJECTION">
	<parameter name="TypeProjectIter" type="string" input="select">
		<option name="Conjugate Gradients" value="cg"		/>
		<option name="BiCGSTAB" value="bicgstab" default="T"	/>
	</parameter>
	<parameter name="TypeProjectStop" type="string" input="select">
		<option name="Relative norm" value="rel" default="T"	/>
		<option name="Maximum error" value="abs"		/>
	</parameter>
	<parameter name="RelativeLimit" type="real" min="0" max="1"
							default="0.1" />
	<parameter name="AbsoluteLimit" type="real" min="0"
							default="0.0" />
	<parameter name="MaxMatvec" type="integer" min="1" default="50" />
#PROJECTION
bicgstab		TypeProjectIter:'cg' or 'bicgstab' for iterative scheme
rel			TypeProjectStop:'rel' or 'max' error for stop condition
0.1			RelativeLimit
0.0			AbsoluteLimit 
50			MaxMatvec (upper limit on matrix.vector multipl.)

! Default values are shown above.
!
! For uniform Cartesian grid (symmetric matrix), TypeProjectIter='cg' 
! (Conjugate Gradients) can be used. It is twice as fast as BiCGSTAB.
! For adaptive grid (asymmetric matrix), only 'bicgstab' can be used 
! 
! The iterative scheme stops when the stopping condition is fulfilled:
!   TypeProjectStop = 'rel' : 
!        stop if ||div B|| &lt; RelativeLimit*||div B0||
!   TypeProjectStop = 'max' and RelativeLimit is positive: 
!        stop if max(|div B|) &lt; RelativeLimit*max(|div B0|)
!   TypeProjectStop = 'max' and RelativeLimit is negative
!        stop if max(|div B|) &lt; AbsoluteLimit
!
!   where ||.|| is the second norm, and B0 is the magnetic
!   field before projection. In words 'rel' means that the norm of the error
!   should be decreased by a factor of RelativeLimit, while 
!   'max' means that the maximum error should be less than either
!   a fraction of the maximum error in div B0, or less than the constant 
!   AbsoluteLimit.
! 
!   Finally the iterations stop if the number of matrix vector
!   multiplications exceed MaxMatvec. For the CG iterative scheme
!   there is 1 matvec per iteration, while for BiCGSTAB there are 2/iteration.
!
!  In practice reducing the norm of the error by a factor of 10 to 100 in 
!  every iteration works well.
!
<!-- ^CFG IF CONSTRAINB BEGIN -->
!
!  Projection is also used when the scheme switches to constrained transport.
!  It is probably a good idea to allow many iterations and require an
!  accurate projection, because it is only done once, and the constrained
!  transport will carry along the remaining errors in div B. An example is
!
#PROJECTION
bicgstab		TypeProjIter
rel			TypeProjStop
0.0001			RelativeLimit
0.0			AbsoluteLimit 
500			MaxMatvec
<!-- ^CFG END CONSTRAINB -->
</command>

<command name="CORRECTP">
	<parameter name="pRatioLow" type="real" min="0" max="1"
							default="0.01"/>
	<parameter name="pRatioHigh" type="real" min="$pRatioLow" max="1"
							default="0.1"/>
! Default values are shown. 
!
! The purpose of the correctP subroutine is to remove any discrepancies between
! pressure in the p_BLK variable and the pressure calculated from the
! E_BLK variable. Such discrepancies can be caused by the
! constrained transport scheme and by the projection scheme
! which modify the magnetic energy. The algorithm is the following:
!
! q = eThermal/e
!
!                  q.lt. pRatioLow  E is set to eThermal+(rho*u**2+B**2)/2
! if pRatioLow .lt.q.lt.pRatioHigh  both P and E are modified depending on q
! if pratioHigh.lt.q                P is set to (gamma-1)*(e-(rho*u**2+B**2)/2)
!
! The 2nd case is a linear interpolation between the 2nd and 4th cases.
</command>
<!-- ^CFG END PROJECTION -->

<!-- ^CFG IF RAYTRACE BEGIN -->
<command name="RAYTRACE">
	<parameter name="UseRayTrace" type="logical" default="F"/>
	<if expr="$UseRayTrace">
		<parameter name="DoCheckRayLoop" type="logical" default="F"/>
		<parameter name="DnRayTrace" type="integer" min="1" 
								default="100"/>
		<parameter name="rRayTrace" type="real" min="0" default="1" />
	</if>
#RAYTRACE
T			UseRayTrace    ! Rest of the parameters read if .true.
F			DoCheckRayLoop print info for loops
100			DnRayTrace   how often
3.0			rRayTrace    where to stop with ray tracing

! Raytracing is still experimental. Default is UseRayTrace false.
</command>
<!-- ^CFG END RAYTRACE -->
</commandgroup>
<commandgroup name="PHYSICS PARAMETERS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!  PHYSICS PARAMETERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="GAMMA" if="$IsFirstSession">
	<parameter name="Gamma" type="real" min="1" default="1.6666666667"/>
#GAMMA
1.6666666667		g

! Above value is the default.
</command>

<command name="SHOCKTUBE">
	<parameter name="RhoLeft"  type="real" min="0" default="1"	/>
	<parameter name="UnLeft"   type="real"		default="0"	/>
	<parameter name="Ut1Left"  type="real"		default="0"	/>
	<parameter name="Ut2Left"  type="real"		default="0"	/>
	<parameter name="BnLeft"   type="real"		default="0.75"	/>
	<parameter name="Bt1Left"  type="real"		default="1"	/>
	<parameter name="Bt2Left"  type="real"		default="0"	/>
	<parameter name="pRight"   type="real" min="0"	default="1"	/>
	<parameter name="RhoRight" type="real" min="0"	default="0.125"	/>
	<parameter name="UnRight"  type="real" 		default="0"	/>
	<parameter name="Ut1Right" type="real"		default="0"	/>
	<parameter name="Ut2Right" type="real"		default="0"	/>
	<parameter name="BnRight"  type="real"		default="0.75"	/>
	<parameter name="Bt1Right" type="real"		default="-1"	/>
	<parameter name="Bt2Right" type="real" 		default="0"	/>
	<parameter name="pRight"   type="real" min="0"	default="0.1"	/>
	<parameter name="ShockSlope" type="real" input="select">
		<option value="0" name="no rotation" default="T"	/>
		<option value="0.25"					/>
		<option value="0.3333333333333"				/>
		<option value="0.5"					/>
		<option value="1"					/>
		<option value="2"					/>
		<option value="3"					/>
		<option value="4"					/>
	</parameter>
#SHOCKTUBE
1.		rho (left state)
0.		Ux (Un)
0.		Uy (Ut1)
0.		Uz (Ut2)
0.75		Bx (Bn)
1.		By (Bt1)
0.		Bz (Bt2)
1.		P
0.125		rho (right state)
0.		Ux (Un)
0.		Uy (Ut1)
0.		Uz (Ut2)
0.75		Bx (Bn)
-1.		By (Bt1)
0.		Bz (Bt2)
0.1		P
0.0		ShockSlope

! Default values are shown (Brio-Wu problem).
! The shock is rotated if ShockSlope is not 0, and the tangent of 
! the rotation angle is ShockSlope. 
! When the shock is rotated, it is best used in combination
! with sheared outer boundaries, but then only
!
! ShockSlope = 1., 2., 3., 4., 5.      .....
! ShockSlope = 0.5, 0.33333333, 0.25, 0.2, .....
!
! can be used, because these angles can be accurately represented
! on the grid.
</command>

<command name="SOLARWIND" if="$IsFirstSession">
	<parameter name="SwRhoDim" type="real" min="0"	default="5"	/>
	<parameter name="SwTDim"   type="real" min="0"	default="181712.175" />
	<parameter name="SwUxDim"  type="real" max="0"	default="-400"	/>
	<parameter name="SwUyDim"  type="real"		default="0"	/>
	<parameter name="SwUzDim"  type="real"		default="0"	/>
	<parameter name="SwBxDim"  type="real" max="0"	default="-400"	/>
	<parameter name="SwByDim"  type="real"		default="0"	/>
	<parameter name="SwBzDim"  type="real"		default="5"	/>
#SOLARWIND
5.0			SwRhoDim [n/cc]
181712.175		SwTDim [K]
-400.0			SwUxDim [km/s]
0.0			SwUyDim [km/s]
0.0			SwUzDim [km/s]
0.0			SwBxDim [nT]
0.0			SwByDim [nT]
5.0			SwBzDim [nT]

! No default values!
</command>
<command name="UPSTREAM_INPUT_FILE">
	<parameter name="UseUpstreamInputFile" type="logical" default="F"/>
	<if expr="$UseUpstreamInputFile">
		<parameter name="NameUpstreamFile" type="string" length="100"/>
		<parameter name="SatelliteYPos"	type="real" default="0"	/>
		<parameter name="SatelliteZPos"	type="real" default="0"	/>
	</if>
#UPSTREAM_INPUT_FILE
T			UseUpstreamInputFile (rest of parameters read if true)
IMF.dat                 NameUpstreamFile
0.0                     SatelliteYPos
0.0                     SatelliteZPos

! UseUpstreamInputFile - default is false
! UpstreamFileName     - user specified input file
! Satellite_Y_Pos      - not yet used
! Satellite_Z_Pos      - not yet used
</command>

<command name="BODY" alias="MAGNETOSPHERE" if="$IsFirstSession">
	<parameter name="UseBody" type="logical" default="F"/>
	<if expr="$UseBody">
		<parameter name="rBody" type="real" min="0"
							      default="3"/>
		<parameter name="rCurrents" type="real" min="$rBody" 
							      default="4"/>
		<parameter name="BodyRhoDim" type="real" min="0"
							      default="1"/>
		<parameter name="BodyTDim" type="real" min="0"
							      default="10000"/>
	</if>
#BODY
T			UseBody (rest of parameters read if true)
3.0			rBody
4.0			rCurrents
1.0			BodyRhoDim (/ccm) density for fixed BC for rho_BLK
10000.0			BodyTDim (K) temperature for fixed BC for P_BLK

! Default values depend on problem_type.
</command>

<command name="GRAVITY" if="$IsFirstSession">
	<parameter name="UseGravity" type="logical" default="F" />
	<parameter name="iDirGravity" type="integer" input="select"
							if="$UseGravity">
		<option name="central mass" value="0" default="T"	/>
		<option name="X direction"  value="1"			/>
		<option name="Y direction"  value="2"			/>
		<option name="Z direction"  value="3"			/>
	</parameter>
#GRAVITY
T			UseGravity (rest of parameters read if true)
0			GravityDir (0 - central, 1 - X, 2 - Y, 3 - Z direction)

! Default values depend on problem_type.  
<!-- ^CFG IF SECONDBODY BEGIN -->
! When a second body is used the gravity direction for the second body
!  is independent of the GravityDir value.  Gravity due to the second body
!  is radially inward toward the second body.
<!-- ^CFG IF SECONDBODY END -->
</command>

<command name="FACONDUCTIVITYMODEL">
	<parameter name="UsePhysicalFAConductance" type="logical" default="F"/>
#FACONDUCTIVITYMODEL
F			UsePhysicalFAConductance

Default value is shown.
</command>

<command name="MASSLOADING">
	<parameter name="UseMassLoading" type="logical" default="F"/>	
	<parameter name="DoAccelerateMassLoading" type="logical" default="F"/>
#MASSLOADING
F			UseMassLoading
F			AccelerateMassLoading
</command>

<!-- ^CFG IF DISSFLUX BEGIN -->
<command name="HEATFLUX">
	<parameter name="UseHeatFlux"    type="logical" default="F"/>
	<parameter name="UseSpitzerForm" type="logical" default="T"/>
	<if expr="not $UseSpitzerForm">
		<parameter name="Kappa0Heat" type="real" default="1.23E-11"/>
		<parameter name="Kappa0Heat" type="real" default="2.5"     />
	</if>
#HEATFLUX
T		UseHeatFlux
F		UseSpitzerForm
1.23E-11	Kappa0Heat [W/m/K]	! Only if not UseSpitzerForm
2.50E+00	ExponentHeat [-]	! Only if not UseSpitzerForm
</command>

<command name="RESISTIVEFLUX">
	<parameter name="UseResistFlux"  type="logical" default="F"	/>
	<parameter name="UseSpitzerForm" type="logical" default="T"	/>
	<if expr="not $UseSpitzerForm">
		<parameter name="TypeResist" type="string" input="select">
			<option name="localized" value="Localized/localized"/>
			<option name="constant"  value="Constant/constant"
								default="T"/>
		</parameter>
		<if expr="$TypeResist =~ /localized/i">
			<parameter name="Eta0Resist" type="real" 
						default="9.69953E+8"	/>
			<parameter name="Alpha0Resist" type="real"
						default="150"		/>
			<parameter name="yShiftResist" type="real"
						default="0.5"		/>
			<parameter name="TimeInitRise" type="real"
						default="0.05"		/>
			<parameter name="TimeConstLev" type="real"
						default="1"		/>
		</if>
	</if>
	<parameter name="UseAnomResist" type="logical" default="F"	/>
	<if expr="$UseAnomResist">
		<parameter name="Eta0AnomResist" type="real"
						default="1.93991E+09"	/>
		<parameter name="EtaAnomMaxResist" type="real"
						default="1.93991E+10"	/>
		<parameter name="ThresholdFactorResist" type="real"
						default="1"		/>
	</if>
#RESISTIVEFLUX
T		UseResistFlux
F		UseSpitzerForm
Localized	TypeResist		! Only if not UseSpitzerForm
9.69953E+08	Eta0Resist [m^2/s]	! Only if not UseSpitzerForm
1.50000E+02	Alpha0Resist [-]	! Only if TypeResist=='Localized'
5.00000E-01	yShiftResist [-]	! Only if TypeResist=='Localized'
5.00000E-02	TimeInitRise [-]	! Only if TypeResist=='Localized'
1.00000E+00	TimeConstLev [-]	! Only if TypeResist=='Localized'
T		UseAnomResist
1.93991E+09	Eta0AnomResist [m^2/s]		! Only if UseAnomResist
1.93991E+10	EtaAnomMaxResist [m^2/s]	! Only if UseAnomResist
1.00000E+00	ThresholdFactorResist [-]	! Only if UseAnomResist

! Note: ResistType = `Constant'  (the same as `constant')
!		     'Localized' (the same as 'localized')
!
! The first choice results in a uniform resistivity of value Eta0Resist.
! The second choice represents localized in space magnetic diffusion 
! with a peak value Eta0Resist. The enhanced resistivity has a Gaussian 
! shape with HWHM of 1/sqrt(Alpha0Resist), shifted along the y-axis on 
! -yShistResist*y2.
</command>

<command name="TESTDISSMHD" if="$IsFirstSession">
	<parameter name="UseDefaultUnits" type="logical" default="T"/>
	<parameter name="Grav0Diss"	  type="real" default="2.635620E-02"/>
	<parameter name="Beta0Diss"	  type="real" default="1.640000E-01"/>
	<parameter name="Length0Diss"	  type="real" default="1.500000E+06"/>
	<parameter name="Time0Diss"	  type="real" default="1.159850E+01"/>
	<parameter name="Rho0Diss"	  type="real" default="5.019000E-11"/>
	<parameter name="Tem0Diss"	  type="real" default="1.000000E+05"/>
	<parameter name="Theta0Diss"	  type="real" default="6.000000E-01"/>
	<parameter name="Delta0Diss"	  type="real" default="2.500000E+01"/>
	<parameter name="EpsilonDiss"	  type="real" default="7.000000E+00"/>
	<parameter name="RhoDifDiss"	  type="real" default="4.500000E+00"/>
	<parameter name="yShiftDiss"	  type="real" default="4.000000E-01"/>
	<parameter name="ScaleHeightDiss" type="real" default="5.000000E-01"/>
	<parameter name="ScaleFactorDiss" type="real" default="1.159850E+01"/>
	<parameter name="BZ0iss" 	  type="real" default="5.000000E-01"/>
#TESTDISSMHD
F                       UseDefaultUnits
2.635620E-02            Grav0Diss
1.640000E-01            Beta0Diss
1.500000E+06            Length0Diss
1.159850E+01            Time0Diss
5.019000E-11            Rho0Diss
1.000000E+05            Tem0Diss
6.000000E-01            ThetaDiss
2.500000E+01            DeltaDiss
7.000000E+00            EpsilonDiss
4.500000E+00            RhoDifDiss
4.000000E-01            yShiftDiss
5.000000E-01            scaleHeightDiss
1.000000E+00            scaleFactorDiss
0.000000E-01            BZ0Diss

! Default values are shown. Parameters for problem_dissipation
</command>

<!-- ^CFG END DISSFLUX -->
<command name="USER_FLAGS">
	<parameter name="UseUserInnerBcs" type="logical" default="F"	/>
	<parameter name="UseUserSource"	  type="logical" default="F"	/>
	<parameter name="UseUserPerturbation" type="logical" default="F"/>
#USER_FLAGS
F			UseUserInnerBcs
F			UseUserSource
F			UseUserPerturbation

! This command controls the use of user defined routines in user_routines.f90.
! For each flag that is set, an associated routine will be called in 
! user_routines.f90.  Default is .false. for all flags.
</command>

<command name="AXES" if="$IsFirstSession">
	<parameter name="TypeCoordinateSystem" type="string" input="select">
		<option name="Geocentric Solar Magnetic" value="GSM"
							default="T" />
	</parameter>
	<parameter name="TypeAxes" type="strings" min="1" max="2"
						duplicate="T" ordered="T">
		<part name="TypeDipole" type="string" input="select"
								required="T">
			<option name="Zero dipole strength"
							value="none"/>
			<option name="Default dipole strength, no tilt" 
						 value="ideal" default="T"/>
			<option name="Default strength and tilt"
							value="planet"	/>
			<option name="Set strength and tilt"
							value="user"	/>
		</part>
		<part name="TypeRotation" type="string" input="select"
								required="F">
			<option name="No rotation" value="none"		/>
			<option name="Default rate and aligned with dipole"
						value="ideal" default="T"/>
			<option name="Default rate and tilt" value="planet"/>
			<option name="Set rate and tilt" value="user" />
		</part>
	</parameter>
	<if expr="$TypeDipole eq 'user'">
		<parameter name="BdpDim" type="real" default="31100.0"	/>
		<parameter name="ThetaTilt" type="real" min="0" max="180"
							default="30"	/>
	</if>
	<if expr="$TypeRotation eq 'user'">
		<parameter name="CorotationTilt" type="real" min="0" max="180"
							default="30"    />
		<parameter name="CorotationLon" type="real" min="0" max="360"
							default="90"	/>
		<parameter name="RotatioPeriod"	type="real"
							default="86400"/>
	</if>
#AXES
GSM			TypeCoordinateSystem
user user 		AxesType
31100.0			BdpDim (in nT)
30.0			ThetaTilt (rotation from +Z direction)
30.0			CorotationTilt (rotation from +Z direction)
90.0			CorotationLon (rotation from +X direction)
39600.0			rotPeriod (in seconds)


! CoordinateSystemString -  indicates the coordinate system in which the
!   code is run.  Currently the only option is:
!
!   'GSM'  - Geocentric Solar Magnetic - +x point to sun, 
!                                        dipole axis in x-z plane
!
!
! AxesType - indicates the functionality of the magnetic dipole and the
!   rotation axis.  The first string controls the magnetic dipole
!   the second controls the corotation axis.  If only one string
!   is given, the same value is used for both.  Possible values are:
!
!  String   Magnetic Dipole meaning           Corotation meaning  
!  ------   -------------------------------   -------------------------------
!  'none'   dipole strength (BdpDim) = 0.0   UseCorotation = false
!
!  'ideal'  0.0 degree dipole tilt           rotation axis aligned with dipole
!           BdpDim set by problem_type       rotation rate set by problem_type
!
!  'planet' dipole tilt and BdpDim set       rotation axis tilt and rate set
!           by problem_type according to     by problem_type according to
!           the date set in #SETREALTIME.    the date set int @SETREALTIME.
!           Values are updated in time.      Values are updated in time.
!
!  'user'   User specified values:           User specified values:
!            BdpDim (in nT)                  rot_period (period in seconds)
!            ThetaTilt = angle between z-    CorotationTilt = angle between
!             axis and dipole in X-Z plane   z-axis and rotation axis in
!             (+ = southern hemisphere       X-Z plane (+ = southern
!             tilted towards sun).           hemisphere tilted towards sun).
!           Not updated in time.             CorotationLon = longitude of the
!                                            rotation axis (around the z axis)
!                                            (+ counterclockwise looking 
!                                             down z axis).
!                                            Not updated in time.
! 
! The values of BdpDim and ThetaTilt are read only if AxesType for 
!     dipole is 'user'
! The values of CorotationTilt, CorotationLon, and rot_period are read only if 
!     AxesType for corotation is 'user'
!
</command>

<command name="DIPOLE" if="$IsFirstSession">
	<parameter name="BdpDim" type="real" default="-31100.0"		/>
	<parameter name="DoSetDipoleTilt" type="logical" default="F"	/>
	<parameter name="ThetaTilt" type="real" min="0" max="180"
                                                        default="30"    />
	<parameter name="DtUpdateB0" type="real" input="select">
		<option name="No update" value="-1" default="T"	/>
		<option name="Default update rate" value="0"	/>
		<optioninput name="Set update rate" min="0" default="60" />
	</parameter>
#DIPOLE
-31100.0		BdpDim [nT] dipole strength=equatorial field strength
F			DoSetDipoleTilt
0.0			ThetaTilt
0.0			dtUpdateB0

! The #DIPOLE command is included for backward compatibility (use #AXES).
!
! DipoleStrength    -  strength of the magnetic field at the equator in nT 
! SetDipoleTilt     -  If false, then set the dipole tilt angle
!                      according to the time of day and day of year.
!                      So far, this only works with problem_earth.
!                      If true, set the dipole angle according to ThetaTilt
! ThetaTilt         -  The angle of the dipole in the X-Z plane.
!                      can only be manually set if SetDipoleTilt = .true.
! DtUpdateB0        -  If you have a time_accurate run and you want the
!                      dipole to move, the B0 must be updated at regular
!                      intervals.  This variable allows you to do this.
!                      It is only used if SetDipoleTilt = .false. and
!                      DoTimeAccurate is .true.  Settings for this variable
!                      are:  &lt; 0.0  do not update B0.
!                             = 0.0  automatically figure out when to update
!                            &gt; 0.0  manually set the update rate.
! Default value depends on problem_type.
</command>

<command name="COROTATION" if="$IsFirstSession">
	<parameter name="UseCorotation" type="logical" default="F" />
	<if expr="$UseCorotation">
		<parameter name="DoAlignCorotation" type="logical" 
				default="T"				/>
		<parameter name="DoSetCorotationTilt" type="logical" 
				default="F" if="not $DoAlignCorotation"	/>
		<parameter name="CorotationTilt" type="real" min="0" max="180"
				default="30" if="$DoSetCorotationTilt"	/>
	</if>
#COROTATION
T			UseCorotation  (rest of parameters read if true)
F			DoAlignCorotation (rest of parameters read if false)
F			SetCorotationTilt (rest of parameters read if true)
0.0			CorotationTilt

! The #COROTATION command is included for backward compatibility (use #AXES). 
! 
! UseCorotation         - Apply a corotation velocity at the boundary or not
! AlignDipoleCorotation - If this is true, then the dipole and the corotation
!                         axis are automatically aligned.  If not, then the
!                         Axis tilt angle can be set.
! SetCorotationTilt     - True if you want to set tilt manually
!                         False if you want time of day to determine tilt
! CorotationTilt        - if AlignDipoleCorotation = .false., then you must
!                         manually set a tilt angle in degrees
</command>

<!-- ^CFG IF SECONDBODY BEGIN -->
<command name="SECONDBODY" if="$IsFirstSession">
	<parameter name="UseBody2" type="logical" default="F"/>
	<if expr="$UseBody2">
		<parameter name="rBody2" type="real" min="0"
							default="0.1"/>
		<parameter name="xBody2" type="real" min="$xMin" max="$xMax"
							default="-40"/>
		<parameter name="yBody2" type="real" min="$yMin" max="$yMax"
							default="0" />
		<parameter name="zBody2" type="real" min="$zMin" max="$zMax"
							default="0" />
		<parameter name="rCurrents2" type="real" min="$rBody2"
							default="1.3*$rBody2"/>
		<parameter name="RhoDimBody2" type="real" min="0"
							default="5" />
		<parameter name="tDimBody2" type="real" min="0"
							default="25000"/>
	</if>
#SECONDBODY
T			UseBody2   ! Rest of the parameters read if .true.
0.01			rBody2 
-40.			xBody2
0.			yBody2
0.			zBody2
0.011                   rCurrents2  !This is unused currently 
5.0			RhoDimBody2 (/ccm) density for fixed BC for rho_BLK
25000.0			TDimBody2 (K) temperature for fixed BC for P_BLK

! Default for UseBody2=.false.   -   All others no defaults!
! This command should appear before the #INNERBOUNDARY command when using
! a second body.
</command>

<command name="DIPOLEBODY2" if="$IsFirstSession">
	<parameter name="BdpDim2" type="real" default="0" />
#DIPOLEBODY2
-1000.0			BdpDim2 [nT] dipole strength=equatorial field strength

!for now the dipole of the second body can only be aligned with the z-axis
</command>
<!-- ^CFG END SECONDBODY -->
</commandgroup>

<commandgroup name="OTHER MODULES">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!! OTHER MODULES !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

<!-- ^CFG IF IONOSPHERE BEGIN -->
<command name="IONOSPHERE">
	<parameter name="UseIonosphere" type="logical" default="F" />
	<if expr="$UseIonosphere">
		<parameter name="ConductanceModel" type="integer"
								input="select">
			<option name="(0) constant pedersen and 0 Hall"
								value="0" />
			<option name="(1) constant pedersen and Hall"
								value="1" />
			<option name="(2) F107 flux and and constant Hall"
								value="2" />
			<option name="(3) Simple oval"		value="3" />
			<option name="(5) Realistic oval" 	value="5" 
								default="T"/>
		</parameter>
		<parameter name="UseFullCurrent" type="logical" default="F"/>
		<parameter name="UseFakeRegion2" type="logical" default="F"/>
		<parameter name="F107Flux" type="real" min="0" default="150"/>
		<parameter name="StarLightPedConductance" type="real" min="0" 
							default="0.25"/>
		<parameter name="PolarCapPedConductance" type="real" min="0" 
							default="0.25"/>
		<parameter name="DnCoupleIonosphere" type="integer" min="-1"
							default="100"/>
		<parameter name="DtCoupleIonosphere" type="real" min="-1"
				if="$DoTimeAccurate"	default="-1"/>
	</if>
#IONOSPHERE
T			UseIonosphere   ! Rest of the parameters read if .true.
5			iConductanceModel
F			UseFullCurrent
F                       UseFakeRegion2
150.			F107Flux
0.25			StarLightPedConductance
0.25			PolarCapPedConductance
100			DnCoupleIonosphere
60.0			DtCoupleIonosphere ! Read if time accurate

! Default is UseIonosphere=.false.

! conductance_models :
! 0 - uses a constant pedersen conductance which is set by 
!     PolarCapPedConductance
! 1 - uses a constant pedersen conductance which is set by 
!     PolarCapPedConductance, and a constant Hall conductance
!     which is set by StarLightPedConductance
! 2 - uses a solar EUV combined with a nightside conductance, so
!     it uses f107_flux and StarLightPedConductance
! 3 - uses solar EUV, nightside, and crude oval, so uses
!     f107_flux, StarLightPedConductance, and PolarCapPedConductance,
!     since a polar cap is defined with the oval.
! 4 - doesn't work
! 5 - more realistic oval, uses same variables as 3.
</command>
<!-- ^CFG END IONOSPHERE -->

<!-- ^CFG IF TIEGCM BEGIN -->
<command name="UAM">
	<parameter name="UseUam"     type="logical" default="F"/>
	<if expr="$UseUam">
		<parameter name="DoUamToMhd" type="logical" default="F"/>
		<parameter name="DoMhdToUam" type="logical" default="F"/>
	</if>
#UAM
F			UseUAM
F			UAMtoMHD
F			MHDtoUAM

! The above "DoUamToMhd" and "DoMhdToUam" describe whether the coupling is one
! way or two way.  If both are true, then the coupling is two way. If you
! want a static neutral wind pattern, then you can set DoUamToMhd to true
! and DoMhdToUam to false and this will read in a neutral wind pattern 
! (which you must produce),
! but won't feed anythin back to the UAM.  If you don't want the neutral
! wind to influence the potential pattern, but you want the potential and
! then precipitation to be used in the UAM, then set MHDtoUAM to true
! and DoUamToMhd to false.
</command>
<!-- ^CFG END TIEGCM -->

<!-- ^CFG IF RCM BEGIN -->
<command name="IM">
	<parameter name="UseIm" type="logical" default="F"	/>
	<if expr="$UseIm">
		<parameter name="DnCoupleIm"  type="integer" min="-1"/>
		<parameter name="DtCoupleIm"  type="real"    min="-1"/>
		<parameter name="TauCoupleIm" type="real"    min="0"/>
	</if>
#IM
F			UseIM
100			dnCoupleIM
600.			dtCoupleIM
0.01			tauCoupleIM
</command>
<!-- ^CFG END RCM -->

<command name="AMIE">
	<parameter name="UseAmie" type="logical" default="F"/>
#AMIE
F			UseAmie
</command>

<command name="RAM">
	<parameter name="UseRam" type="logical" default="F"/>
#RAM
F			UseRam
</command>
</commandgroup>

<commandgroup name="SOLAR PROBLEM TYPES">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!! SOLAR PROBLEM TYPES !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="HELIOSPHERE" if="$IsFirstSession">
	<parameter name="BodyTDim"   type="real" min="0" default="2.85E06"/>
	<parameter name="BodyRhoDim" type="real" min="0" default="1.50E8"/>
	<parameter name="qSun"	     type="real" min="0" default="25.0"/>
	<parameter name="tHeat"	     type="real" min="0" default="1.75"/>
	<parameter name="rHeat"	     type="real" min="0" default="1.0"/>
	<parameter name="SigmaHeat"  type="real" min="0" default="4.5"/>
	<parameter name="DoInitRope" type="logical" default="F" />
	<if expr="$DoInitRope">
	 <parameter name="CmeA"	     type="real" min="0" default="0.7"	  />
	 <parameter name="CmeR1"     type="real" min="0" default="1.2"    />
	 <parameter name="CmeR0"     type="real" min="0" default="1.0"    />
	 <parameter name="CmeA1"     type="real" min="0" default="0.23"   />
	 <parameter name="CmeAlpha"  type="real"	 default="0.0"	  />
	 <parameter name="CmeRho1"   type="real" min="0" default="2.5E-12"/>
	 <parameter name="CmeRho2"   type="real" min="0" default="2.0E-13"/>
	 <parameter name="ModulationRho" type="real" min="0" max="10"
							 default="0.0"	  />
	 <parameter name="ModulationP" type="real" min="0" max="10"
							 default="0.0"  />
	</if>
#HELIOSPHERE
2.85E06			BodyTDim	[K]
1.50E8			BodyRhoDim	[N/ccm]
25.00			qSun		
1.75			tHeat
1.00			rHeat
4.50			SIGMAheat
F			InitRope
0.7     		CmeA    [scaled] contraction distance
1.2     		CmeR1   [scaled] distance of spheromac from sun center
1.0     		CmeR0   [scaled] diameter of spheromac
0.23    		CmeA1   [Gauss]  spheromac B field strength
0.0     		CmeAlpha[scaled] cme acceleration rate
2.5E-12 		CmeRho1 [kg/m^3] density of background corona before contract
2.0E-13 		CmeRho2 [kg/m^3] density of background corona after contract 
0.0                     ModulationRho
0.0                     ModulationP

! Default values are shown. Parameters for problem_heliosphere
</command>

<command name="INERTIAL" if="$IsFirstSession">
	<parameter name="UseInertial" type="logical" default="F"/>
#INERTIAL
F		UseInertial

! Use the inertial frame for the heliosphere calculation? 
</command>

<command name="CME" if="$IsFirstSession">
	<parameter name="TypeCme" type="string" input="select">
		<option name="Low" default="T" />
	</parameter>
	<parameter name="CmeA"	    type="real" min="0"	default="0.7"	/>
	<parameter name="CmeR1"	    type="real" min="0"	default="1.2"	/>
	<parameter name="CmeR0"     type="real" min="0"	default="1.0"	/>
	<parameter name="CmeA1"     type="real" min="0"	default="0.23"	/>
	<parameter name="CmeAlpha"  type="real"		default="0.0"	/>
	<parameter name="CmeRho1"   type="real" min="0"	default="2.5E-12"/>
	<parameter name="CmeRho2"   type="real" min="0"	default="2.0E-13"/>
	<parameter name="CmeB1Dim"  type="real"		default="1.0"	/>
	<parameter name="CmeUErupt" type="real" min="0" default="4.0E5"	/>
#CME
Low		TypeCme   model type ('Low')
0.7		CmeA    [scaled] contraction distance
1.2             CmeR1   [scaled] distance of spheromac from sun center
1.0             CmeR0   [scaled] diameter of spheromac
0.23		CmeA1   [Gauss]  spheromac B field strength
0.0		Cmealpha   [scaled] cme acceleration rate
2.5E-12		CmeRho1 [kg/m^3] density of background corona before contract
2.0E-13		CmeRho2 [kg/m^3] density of background corona after contract 
1.0             CmeB1Dim [Gauss] field strength of dipole-type B field
4.0E5           CmeUErupt  [m/s] cme velocity

! Default values are shown above for B.C. Low's CME model
</command>

<command name="ARCADE" if="$IsFirstSession">
	<parameter name="tArcDim"	type="real" min="0"
							default="1.0E6" />
	<parameter name="RhoArcDim"	type="real" min="0"
							default="1.0E-12"/>
	<parameter name="bArcDim"	type="real" min="0"
							default="0.718144" />
	<parameter name="ByArcDim"	type="real"	default="1.0E6" />
	<parameter name="UzArcDim"	type="real"	default="5.0E3" />
	<parameter name="Phi0Arc"	type="real"	default="0.5"	/>
	<parameter name="MuArc"		type="real"	default="1.3"	/>
	<parameter name="ExpArc"	type="real" min="0"
							default="3"	/>
	<parameter name="WidthArc"	type="real" min="0"
							default="0.5"	/>
#ARCADE
1.0E6                   tArcDim   [K]      1.0E6
1.0E-12                 RhoArcDim [kg/m^3] 1.0E-12
0.71814                 bArcDim   [Gauss]  0.718144
0.0                     ByArcDim  [Gauss]
5.0E3                   UzArcDim  [5.0E3 m/s]
0.5                     Phi0Arc
1.3                     MuArc
3                       ExpArc
0.5                     WidthArc

! Default values are shown. Parameters for problem_arcade
</command>
</commandgroup>

<commandgroup name="COMET PROBLEM TYPE">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!! COMET PROBLEM TYPE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="COMET" if="$IsFirstSession">
	<parameter name="ProdRate"		type="real" min="0"/>
	<parameter name="UrNeutral"		type="real" min="0"/>
	<parameter name="AverageMass"		type="real" min="0"/>
	<parameter name="IonizationRate"	type="real" min="0"/>
	<parameter name="kFriction"		type="real" min="0"/>
#COMET
1.0E28		ProdRate    - Production rate (#/s)
1.0		UrNeutral   - neutral radial outflow velocity (km/s)
17.0		AverageMass - average particle mass (amu)
1.0E-6		IonizationRate (1/s)
1.7E-9		kFriction - ion-neutral friction rate coefficient (cm^3/s)

! Only used by problem_comet.  Defaults are as shown.
</command>
</commandgroup>

<commandgroup name="SCRIPT COMMANDS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!! SCRIPT COMMANDS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="INCLUDE">
	<parameter name="NameIncludeFile" type="string" length="100" 
		default="Param/" />
	<formValue name="containsSession" type="logical" default="F" />
	<set name="IsFirstSession" type="logical" value="F" 
		if="$containsSession" />

	<formValue name="setsTimeAccurate" type="integer" input="select">
		<option name="no change"     value="0" default="T"	/>
		<option name="steady state"  value="-1"			/>
		<option name="time accurate" value="1"			/>
	</formValue>
	<set name="DoTimeAccurate" type="logical" value="$setsTimeAccurate>0"
		if="$setsTimeAccurate != 0" />
#INCLUDE
Param/SSS_3000		NameIncludeFile

! Include a library file from Param/ or any file from anywhere else
</command>

<command name="RUN">
	<set name="IsFirstSession" type="logical" value="F" />
	<set name="IsNewSession"   type="logical" value="T" />
#RUN

! Run BATSRUS with the parameters above and then return for the next session
</command>

<command name="END">
	<set name="Done" type="logical" value="T" />
#END

! Run BATSRUS with the parameters above and then stop BATS-R-US
! In included files #END simply means the end of the included lines.
</command>
</commandgroup>
<!--
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!! GLOBAL RULES !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-->
<rule expr="($SwRhoDim > 0) or $UseUpstreamInputFile">
	Either command #SOLARWIND or #UPSTREAM_INPUT_FILE must be used!
</rule>

</commandList>
