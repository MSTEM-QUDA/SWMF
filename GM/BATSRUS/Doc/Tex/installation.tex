%^CFG COPYRIGHT UM
\section{Installation and Compilation \label{section:install_compile}}

\subsection{Code Installation \label{section:install}}
The \BATSRUS\ distribution is a tar file which contains all of the
relevant source code, scripts and documentation.  Distributions are
labeled {\tt distBATSRUS\_vX.XX\_mm-dd-yy-hhmm.tar} where {\tt X.XX} is the
version number, {\tt mm-dd-yy} is the date of the distribution and
{\tt hhmm} is the time of the distribution.  Installation of the {\tt
.tar} file will place a single directory named {\tt BATSRUS\_vX.XX} (referred to
as the ``root of the distribution'') 
in the current directory and will create several subdirectories.

To install the code, locate the {\tt .tar} file in the directory 
where you want the {\tt BATSRUS\_vX.XX} directory to reside.  Then type
\begin{verbatim}
tar -xvf distBATSRUS_vX.XX_mm-dd-yy-hhmm.tar
\end{verbatim}

Upon installing \BATSRUS, you should find the following files
and directories inside the {\tt BATSRUS\_vX.XX} directory.  
The subdirectories are included without listing
all of the files that they contain.

\begin{verbatim}
File or Directory:         Notes:
			
Doc/                       Documentation 
   MANUAL.pdf              Users Manual in .pdf format
   MANUAL.ps.gz            Users Manual in .ps format and is gzipped
   RELEASENOTES            Listing of changes made to the code by version
   Tex/                       Latex source code for documentation
Idl/                       Source code for IDL post processing
Makefile                   Main makefile-calls others in src,srcIONO,srcTIEGCM
Param/                     Sample PARAM.in files, include files, and FULL
Scripts/                   Contains scripts to run the code on
   IDL/                       Scripts used to process IDL files
   Run/                       Scripts used to run BATSRUS and process output
      AIX/                       -IBM SP
      IRIX/ -> IRIX64/           -SGI Origin
      IRIX64/                    -SGI Origin
      Linux/                     -Linux (Beowulf Clusters)
      pp_IDL/			 -Scripts for processing IDL files
      pp_TEC/			 -Scripts for processing TEC files	
      sn6330/                    -Cray T3E
   TEC/                       Scripts used to process TECPLOT files
   Tools/                     Scripts for doing various useful things
TEST/                      Contains logfiles from previous tests
src/                       Source code for BATSRUS,scripts,makfiles,mpi
srcIONO/                   Source code for the ionosphere
srcTIEGCM/                 Source code for the TIEGCM
\end{verbatim}

\subsection{Quick Start \label{section:quick_start}}

This should work on a large number of platforms. If it does not,
see sections below on compiling and running the code. Type the following
commands after putting the {\tt distBATSRUS\_vX.XX\_mm-dd-yy-hhmm.tar} file 
in the current directory:
\begin{verbatim}
tar -xvf distBATSRUS_vX.XX_mm-dd-yy-hhmm.tar
cd BATSRUS_vX.XX
make
make rundir_abs
cd run
mv PARAM.in PARAM.DEFAULT
mv PARAM.TEST PARAM.in
cd ..
make dorun
\end{verbatim}
The 
{\tt Param.TEST} file runs a standard test which is used to determine
if the code is giving the same results on different platforms.  The
user can (and should) compare the results of the logfile in {\tt IO2/} with 
logfiles in {\tt TEST/} which were generated on other platforms.


\subsection{Setting Grid Structure Before Compiling \BATSRUS\ \label{section:before_compile}}

Part of the design of \BATSRUS\ is the conscious decision to limit the
usage of allocateable variables.  This is because
allocateable memory was found to slow the code considerably and 
the choice was made to maximize code speed.  This means that the
the main arrays of \BATSRUS\ must be dimensioned in the source code.
Since platforms vary widely, there is no way to set these in a universal
way and the user will have to set them.  There are two main sets of 
parameters that must be changed.

\subsubsection{Number of Blocks per Processor: {\tt nBLK} \label{section:nblk}}

As described in section~\ref{section:blocks}, 
the main unit of mesh used for computation in \BATSRUS\ 
is the Cartesian block.  The major part of memory is dimensioned in this
block structure.  Therefore, the number of blocks basically determines the
amount of memory the code will use.  The number
of blocks that any given processor can handle depends on the amount of
memory that each node has available and must be changed in the file {\tt src/ModMain.f90}.
The code variable that must be changed is {\tt nBLK}.  The source code in    
{\tt ModMain.f90} begins
\begin{verbatim}
module ModMain

  character (len=10) :: CodeVersion='X.XX'

  !\
  ! Block parameters.
  !/
  integer, parameter :: nBLK=500
  integer :: nMultiBlkLevels, globalBLK

  !\
  ! Cell array parameters.
  !/
  integer, parameter :: nCellsI=4,  &
                        nCellsJ=4,  &
                        nCellsK=4
...
\end{verbatim}
Changing  {\tt nBLK} is somewhat an exercise in trial and error.  As an example,
on the Cray T3E at Goddard Space Flight Center, each node has 128 MB of memory.
Using 4x4x4 blocks with 8 byte reals, the maximum {\tt nBLK} is around 150.  
On a Beowulf cluster 
with 750 MB of memory per node and 4 byte reals, the maximum {\tt nBLK} is 7000.

\subsubsection{Number of Cells in Each Block: {\tt nCellsI},
{\tt nCellsJ}, {\tt nCellsK} \label{section:ncells}}

Typically, \BATSRUS\ is run with blocks that are cubes, but this does not have to
be the case.  The size of blocks is determined in {\tt ModMain.f90} by the parameters 
{\tt nCellsI}, {\tt nCellsJ}, {\tt nCellsK}, the numbers of cells in a block
in each dimension.  This number does not include ghost cells which the code
takes care of automatically.  The user should set these numbers according to
their needs based on the following restrictions.
\begin{itemize}
\item {\tt nCells} variables should not be less than 4 and must be set as even
      integers (4, 6, 8, 10 ...). If the grid is uniform (all cells the same size)
      the code should run with {\tt nCells} set to 2.
\item Smaller blocks means a larger ratio of ghost cells to computational cells.
      For example a 4x4x4 block has a 64 cell computation region, while
      it has 8x8x8 = 512 total cells counting ghost cells.  In other words,
      the majority of the storage is ghost cells (\#Ghost/\#Computation = 7).
      If the user used 8x8x8 blocks, the computation region would have 512 
      cells while the total number of cells is 1728 and the ratio of ghost cells
      to computation cells is only 2.4.
\item The time the code spends message passing depends on the number of
      ghost cells in a block and on the number of blocks.  With larger blocks
      the message passing time may be reduced.
\item Larger blocks mean more wasted cells when doing AMR to resolve
      features of the solution.  If the user uses 4x4x4 block he or she will
      have much better control over where the resolution is located.  With larger
      blocks the user will have to resolve a larger area to get the interesting
      area resolved.
\end{itemize}
The user should note that as usual, in numerical simulations there is a trade off
in efficiency in resolving the solution and the amount of storage.  In general,
larger blocks mean less ``wasted'' storage but will inevitably lead to more cells
to resolve the same features.

At this point we provide the user with a little insight about makefiles and 
{\tt ModMain.f90}.  With a makefile, when recompiling after a change is 
made to the source
code, the makefile will only recompile the necessary source files.  However,
since every routine in \BATSRUS\ depends on {\tt ModMain.f90}, changing it will
force every file to be recompiled.

\subsubsection{Getting the Grid you Want \label{section:proc_dims}}

The initial grid (before any refinement) contains
a number of blocks determined by the {\tt proc\_dims(i)} variable, where
{\tt i} is the direction (1=x, 2=y, 3=z).  If the values are set to
\begin{verbatim}
proc_dims(1) = 2
proc_dims(2) = 1
proc_dims(3) = 1
\end{verbatim}
then the top level blocks form a brick consisting of 2 blocks arranged along the
x axis.  
The parameter is called {\tt proc\_dims} because {\bf the initial
number of blocks cannot exceed the number of processors}.
In other words,
\begin{verbatim}
Number of Processors > proc_dims(1)*proc_dims(2)*proc_dims(3)
\end{verbatim}
is required.

The sizes of cells in these top level blocks is determined
by the initial number of blocks and
also by the physical size of the computational domain and the 
values of {\tt nCellsI}, {\tt nCellsJ}, {\tt nCellK}.
As an example, we show
a section of the input parameters used when running the code (see 
section~\ref{section:param_details}).
\begin{verbatim}
#GRID        
4                      proc_dims(1)
2                      proc_dims(2)
1                      proc_dims(3)
-32.                   x1 
 32.                   x2 
-8.                    y1 
 8.                    y2 
 0.                    z1 
 4.                    z2 
\end{verbatim}

These input parameters, along with  
{\tt nCells} define the initial grid used in the simulation.
The {\tt proc\_dims} variables are 
are the initial number of blocks to use in the simulation in the different
directions.  
The values x1, x2, ... indicate the physical 
domain of the computation.  In section~\ref{section:ncells}
we indicated that the number of cells in a block in each direction is determined
in {\tt ModMain.f90}.  Here we determine the actual shape of the computational
domain as well as the actual shape of each cell. Typically, \BATSRUS\ is
run with cells and blocks that are cubes.  While this is not required, 
cells that have large aspect ratios may lead to less accurate computations.  
The shape of a cell is
determined by the {\tt nCells}, the {\tt proc\_dims} and the physical size of 
each dimension. 
The size of a cell
in the top level blocks is given by 
\begin{equation}
dx = \frac{x2-x1}{\mbox{proc\_dims(1)}*\mbox{nCellsI}} \qquad
dy = \frac{y2-y1}{\mbox{proc\_dims(2)}*\mbox{nCellsJ}} \qquad
dz = \frac{z2-z1}{\mbox{proc\_dims(3)}*\mbox{nCellsK}}
\end{equation}

We give three examples.
First, with 4x4x4 blocks, if the physical dimension
of the computation region is a cube, then setting the initial number of blocks
in each dimension ({\tt proc\_dims}) equal will ensure cells that are cubes.  
For the second example, if one dimension is twice
as large as the other two, then beginning with twice as many blocks in this dimension
will again ensure cubic cells.  
Finally, combining x1, x2, nCells and proc\_dims can allow the user to make computation
regions that are highly stretched in  one dimension while still having
cubic cells.  If the user wanted to do a two dimensional problem, for example,
he or she could choose parameters to minimize the numbers of cells in 1 dimension.
Figure~\ref{fig:stretched_initial_grid} shows a 2 dimensional view of a 
grid defined using the input shown above and 
with {\tt nCellsI} = 16, {\tt nCellsJ} = 8, {\tt  nCellsK = 4}.
In the figure, the dark lines show the locations of blocks, initially
4x2x1 (the z dimension is not shown).  This grid would have to be 
run on at least 8 processors.  The
The lighter lines show the individual cells in one of the blocks.  These are 16x8x4 
(again, the z dimension is not shown).  Notice that the cells are cubes (dx=dy=dz=1.0),
but the computation region is stretched in the x and y directions.
\begin{figure}
\begin{center}
\includegraphics*[width=6.0in]{proc_dims.eps}
\end{center}
\caption{Initial block and grid structure for {\tt proc\_dims} of 4x2x1
and {\tt nCells} of 16x8x4.  The z dimension is not shown.  Heavy line indicate
blocks, lighter lines indicate individual cells.
\label{fig:stretched_initial_grid}
}
\end{figure}

{\bf THERE IS ONE OTHER RESTRICTION ON THE WAY THAT GRIDS CAN BE CREATED
WHEN USING A CENTRAL BODY.}
Because the first body is created with its center at the origin, it is
important that eight block corners meet at the origin.  The user must 
think ahead so that the final desired refinement level at the body
satisfies this restriction.  While
the code may run if this is not that case, Tecplot output will not be
correct, initial refinement may not do what you thought it should and
there may be other problems.  
We give parameters for the standard Earth case as an example
\begin{verbatim}
#GRID        
2                      proc_dims(1)
1                      proc_dims(2)
1                      proc_dims(3)
-224.                  x1 
 32.                   x2 
-64.                   y1 
 64.                   y2 
 64.                   z1 
 64.                   z2 
\end{verbatim}
Initially there are two blocks which meet at x=-96. 
The origin does not lie at block corners.
Two refinements of these initial blocks will create 128 blocks and
will give the required corners at the origin.  Since this case is
never run with a lower resolution than this we are okay.


\subsection{The Main Makefile \label{section:main_make}}

The \BATSRUS\ executable and all the post processing executables along
with run directories can all be set up from the main makefile.  Typing
\begin{verbatim}
make help
\end{verbatim}
lists the available executables, directories and scripts which can be built 
or executed.  The output is 

\begin{verbatim}
You can "make" the following:

  <default> BATSRUS

  BATSRUS (Block Adaptive Tree Solar-Wind Roe Upwind Scheme)
  NOMPI   (NOMPI library for single node execution with no MPI)
  PIO     (ProcessIO program creates 1 TecPlot zone w/o redundant nodes)
  PIDL    (PostIDL program creates 1 .out file from local .idl files)

  help      (makefile option list)
  clean     (remove files: *~ *.o *.kmo *.mod *.T *.lst core)
  distclean (remove files: *~ *.o *.kmo *.mod *.T *.lst core *exe)
  dist      (create source distribution tar file)

  rundir_abs  (create run directory with absolute links)
  rundir_rel  (create run directory with relative links)

  dorun       (check if BATSRUS is up to date and run BATSRUS.exe on 8 PE-s)
  dorun NP=77 (check if BATSRUS is up to date and run BATSRUS.exe on 77 PE-s)
  pIDL                (process IO2/*.idl files)
  pIDL TYPE='z=0_ray' (process IO2/z=0_ray*.idl files)
\end{verbatim}

\noindent
As an example, in order to make {\tt BATSRUS.exe}, simply type 
\begin{verbatim}
make
\end{verbatim}
To make a distribution (tar file) of the code like the one used for installation,  type
\begin{verbatim}
make dist
\end{verbatim}
To make a directory with everything setup to run code (with links
that are relative to the current directory), 
\begin{verbatim}
make rundir_rel
\end{verbatim}
The executables reside in the {\tt src} directory.  When a run
directory is created it is located in the root directory of the
installation and will have links to the executables, will have copies of
the appropriate scripts for the current platform and will have the
directory structure for running the code setup.

The Makefile in the root directory of the distribution calls one of several
different makefiles in the  {\tt src/} and {\tt srcIONO/} directories
in order to do the
actual compilations.  The makefile called is platform dependent.

\subsection{The Makefiles in {\tt src/} and {\tt srcIONO/} \label{section:src_make}}

In the root directory of the distribution is a Makefile.  This makefile calls 
other makefiles in the {\tt src/} and {\tt srcIONO/} directories 
which actually compile the code.  There is a {\tt Makefile}, 
a {\tt Makefile.COMMON} which contains
pieces that are common for each system and there are makefiles which are platform 
dependent.  These have the naming convention 
{\tt Makefile.uname}, where
{\tt uname} is the platform name provided by the system.
These makefiles are platform dependent because different
compiler flags and optimizations must be used.  The main Makefile
looks at the system {\tt uname} and decides if it recognizes the
current system. The currently recognized systems are:
\begin{tabbing}
{\tt uname}      \hspace{.5in} \= Platform                \\
---------------   \> ----------------------- \\
AIX               \> IBM SP                  \\
IRIX              \> SGI ORIGIN              \\
IRIX64            \> SGI ORIGIN              \\
Linux             \> Linux (Beowulf Cluster) \\
sn6330            \> Cray T3E                
\end{tabbing}
If your system is not recognized you will have to do the following:
\begin{itemize}
\item Modify {\tt Makefile} in the root of the distribution to contain
      a call to a {\tt Makefile.uname} in the {\tt src/} and {\tt srcIONO/} 
      directories.
\item Modify {\tt Makefile} and {\tt Makefile.COMMON} in the {\tt src/} and
      {\tt srcIONO} if necessary.
\item Create a  {\tt Makefile.uname} in the {\tt src/}  and {\tt srcIONO}
       directories
      which contains the correct compiler and optimization flags for
      your platform.  
\item Get the proper mpif90.h file for you platform and include it in
      {\tt src/} with the name {\tt mpif90\_uname.h}.  In addition, you will
      have to make the necessary changes to the file for 8 byte reals and 
      include this new file with the name {\tt mpif90\_uname-r8.h}
\item Create a subdirectory in the {\tt Scripts} directory to contain any
      run scripts you would like to have put in the run directory when
      using the Makefile to make a run directory.
\end{itemize}


\subsection{Compiler Flags \label{section:compiler_flags}} 

The individual makefiles, {\tt Makefile.uname}, have system dependent flags.
In these files, the user will find several sets of commented out flags.
The default version will be the one that should be used for running 
the code to do production type runs.  Other sets of flags include
those for debugging (which does more error checking), among others.
As mentioned above, compile flags are not trivial to set and if the user 
has to change them, they will
likely have to consult the manual pages of the F90 compiler.

One main flag, {\bf PRECISION},  that is in the individual 
makefiles, {\tt Makefile.uname},
is the number of bytes a real number occupies.  
On most systems the default size real is 4 bytes.  
On the Cray T3E, there is no choice and reals are 8 bytes. 
In the Makefiles, the flag {\bf PRECISION} can be changed to
indicate the number of bytes to use for a real.
When debugging it is often necessary to use 8 byte real to differentiate
round off error from true errors.  For production runs, 8 byte reals should
be more accurate, but may not always be necessary. 
Using 8 byte real will double the size of the code.
The trade off is of course loss of some accuracy with 4 byte reals
and increased code and restart file size for 8 byte reals.
In addition, on 32 bit machines (such as most PC's and Suns), the code
will run slower (about 30 \% on our PC based Beowulf) when using 8 byte reals.

Another compiler flag that the user may need to change is the {\bf MPILIB}
flag.  As mentioned in section~\ref{section:compiler}, the code can be
run on a single processor with our {\tt NOMPI} library, which the user
can make (see section~\ref{section:main_make}).  To run with this library the
{\bf MPILIB} needs to be changed from calling the system libraries to 
the NOMPI library.  As an example, the {\tt Makefile.IRIX64}, is the makefile
for the SGI Origin.  In this makefile the user will find the following lines:
\begin{verbatim}
MPILIB = -lmpi
#MPILIB = -L. -lNOMPI
\end{verbatim}
To use the {\tt NOMPI} library, the first line must be commented out (place a 
\# in front of the line) and the \# should be removed from the second line.
The {\tt NOMPI} library currently will only run with a single block.  This
means that {\tt proc\_dims}=1 and no AMR is possible
.
\subsection{Run  Directory Structure \label{section:run_dir}}

The {\tt run} directory is setup using {\tt make rundir\_abs} (links with absolute
paths) or  {\tt make rundir\_rel} (links with relative
paths) from the root directory of
the distribution. 
The purpose for creating run directories is to separate runs.  You can rename them
\begin{verbatim}
mv run run_CME
\end{verbatim}
to do a simulation of a CME, for example.  
If you use absolute links, you can move {\tt run} to another
directory or disk.
A typical run directory created on an SGI would
contain the following

\begin{verbatim} 
BATSRUS.exe -> ../src/BATSRUS.exe             
IO2/                                                 
PARAM.DEFAULT
PARAM.TEST                                           
Param -> ../src/Param/                         
PostIDL.exe -> ../src/PostIDL.exe             
ProcessIO.exe -> ../src/ProcessIO.exe         
core                                                
ionosphere/                                          
job.ames                                            
job.cylon                                           
job.ncsa                                            
makesub.ames                                        
pIDL -> ../src/pIDL                           
pIO -> ../src/pIO                             
pIO2d -> ../src/pIO2d                         
pIO3d -> ../src/pIO3d                         
pIOsph -> ../src/pIOsph                       
restartIN -> restartOUT/                             
restartOUT/                                          
\end{verbatim} 

This directory is now setup to run the code.  Links have been made to 
{\tt BATSRUS.exe} which is the main MHD executable, as well as the 
IDL post processing executable {\tt PostIDL.exe} and the Tecplot post 
processing executable {\tt ProcessIO.exe}.  The scripts {\tt pIOXXX}
are for processing the Tecplot IO files while {\tt pIDL} is for
processing the IDL IO files.  The scripts {\tt job.XXXXX} contain
sample scripts for submitting jobs to the various SGI machines that we
have run the code on.  The {\tt makesub.ames} script builds a job script from
your input parameters  for running the code on the NASA AMES SGI Origin 2000.

The {\tt run} directory contains subdirectories or links to directories
 such as {\tt ionosphere/}, {\tt
restartOUT/}, {\tt IO2/}, and {\tt Param/}.  The first three are needed
to run the code, while the fourth contains input files which can be
inputted from the {\tt PARAM.in} file, as described below.  Without at
least the {\tt IO2/} and {\tt restartOUT/} (and {\tt ionosphere/}, if
the code is run with the ionosphere turned on) subdirectories, the
code will crash.

{\tt IO2/} is the most important directory, since it contains output
of the MHD run.  The {\tt restartOUT/} directory is where restart
files are written.  These files allow the code to be restarted if it
either crashes or if the code must be run on a queue system in which
the run takes longer than the length of the run time allowed on the
machine.  For example, on the CRAY T3E, codes are allowed to run for
16,000 seconds.  Since most time accurate runs take much longer than
this, restart files can be saved near the end of the 16,000 seconds
and the code can be started again after waiting in the queue again.

The {\tt restartIN/} directory is needed to actually restart the run
from a previous run.  Often the {\tt restartIN/}
directory is simply a link to the {\tt restartOUT/} directory.  This, however,
can be dangerous because if something ``bad'' occurs during the
writing of the restart files, the last save may be destroyed.  It is
more wise to move the {\tt restartOUT/} directory to some other
location, link the {\tt restartIN/} directory to this directory, and
create a new {\tt restartOUT/} directory.  This will ensure that the
old save will be secure, while restarting correctly.

{\tt PARAM.DEFAULT} is a sample input file to the \BATSRUS\ code.  This has
to moved to {\tt PARAM.in} and modified.  This file is read in by the code 
and controls the
run and inputs all of the relevant parameters.  More details about this
file are given in section~\ref{chapter:param}.















