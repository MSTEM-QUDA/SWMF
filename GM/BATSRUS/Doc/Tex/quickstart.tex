%^CFG COPYRIGHT UM
\section{Quick Start \label{section:quick_start}}

\subsection{Extracting the code from a tar file}

Create a new and empty directory, and open the tar file you received, eg:
\begin{verbatim}
mkdir bats
cd bats
tar xf distBATSRUS_v7.50_03-12-02-1200.tar  
\end{verbatim}
where the version number and the creation date and time are indicated
in the file name. If the tar file is compressed with {\tt gzip}, use
\begin{verbatim}
gunzip distBATSRUS_v7.50_03-12-02-1200.tar.gz
tar xf distBATSRUS_v7.50_03-12-02-1200.tar
\end{verbatim}

\subsection{Checking out the code with CVS}

If CVS (Concurrent Versions System) is available on your computer
and you have an account on the CVS server machine 
{\tt butch.engin.umich.edu}, you can use CVS to install
the current or a particular version of the code.
First of all have the following environment variables set
\begin{verbatim}
setenv CVSROOT UserName@butch.engin.umich.edu:/home/weymouth/CVSROOT/
setenv CVS_RSH ssh
\end{verbatim}
where {\tt UserName} is your user name on butch. Here it is assumed
that you use csh or tcsh. Also put these settings into your .cshrc file
so it is automatically executed at login. Alternatively, use
\begin{verbatim}
CVSROOT=UserName@butch.engin.umich.edu:/home/weymouth/CVSROOT/
export CVSROOT
CVS_RSH=ssh
export CVS_RSH
\end{verbatim}
under sh, ksh and bash shells, and also put these commands into your 
.bash\_rc or .profile file so it is automatically executed at login.

Once the CVS environment variables are set, you can download the
current (HEAD) version of the BATSRUS distribution with
\begin{verbatim}
cvs checkout BATSRUS
\end{verbatim}
If you want a particular version, use
\begin{verbatim}
cvs checkout -r v7_5_0 BATSRUS
\end{verbatim}
where {\tt v7\_5\_0} is the {it tag} associated with the version.
To download bug fixes or new features, the 
\begin{verbatim}
cvs update
\end{verbatim}
command can be used. See {\tt man cvs} for more information.

%^CFG IF CONFIGURE BEGIN
\subsection{Configuration of the code}

For production runs many features of the code can be configured out.
This makes the compile time shorter and the executable smaller.
To configure the code with the default options listed in the file
\begin{verbatim}
Configure.options
\end{verbatim}
simply type
\begin{verbatim}
Configure.pl
cd Build
\end{verbatim}
The new {\tt Build} directory contains the configured version of the code.
You can compile and run the code in the Build directory just as if you were
in the main directory. The only difference is that the configured out
options cannot be used, of course. You can switch options on and off
from the command line. Remember that if you change the options 
you have to remove or rename the previous Build directory first:
\begin{verbatim}
rm -rf Build
Configure.pl -on=PROJECTION,RAYTRACE -off=BORISCORR
cd Build
\end{verbatim}
The options can also be read from an option file
\begin{verbatim}
Configure.pl -o=MyOptionFile
\end{verbatim}
If you are developing the code, you should edit the source code
in the unconfigured distribution. You can still use a configured
version to test it, of course. To update newly modified files only type
\begin{verbatim}
Configure.pl -u
\end{verbatim}
Remember, however that by default {\tt Configure.pl} configures files 
which are part of the CVS distribution only. Other files must be listed
explicitly:
\begin{verbatim}
Configure.pl src/newfile.f90
Configure.pl srcIONO/*.f90
\end{verbatim}
For more information type {\tt Configure.pl -h}.
%^CFG END CONFIGURE

\subsection{Installing the code}

%^CFG IF TESTING BEGIN
The fastest way of testing the code is to run a test problem.
In the main directory type
\begin{verbatim}
./TestBatsrus.pl
\end{verbatim}
This perl script will compile the code, produce a run directory,
it will run the code, and post process the output.
%^CFG END TESTING

The first step of normal installation is
\begin{verbatim}
make MAKEFILES
\end{verbatim}
which will copy the Makefile belonging to the platform 
(e.g. {\tt src/Makefile.Linux} into the generic {\tt src/Makefile},
also copy {\tt src/Makefile.OPTIONS.ORIG} into {\tt src/Makefile.OPTIONS}.
In case your platform is not supported yet, you will have to create the
{\tt src/Makefile.YourOS} and 
{\tt srcIONO/Makefile\_IONO\_YourOS} files yourself,
where {\tt YourOS} is the string returned by the
UNIX command {\tt uname}.
Now you can edit the Makefiles
\begin{verbatim}
emacs src/Makefile
emacs src/Makefile.OPTIONS
\end{verbatim}
In {\tt src/Makefile} you can set the {\tt PRECISION} variable to decide
if 4 or 8 byte real numbers should be used and you can set the compiler flags
for selecting the optimization level. 
In the {\tt src/Makefile.OPTIONS} certain parts of the code
can be switched on and off.

The next step is
\begin{verbatim}
make install
\end{verbatim}
which will create the appropriate (depending on the 
operating system and the precision of real numbers) MPI header file 
{\tt src/mpif90.h}, the module determining the grid size 
{\tt src/ModSize.f90} and the user defined subroutines 
{\tt src/user\_routines.f90}. Now the grid size can be set by editing
\begin{verbatim}
emacs src/ModSize.f90
\end{verbatim}
In the file the number of the blocks {\tt nBLK=MaxBlock}
, the number of implicit blocks {\tt MaxImplBLK}             %^CFG IF IMPLICIT
and the size of the blocks {\tt nI=nCellsI, nJ=nCellsJ, nK=nCellsK}
can be set. See section \ref{section:block} for details.

\subsection{Compilation}

To compile the main code type
\begin{verbatim}
make
\end{verbatim}
in the main directory. This will produce the executable 
{\tt src/BATSRUS.exe}. For post-processing IDL,
Tecplot Cartesian and/or Tecplot spherical output data 
you need to compile the corresponding executables {\tt src/PostIDL.exe}
and/or {\tt src/PostSPH.exe} using
\begin{verbatim}
make PIDL
make PTEC
make PSPH
\end{verbatim}

\subsection{Running the code}

The next step is to create a run directory with appropriate links
\begin{verbatim}
make rundir
\end{verbatim}
You can specify which post-processing and job scripts should be
included with the PLOT and MACHINE environment variables, e.g.
\begin{verbatim}
make rundir PLOT=IDL MACHINE=bats
\end{verbatim}
will only copy and link the IDL postprocessing codes and scripts,
and it will copy the job scripts containing the name 'bats'.
Before running the code you need to create/edit the input
parameter file
\begin{verbatim}
emacs run/PARAM.in
\end{verbatim}
The files in the Param directory can be used as examples or included
with the {\tt \#INCLUDE} command.
Especially useful is the Param/FULL file which contains
all the possible commands and descriptions.
See \ref{section:param_details} for details.

Now you are ready to run the code. For an interactive run
on 8 processors type
\begin{verbatim}
make mpirun
\end{verbatim}
which is equivalent with
\begin{verbatim}
make
cd run
mpirun -np 8 BATSRUS.exe
\end{verbatim}
To run on a different number of processors either change the number
after the {\tt -np flag} or use
\begin{verbatim}
make mpirun NP=2
\end{verbatim}
On some systems the command to run MPI jobs is called {\tt mprun}
instead of {\tt mpirun}. Then use, for example
\begin{verbatim}
make mprun NP=16
\end{verbatim}
On some platforms it is allowed to execute BATSRUS.exe on a single node 
without the {\tt mpirun} or {\tt mprun} commands:
\begin{verbatim}
make nompirun
\end{verbatim}
On many machines you have to submit the run to a batch queue.
First edit the appropriate job script file and then submit the job,
for example
\begin{verbatim}
emacs job.modi4 
bsub < job.modi4 
\end{verbatim}
The format the job scripts and submission commands depend on
the queuing system. Some of these will be described in 
section \ref{section:platforms}.

\subsection{Postprocssing}

After the code has successfully run, the output files 
found in {\tt run/IO2} need some post processing before 
they can be visualized. The raw IDL plot files {\tt run/IO2/*.idl}
can be processed with
\begin{verbatim}
make pIDL
\end{verbatim}
which is equivalent with
\begin{verbatim}
cd run
pIDL
\end{verbatim}
This command will produce the new {\tt run/IO2/*.out}
files, and delete the {\tt run/IO2/*.idl} files
and the corresponding header files {\tt run/IO2/*.h}.
In case you want to keep the raw data, e.g. to be safe, type
\begin{verbatim}
cd run
pIDL IO2/ KEEP
\end{verbatim}
For complete usage information type {\tt pIDL -h}.

The raw Tecplot files {\tt run/IO2/*.dat} can be processed
into the {\tt run/IO2/new*.dat} or {\tt new*.plt} files
with the commands
\begin{verbatim}
cd run
pTEC p r
\end{verbatim}
where 'p' means the file will be processed with preplot for ready input
in Tecplot, and 'r' refers to the removal of the raw data and header
files.  For complete usage information type {\tt pTEC -h}.

Visualization of the resulting output files with IDL and TecPlot
will be described in detail in sections \ref{section:idl_visualization}
and \ref{section:tecplot_visualization}, respectively.

\subsection{Recompilation and clean up}

If you change some source files, e.g. the number of blocks
in {\tt src/ModSize.f90}, or if you change the selected options in
{\tt src/Makefile.OPTIONS}, the code can be simply recompiled
with the {\tt make} command. However, if the compiler flags or the
precision are changed in {\tt src/Makefile}, you need to clean the
object files with
\begin{verbatim}
make clean
\end{verbatim}
before recompilation. This will remove the object files as
well as the MPI header file {\tt src/mpif90.h} which depends
on the precision. 

To delete all files created during installation and compilation, use
\begin{verbatim}
make distclean
\end{verbatim}
In addition to the object files and the MPI header file, 
this command will remove the executables {\tt src/*.exe}, 
the libraries {\tt src*/*.a}, the source files
{\tt src/ModSize.f90} and {\tt src/user\_routines.f90}, 
and the Makefiles {\tt src/Makefile} and {\tt src/Makefile.OPTIONS}.

For a complete list of possible make targets type
\begin{verbatim}
make help
\end{verbatim}

