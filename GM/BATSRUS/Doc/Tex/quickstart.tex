%^CFG COPYRIGHT UM
\section{Quick Start \label{section:quick_start}}

\subsection{Extracting the code from a tar file}

Create a new and empty directory, and open the tar file you received, eg:
\begin{verbatim}
  mkdir bats
  cd bats
  tar xf distBATSRUS_v7.50_03-12-02-1200.tar  
\end{verbatim}
where the version number and the creation date and time are indicated
in the file name. If the tar file is compressed with {\tt gzip}, use
\begin{verbatim}
  tar xzf distBATSRUS_v7.50_03-12-02-1200.tar.gz
\end{verbatim}
or, if the {\tt tar} command does not recognize the 'z' flag, use
\begin{verbatim}
  gunzip distBATSRUS_v7.50_03-12-02-1200.tar.gz
  tar xf distBATSRUS_v7.50_03-12-02-1200.tar
\end{verbatim}

\subsection{Checking out the code with CVS}

If CVS (Concurrent Versions System) is available on your computer
and you have an account on the CVS server machine 
{\tt butch.engin.umich.edu}, you can use CVS to install
the current or a particular version of the code.
First of all have the following environment variables set
\begin{verbatim}
  setenv CVSROOT UserName@herot.engin.umich.edu:/FRAMEWORK
  setenv CVS_RSH ssh
\end{verbatim}
where {\tt UserName} is your user name on butch. Here it is assumed
that you use csh or tcsh. Also put these settings into your .cshrc file
so it is automatically executed at login. Alternatively, use
\begin{verbatim}
  CVSROOT=UserName@herot.engin.umich.edu:/FRAMEWORK
  export CVSROOT
  CVS_RSH=ssh
  export CVS_RSH
\end{verbatim}
under sh, ksh and bash shells, and also put these commands into your 
.bash\_rc or .profile file so it is automatically executed at login.
Once the CVS environment variables are set, you can download the
current (HEAD) version of the BATSRUS distribution.

When \BATSRUS\ is used within the SWMF, it can be downloaded with
\begin{verbatim}
  cvs checkout SWMF_NEW
\end{verbatim}
as part of the framework and \BATSRUS\ will reside in the
\begin{verbatim}
  GM/BATSRUS
\end{verbatim}
subdirectory. A standalone version of the code can be downloaded
with
\begin{verbatim}
  cvs checkout BATSRUS share_bats util_bats
\end{verbatim}
To download bug fixes or new features, the 
\begin{verbatim}
  cvs update
\end{verbatim}
command can be used. See {\tt man cvs} for more information.

%^CFG IF CONFIGURE BEGIN
\subsection{Configuration of the code}

For production runs many features of the code can be configured out.
This makes the compile time shorter and the executable smaller.
To configure the code with the default options listed in the file
\begin{verbatim}
  Configure.options
\end{verbatim}
simply type
\begin{verbatim}
  Configure.pl
  cd Build
\end{verbatim}
The new {\tt Build} directory contains the configured version of the code.
You can compile and run the code in the Build directory just as if you were
in the main directory. The only difference is that the configured out
options cannot be used, of course. You can switch options on and off
from the command line. Remember that if you change the options 
you have to remove or rename the previous Build directory first:
\begin{verbatim}
  rm -rf Build
  Configure.pl -on=PROJECTION,RAYTRACE -off=BORISCORR
  cd Build
\end{verbatim}
The options can also be read from an option file
\begin{verbatim}
  Configure.pl -o=MyOptionFile
\end{verbatim}
If you are developing the code, you should edit the source code
in the unconfigured distribution. You can still use a configured
version to test it, of course. To update newly modified files only type
\begin{verbatim}
  Configure.pl -u
\end{verbatim}
Remember, however that by default {\tt Configure.pl} configures files 
which are part of the CVS distribution only. Other files must be listed
explicitly:
\begin{verbatim}
  Configure.pl src/newfile.f90
  Configure.pl srcIONO/*.f90
\end{verbatim}
For more information type {\tt Configure.pl -h}.

Some of the usual configurations are provided as makefile targets 
defined in the Makefile\_CONFIGURE file and can be used by typing
for example
\begin{verbatim}
  make globhelio_src
\end{verbatim}
Type {\tt make help} for a complete list of possible targets.
%^CFG END CONFIGURE

\subsection{Installing the code}

In SWMF the components are installed and uninstalled automatically 
at the same time as the framework is installed.
The Makefile.def and Makefile.conf make files in GM/BATSRUS will 
simply include the files with the same name in the SWMF directory.
The rest of this subsection describes the installation procedure
for the stand alone code.
 
In stand alone mode the first thing to do is
\begin{verbatim}
  make install
\end{verbatim}
This will replace the original Makefile.def file, 
create a new Makefile.conf file, 
create src/Makefile.RULES, touch src/Makefile.DEPEND, 
copy src/user\_files.f90, install the code in util/ and share/ etc.

You can install the standalone \BATSRUS\ to behave as if it
was the GM, IH or SC component. The appropriate mode can be
selected with the STANDALONE variable, for example
\begin{verbatim}
  make install STANDALONE=ih
\end{verbatim}
The default component is GM in the stand alone mode.
One can also mimick the behaviour of the pre 7.72 version of \BATSRUS\
by using STANDALONE=old but this is not recommended, encouraged
or even supported. The effect of selecting a certain STANDALONE
mode is to copy one of the {\tt src/stand\_alone\_*.f90} files
into the actually used {\tt src/stand\_alone.f90} file,
and it also sets the STANDALONE variable in the modified Makefile.def.
The original Makefile.def contains STANDALONE=gm, so this is the
default mode. In SWMF the STANDALONE variable is set to 'NO'
in the main Makefile.def.

If the compiler and/or the MPI header file is not the default one
for the given platform (e.g. not f95 on a Linux machine), 
you must provide the extra information in the COMPILER and MPIVERSION 
variables, e.g.:
\begin{verbatim}
  make install COMPILER=ifort MPIVERSION=Altix
\end{verbatim}
In case your platform and/or compiler is not supported yet, 
you will have to create a
\begin{verbatim}
  share/build/Makefile.OsCompiler
\end{verbatim}
file where 'Os' is the name of the operating system returned
by the Unix command {\tt uname}, while 'Compiler' is the name
of the F90 compiler used. For every 'Os' there is a default
compiler, for which 'Compiler' is an empty string.

If the MPI header file needed for your platform is not 
found in share/include, you will have to create an
\begin{verbatim}
  mpif90_OsMpiversion.h
\end{verbatim}
file. This file should be created from the mpif.h file used on your system
with a slight modification in the definition of MPI\_REAL, for example
\begin{verbatim}
      PARAMETER (MPI_REAL=26)
      PARAMETER (MPI_DOUBLE_PRECISION=27,MPI_INTEGER=28)
\end{verbatim}
should be modified to
\begin{verbatim}
      PARAMETER (MPI_REAL=26+iRealPrec)
      PARAMETER (MPI_DOUBLE_PRECISION=27,MPI_INTEGER=28)
\end{verbatim}
The modification defines MPI\_REAL to be the same as MPI\_DOUBLE\_PRECISION
when the iRealPrec variable is 1, and leaves it as the original value
when iRealPrec is 0. The value of iRealPrec is provided at run time.
This modification of the MPI header file allows the code to be compiled 
and run with single and double precision reals as well.

%^CFG IF TESTING BEGIN
\subsection{Testing the code}

The fastest way of testing the installed code is to run a test problem.
In the stand alone code type
\begin{verbatim}
  ./TestBatsrus.pl
\end{verbatim}
while in the framework mode type
\begin{verbatim}
  Scripts/TestSWMF
\end{verbatim}
in the main directory (which simplly calls GM/BATSRUS/TestBatsrus.pl
with the executable name modifed to SWMF.exe).
This perl script will compile the code, produce a run directory,
it will run the code, and post process the output.

A more complete test is to run the test suite. 
In stand alone mode type
\begin{verbatim}
  ./TestSuite.pl func
\end{verbatim}
while in the framework use
\begin{verbatim}
  Scripts/TestSWMF func
\end{verbatim}
which simply executes
\begin{verbatim}
  GM/BATSRUS/TestSuite.pl -x=SWMF.exe func 
\end{verbatim}
Note that the two tests involving the ionosphere 
(the IE/Ridley\_serial component of the SWMF) will only 
run in the framework and will stop with an error message
in the stand alone code.
%^CFG END TESTING

\subsection{Changing the default settings}

To change the precision or the compiler flags you should edit 
\begin{verbatim}
  emacs Makefile.conf
\end{verbatim}
Set the {\tt PRECISION} variable to decide
if 4 or 8 byte real numbers should be used and you can set the compiler flags
for selecting the optimization level. Remember that you have to type
\begin{verbatim}
  make clean
\end{verbatim}
before recompiling the code with a different precision or compiler flags!

In the SWMF the grid size of most components (including \BATSRUS) can
be set with the SetSWMF.pl perl script. This script simply calls
the {\tt GridSize.pl} scripts in the component directories.
In the stand alone mode the grid size can be most conveniently 
changed with directly running the {\tt GridSize.pl} Perl script. Type
\begin{verbatim}
  GridSize.pl -h
\end{verbatim}
to see the usage. The script edits the {\tt src/ModSize.f90} file
and sets the number of the blocks {\tt nBLK=MaxBlock}
, the number of implicit blocks {\tt MaxImplBLK}             %^CFG IF IMPLICIT
and the size of the blocks {\tt nI=nCellsI, nJ=nCellsJ, nK=nCellsK}. 
See section \ref{section:block} for details.

The allocation of the largest arrays can be static or dynamic
(in Fortran 90 the latter is called allocatable). The default
configuration is static which provides slightly faster execution.
If the code is running out of memory, dynamic allocation may help.
Type
\begin{verbatim}
  cd src
  make DYNAMIC
\end{verbatim}
to have all the large variables to be allocated at run time.
This is achieved by the share/Scripts/StaticToDynamic.pl perl
script, which converts the static array declarations in the
{\tt src/Mod*\_static.f90} files into
allocatable declarations and creates the allocate and deallocate
statements in the output files (withouth the {\tt \_static} in their
names. You can also make some modules static and others dynamic, for example
\begin{verbatim}
  cd src
  make DYNAMIC1 NAME=CT
  make STATIC1 NAME=Advance
\end{verbatim}

\subsection{Compilation}

{\bf IMPORTANT NOTE:
On the Altix machine at NASA Ames (columbia),
the current (08/12/2004) 
default version of the Intel Fortran compiler 
cannot be used for \BATSRUS. 
You should load the 8.0.066 version with the command
\begin{verbatim}
  module load intel-comp.8.0.066
\end{verbatim}
You may wish to insert this line into the .cshrc file
so it executes at login time. 
Selecting the correct compiler version is 
necessary both to compile and to run the code.
Therefore the above line is needed in the job scripts
as well.}

To compile the main code type
\begin{verbatim}
  make
\end{verbatim}
in the main directory. This will produce the executable 
{\tt src/BATSRUS.exe}. For post-processing IDL and/or 
Tecplot spherical output data 
you need to compile the corresponding executables {\tt src/PostIDL.exe}
and/or {\tt src/PostSPH.exe} using
\begin{verbatim}
  make PIDL
  make PSPH
\end{verbatim}

\subsection{Running the code}

The next step is to create a run directory with appropriate links
\begin{verbatim}
  make rundir
\end{verbatim}
You can specify which post-processing and job scripts should be
included with the PLOT and MACHINE environment variables, e.g.
\begin{verbatim}
  make rundir PLOT=IDL MACHINE=grendel
\end{verbatim}
will only copy and link the IDL postprocessing codes and scripts,
and it will copy the job scripts containing the name 'grendel'.
Before running the code you need to create/edit the input
parameter file
\begin{verbatim}
  emacs run/PARAM.in
\end{verbatim}
The files in the Param directory can be used as examples or included
with the {\tt \#INCLUDE} command.
Especially useful is the Param/FULL file which contains
all the possible commands and descriptions.
See \ref{section:param} for details.

Now you are ready to run the code. For an interactive run
on 8 processors type
\begin{verbatim}
  make mpirun
\end{verbatim}
which is equivalent with
\begin{verbatim}
  make
  cd run
  mpirun -np 8 BATSRUS.exe
\end{verbatim}
To run on a different number of processors either change the number
after the {\tt -np flag} or use
\begin{verbatim}
  make mpirun NP=2
\end{verbatim}
On some systems the command to run MPI jobs is called {\tt mprun}
instead of {\tt mpirun}. Then use, for example
\begin{verbatim}
  make mprun NP=16
\end{verbatim}
On some platforms it is allowed to execute BATSRUS.exe on a single node 
without the {\tt mpirun} or {\tt mprun} commands:
\begin{verbatim}
  make nompirun
\end{verbatim}
On many machines you have to submit the run to a batch queue.
First edit the appropriate job script file and then submit the job,
for example
\begin{verbatim}
  cd run
  emacs job.columbia 
  qsub job.columbia
\end{verbatim}
The format the job scripts and submission commands depend on
the queuing system. Some of these will be described in 
section \ref{section:platforms}.

\subsection{Postprocssing}

After the code has successfully run, the output files 
found in {\tt run/IO2} need some post processing before 
they can be visualized. 

In stand alone mode the raw IDL plot files {\tt run/IO2/*.idl}
can be processed with
\begin{verbatim}
  make pIDL
\end{verbatim}
which is equivalent with
\begin{verbatim}
  cd run
  ./pIDL
\end{verbatim}
In the framework use
\begin{verbatim}
  cd run/GM
  ./pIDL
\end{verbatim}
or another appropriate subdirectory (run/SC or run/IH).

This command will produce the new {\tt run/IO2/*.out}
files, and delete the {\tt run/IO2/*.idl} files
and the corresponding header files {\tt run/IO2/*.h}.
In case you want to keep the raw data, e.g. to be safe, type
\begin{verbatim}
  pIDL IO2/ KEEP
\end{verbatim}
For complete usage information type {\tt pIDL -h}.

The raw Tecplot files {\tt IO2/*.dat} can be processed
into the {\tt IO2/*.dat} or {\tt IO2/*.plt} files
with the commands
\begin{verbatim}
  pTEC p r
\end{verbatim}
where 'p' means the file will be processed with preplot for ready input
in Tecplot, and 'r' refers to the removal of the raw data and header
files.  For complete usage information type {\tt pTEC -h}.

Visualization of the resulting output files with IDL and TecPlot
will be described in detail in sections \ref{section:idl_visualization}
and \ref{section:tecplot_visualization}, respectively.

\subsection{Recompilation and clean up}

If you change some source files, e.g. the number of blocks
in {\tt src/ModSize.f90} the code can be simply recompiled
with the {\tt make} command. However, if the compiler flags or the
precision are changed in {\tt src/Makefile}, you need to clean the
object files with
\begin{verbatim}
  make clean
\end{verbatim}
before recompilation. This will remove all the object files.

To delete all files created during installation and compilation, use
\begin{verbatim}
  make distclean
\end{verbatim}
In addition to the object files and the MPI header file, 
this command will remove the executables {\tt src/*.exe}, 
the libraries {\tt src*/*.a}, the source files
{\tt src/ModSize.f90} and {\tt src/user\_routines.f90}, 
and the Makefiles {\tt src/Makefile} and {\tt src/Makefile.OPTIONS}.

For a complete list of possible make targets type
\begin{verbatim}
  make help
\end{verbatim}
