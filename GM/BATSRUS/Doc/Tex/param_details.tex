%^CFG COPYRIGHT UM
\section{Detailed Parameter Input Options \label{section:param_details}}

This section is designed to explain the functionality of the majority of
input parameters for \BATSRUS.  The user is referred also to the {\tt Param/FULL}
file which gives the exact format in which \BATSRUS\ reads the input and lists 
all the currently allowable commands. This section will follow {\tt FULL}
closely, but that file should be referred to in order to determine the
exact format in which a command should be written.

In this section we group the commands according to functionality.  As noted
above (section~\ref{section:defaults}),
 many of the commands have defaults.  We will try to indicate when a command
does not need to be entered and when a command is required to be entered.
In addition, we include some details on the physics and code details where
appropriate.  We also indicate if this is a command that can only be read in
the first session.  Where not indicated, the command can be read in any session.

Each command listed in this section will have the following format

\begin{alltt}
#COMMAND      \hfill {\bf Text Indicating Use}
typical_value          variable_name or Description from FULL
typical_value          variable_name or Description from FULL
typical_value          variable_name or Description from FULL
typical_value          variable_name or Description from FULL
typical_value          variable_name or Description from FULL
\end{alltt}

Text which describes how the command is used...
\ \ \\
 
For each command the ``{\bf Text Indicating Use}'' can have several values.
The text can indicate that this command can only be used in the first
session ({\bf Session 1 Only}),
that the command must always be included in the {\tt PARAM.in} file ({\bf Required}),
that the command should be included if another related command is included, 
 that there is no restriction to
this commands use, or assorted other comments.
The lines 
\begin{verbatim}
typical_value          variable_name or Description from FULL
\end{verbatim}
show the format of the parameters which are read.  These will not always be
given.  When not given this does not imply that no parameters are required.
The user is referred also to the {\tt Param/FULL}
file which gives the exact format in which \BATSRUS\ reads the input.
The lines will be included when we need to refer to them.

{\bf In general, the order of commands in PARAM.in, in any given session,
 is arbitrary except where noted below and in section~\ref{section:order}.  
However, the order of individual lines within each command is very specific.
See below and {\tt FULL} for details}.


%======================================================================

\subsection{Geometry and Problem Type \label{section:geometry}} 

\begin{alltt}
#PROBLEMTYPE      \hfill {\bf Session 1 Only} -- {\bf Required}
\end{alltt}

The problemtype variable sets up the entire MHD simulation.  This
variable must be one of the first variables set in the {\tt PARAM.in}
file, since a large number of the following commands depend on the value.
The only commands that would normally proceed it would be the testing
commands, because, for example, they control echo-ing back of the 
input parameters and should therefore be the first entry in the file.
Possible values for problemtype are:
\begin{tabular}{rl}
{\bf 1} & MHD Uniform Flow\\
{\bf 2} &  Shock tube\\
{\bf 3} & Solar Wind and Inner Heliosphere\\
{\bf 4} & Empty\\
{\bf 5} & Mass-Loaded Comet\\
{\bf 6} & Rotation test \\
{\bf 7} & Diffusion test \\
{\bf 11} & Earth's Magnetosphere\\
{\bf 12} & Saturn's Magnetosphere\\
{\bf 13} & Jupiter's Magnetosphere \\
{\bf 14} & Venus's Ionosphere \\
{\bf 21} & Conducting Cylinder\\
{\bf 22} & Conducting Sphere\\
\end{tabular}

The user can add additional problem types if necessary.  See the chapter on
modifying the source code (chapter~\ref{chapter:source_code})
for information on how to do this.
\ \ \\

\begin{alltt}
#GRID        \hfill {\bf Session 1 Only} -- {\bf Required}
2                      proc\_dims(1)
1                      proc\_dims(2)
1                      proc\_dims(3)
-224.                  x1 
 32.                   x2 
-64.                   y1 
 64.                   y2 
-64.                   z1 
 64.                   z2 
\end{alltt}

The grid command sets up the domain. 
Details about this command and how it determines the simulation domain,
and the cells sizes is given in section~\ref{section:proc_dims}.
\ \ \\

%======================================================================

\subsection{Testing \label{section:testing}} 

\begin{alltt}
#TEST  \hfill {\bf Typically First Item}
read_inputs            Test String
\end{alltt}

This should always be the first command in {\tt Param.in} if it
is used.  The functionality of this string is the reason.  The
line following the command is a string, parsed by spaces.  Commonly,
putting the name of a subroutine in this line will cause output
to be written from inside that subroutine that is useful in debugging.
The subroutine {\tt read\_inputs} is special because it will echo
back the entire {\tt PARAM.in} file and all its included files 
in the same format as {\tt PARAM.in}.  This is useful in making
sure the run did what you thought it did and also can be used later
to redo the run.  {\tt \#TEST} works in conjunction with other 
test parameters.
\ \ \\

\begin{alltt}
#TESTIJK \hfill {\bf No Restriction}
\end{alltt}

Allows the user to select the processor number, block number, and index
of a single cell for which to write output.  Output may be written from
routines flagged in the {\tt \#TEST} string.
\ \ \\

\begin{alltt}
#TESTYXZ \hfill {\bf No Restriction}
\end{alltt}

Allows the user to select the X, Y and Z position
of a single cell for which to write output.  Output may be written from
routines flagged in the {\tt \#TEST} string.
\ \ \\

\begin{alltt}
#TESTTIME  \hfill {\bf No Restriction}
\end{alltt}

Allows the user to control when testing will begin, either in numbers
of iterations, or in number of simulated seconds for time accurate runs.
\ \ \\

\begin{alltt}
#TESTVAR  \hfill {\bf No Restriction}
\end{alltt}

Allows the user to control which variable will be written out for testing.
\ \ \\

\begin{alltt}
#TESTDIM  \hfill {\bf No Restriction}
\end{alltt}

Allows the user to control the principle direction ($x$,$y$ or $z$) for
which test information is written out.
\ \ \\

\begin{alltt}
#DEBUG \hfill {\bf No Restriction}
\end{alltt}

Excessive debug output can be controlled by the using the global okdebug 
parameter.  See {\tt FULL} and pieces of code to see the functionality.
\ \ \\

\begin{alltt}
#SPEEDFILES \hfill {\bf No Restriction}
\end{alltt}

Controls the writing of speed files.  These have been used mostly on the
Cray to do timing tests.  The default is to not write these files.
\ \ \\


%======================================================================

\subsection{Session Control \label{session_control}} 

\begin{alltt}
#INCLUDE \hfill {\bf No Restriction}
\end{alltt}

This command allows the user to include other files into the {\tt PARAM.in}.
See the detailed description in section~\ref{section:include}.
\ \ \\

\begin{alltt}
#RUN \hfill {\bf No Restriction}
\end{alltt}

This command tells \BATSRUS\ to start running with the parameters
that have been set above it.  When stopping criteria are met, \BATSRUS
will continue reading {\tt PARAM.in} to begin the next session.
\ \ \\


\begin{alltt}
#END \hfill {\bf Required}
\end{alltt}

This command tells \BATSRUS\ to start running with the parameters
that have been set above it.  When stopping criteria are met \BATSRUS
will stop.  When used at the end of an included file, {\tt \#END}
means only the end of the file, not the end of the entire run.
\ \ \\



\begin{alltt}
#STOP       \hfill {\bf Required}
100                    nITER Last/maximum iteration_number for this session.
10.                    t_max (in seconds) Only read if time_accurate is set!
\end{alltt}

The user must include this command in each session, because it indicates 
to \BATSRUS\ how many iterations to take.  In the usual functionality, 
the {\tt nITER} is always read while {\tt t\_max} is read only in time accurate
mode.  As usual, {\tt t\_max} is in simulated seconds.  In time accurate mode, 
which ever criteria is met first will stop the session.  If {\tt nITER} is set
negative, only the {\tt t\_max} criteria is used.

Note that {\tt nITER} is cumulative from session to session within a given run
but when restarting it does not include iterations from the restart file.
{\tt t\_max}, however, is always cumulative, even when restarting.  This is
because, time accurate run usually have associated with them a ``real world''.
See section~\ref{section:frequency}.
\ \ \\

\begin{alltt}
#CPUTIMEMAX \hfill {\bf No Restriction}
\end{alltt}

If this variable is set to some positive value, the code 
stops running after the amount of time
specified in seconds.  
Restart files and plot files are written out like at the end of a normal
run.  This command is extremely useful for batch jobs with run time limits.
The normal usage is to specify a time with is
a few minutes shorter than the maximum allowable run time, so the code
has a few minutes to write the restart and plot files.
\ \ \\



\begin{alltt}
#CHECKSTOPFILE \hfill {\bf No Restriction}
\end{alltt}

If this logical variable is set {\tt .true.} the code will check each
time step for the file {\tt BATSRUS.STOP} in the run directory.  If the
file is found the code will write restart and plot files (if they are
flagged for writing by their appropriate commands) and then will quit.
This command was originally created so that if the
power went off on the Beowulf, the shutdown script could create a file
which would indicate to the running code that it needs to write a
restart file and stop.  It can also be
used to stop any simulation at any given time without having to kill the 
individual processes and possibly lose everything.  To stop the code, 
simply type {\tt touch BATSRUS.STOP} to create the file. {\bf Remember to
remove the file after the code has stopped!}
\ \ \\

%======================================================================

\subsection{Boundary Conditions \label{section:BC}}

\begin{alltt}
#OUTERBOUNDARY \hfill {\bf No Restriction}
outflow                outerBCtype(east_)  (Minimum X - Anti-Sunward) 
inflow                 outerBCtype(west_)  (Maximum X - Sunward) 
float                  outerBCtype(south_) (Minimum Y - GSM)
float                  outerBCtype(north_) (Maximum Y - GSM)
float                  outerBCtype(bot_)   (Minimum Z - GSM)
float                  outerBCtype(top_)   (Maximum Z - GSM)
\end{alltt}

Default for this command is set by problem type. The possible values are:

\begin{itemize}
\setlength{\itemsep}{0.0 in}
\item float - zero gradient
\item fixed - fixed solarwind values
\item fixedB1 - fixed solarwind values without correction for the B0 field
\item inflow - same as fixed
\item outflow - zero extrapolation but reduce rho and P by 0.01 (east\_ only)
\item vary - time dependent BC
\end{itemize}

For a time accurate run with a time dependent boundary condition,
a specific combination of BC's is required.  {\tt west\_}
should be set to vary; {\tt north\_}, {\tt south\_}, {\tt bot\_} and {\tt top\_}
should be set to float; and {\tt east\_} should be set to {\tt outflow}. 
In addition, {\tt PARAM.in} must set the {\tt \#UPSTREAM\_INPUT\_FILE} 
command and its parameters.
\ \ \\


\begin{alltt}
#UPSTREAM_INPUT_FILE  \hfill {\bf No Restriction}
T                      UseUpstreamInputFile
IMF.dat                UpstreamFileName
0.0                    Satellite_Y_Pos
0.0                    Satellite_Z_Pos
\end{alltt}

This command controls the input and use of solar wind data.  The data is
used at the inflow boundary, and the  user can input the file from which
to read the data ({\tt UpstreamFileName}).  This file is read, but 
ignored if the time stepping mode is not time accurate.
The satellite position variables are currently ignored.  An example of part
of a data file follows:
\begin{verbatim}
notes....
yyyy mm dd hh mm ss  ms    bx    by    bz      ux    uy    uz    n         T

#START
2000 03 21 10 45 00  00  0.00  0.00  5.00  -500.0   0.0   0.0  5.0  100000.0
2000 03 21 10 46 00  00  0.00  0.00  2.50  -500.0   0.0   0.0  5.0  100000.0
2000 03 21 10 47 00  00  0.00  0.00  0.00  -500.0   0.0   0.0  5.0  100000.0
\end{verbatim}
Data in this file must start with the {\tt \#START} line.  Anything before
this line in the file is ignored on reading.  The data is given in the order shown with
fields seperated by spaces.  The time in 
year (yy), month (mm), day (dd), hour (hh), minute (mm), second (ss), 
and millisecond (ms) comes first.  Each of these fields is an integer.
This is followed by the MHD variables, B$_x$, B$_y$, B$_z$ in nT; U$_x$, U$_y$, U$_z$
in km/s; the density in \#/cm$^3$ and the Temperature in Kelvin which are reals.  
\BATSRUS\ uses linear interpolation when it needs a values between data points.
For times before the specified start time in the file the first entry is used.
Similarly, the last entry is used for all times after the end time.
\ \ \\


\begin{alltt}
#INNERBOUNDARY \hfill {\bf No Restriction}
ionosphere             innerBCtype 
\end{alltt}

Default is ionosphere for  Earth, Saturn, Jupiter.  Other problem types are 
either not affected by innerBCtype. or the user should look in {\tt read\_inputs.f90}
to determine the defaults.  When UseIonosphere=.true., 
velocity at the boundary is determined by the ionosphere model.

Possible values for innerBCtype are

\begin{itemize}
\setlength{\itemsep}{0.0 in}
\item reflect - reflect Vr, reflect Vphi to rotation, float Vtheta,
reflect Br, float Bphi, float Btheta, float rho, float P
\item float - float Vr, reflect Vphi to rotation, float Vtheta, float B, float rho, float P
\item fixed - Vr=0, Vphi=rotation, Vtheta=0, B=0, fix rho, fix P
\item ionosphere - set V as if ionosphere gave V\_iono=0, Br=0, float Bphi, float Btheta, fix rho, fix P
\item ionosphereB0 -set V as if ionosphere gave V\_iono=0,Br=0, Bphi=0, Btheta0, fix rho, fix P
\item tanaka - Vr$>$0: float Vr, reflect Vphi to rotation, float Vtheta, Br=0., float Btheta, float Bphi, fix rho, fix P, Vr$<$0: reflect Vr, reflect Vphi to rotation, float Vtheta, Br=0., float Btheta, float Bphi, float rho, float P
\item massloading - reflect Vr, Vphi=rotation, Vtheta=0, Br=0, float Bphi, float Btheta, fixed profiles for rho and P
\item special - for experiments use this!!!
\end{itemize}

%======================================================================

\subsection{Grid Refinement \label{section:grid_refinement}}

\begin{alltt}
#AMRINIT           \hfill {\bf Session 1 Only}
default                InitialRefineType
4                      initial_refinement_levels
\end{alltt}

The default values {\tt InitialRefineType} are problem type dependent.
The possible values can be found in {\tt FULL}.  The parameter
{\tt initial\_refinement\_levels} indicates the number of levels of 
refinement which will be conducted at startup.  This command can only
be used in the first session of a run.
Note that {\tt InitialRefineType}
controls refinement that it ``prespecified'',
meaning geometry based refinement that usually happens at startup.
In {\tt \#AMR}, below, it is possible to do a geometry based refinement,
as would have been done at startup at the AMR frequency.  In other
words, let us assume that at startup you normally refined down 4 levels.
If instead you refined down only 1 level at startup, but set {\tt \#AMR} below
correctly, the next 3 AMR's would take you down 3 more levels and would
give you the same grid that you would have had with the normal startup.

It is possible that the user might want to do this ``prespecified'' refinement
after a restart.  In this case, the {\tt \#AMRINIT} command will 
need to be given in the first session to set the {\tt InitialRefineType}.
However, because this is a restart, there will be no initial refinement and
the {\tt initial\_refinement\_levels} variable will be unused.

Note when doing initial refinement at startup, \BATSRUS\ does not prevent
you from refining past the allowed number of blocks.  If you do so the run
will crash.  This is a feature, not a bug.
\ \ \\

\begin{alltt}
#AMR \hfill {\bf No Restriction}
2001                   dn_refine (frequency in terms of total steps n_step)
T                      automatic_refinement 
0.                     percentCoarsen
0.                     percentRefine
99999                  maxTotalBlocks
\end{alltt}

This command controls all refinement of the grid after the initial refinement.
There are a few specific details of this command that can be quite complicated.
Normally the command is used with {\tt dn\_refine} set to some positive
value and {\tt automatic\_refinement} set {\tt .true.}.  In this case the 
refinement based on physical refinement criteria happens at the given 
frequency (see section~\ref{section:frequency} for details).  The
percent variables allow the user to
indicate the percentage of the current number of block to either increase
or decrease the number of blocks by when refining (note that 25.0
indicate 25 \% change).  The parameter {\tt maxTotalBlocks}
lets the user place an upper limit on the number of blocks when doing refinement.
If this number is larger than the number of blocks allowed per processor ({\tt nBLK})
then {\tt maxTotalBlocks} is reset to {\tt nBLK}.  Note that if the {\tt dn\_refine}
parameter is set negative there will be no refinement, and the rest of the parameters
are not read.

The other way to use {\tt \#AMR} is to do a ``prespecified'' refinement which was
alluded to in the {\tt \#AMRINIT} command.  For ``prespecified refinement 
 {\tt dn\_refine} is set positive but
{\tt automatic\_refinement} is set {\tt .false.}. Refinement will still occur at the
given frequency.  Instead of using the physics based refinement criteria, the
refinement will be the equivalent of what an initial refinement would do. See {\tt \#AMRINIT}
for an example.  Note that when doing ``prespecified'' refinement, the percentage
parameter and the {\tt maxTotalBlocks} as well as the  {\tt initial\_refinement\_levels}
parameter from {\tt \#AMRINIT} are not used and the code can refine until all blocks
are used and beyond.  This will cause the code to crash.
 \ \ \\


\begin{alltt}
#AMRLEVELS          \hfill {\bf Strongly Suggested for Automatic AMR}
0                      min_block_level
99                     max_block_level
F                      fix_body_level
\end{alltt}

This command sets the minimum and maximum refinement levels for 
automatic refinement (AMR).  A value of -1 sets {\tt XXX\_block\_level} to
the current level.  This allows the grid to be frozen in as the minimum 
refinement allowed or as the maximum refinement allowed or both.
When {\tt fix\_body\_level = .true.} AMR is not allowed to coarsen or 
refine any block which intersects the body.  These parameters are unused
when automatic refinement is {\tt .false.}, however, when it is {\tt .true.}
either {\tt \#AMRLEVELS} or {\tt \#AMRRESOLUTION} {\bf MUST BE SET}
or there will be no restriction on the number of levels for refinement.
This command is ignored for ``prespecified'' refinement.
\ \ \\


\begin{alltt}
#AMRRESOLUTION     \hfill {\bf Strongly Suggested for Automatic AMR}
0.                     min_cell_dx
99999.                 max_cell_dx
F                      fix_body_level
\end{alltt}

This command sets the minimum and maximum refinement cell sizes for 
automatic refinement (AMR).  These are converted to {\tt min\_block\_level}
and {\tt max\_block\_level}.
When {\tt fix\_body\_level = .true.} AMR is not allowed to coarsen or 
refine any block which intersects the body.  These parameters are unused
when automatic refinement is {\tt .false.}, however, when it is {\tt .true.}
either {\tt \#AMRLEVELS} or {\tt \#AMRRESOLUTION} {\bf MUST BE SET}
or there will be no restriction on the number of levels for refinement.
This command is ignored for ``prespecified'' refinement.
\ \ \\

\begin{alltt}
#AMRCRITERIA      \hfill {\bf Strongly Suggested for Automatic AMR}
3                      RefineCrit (number of refinement criteria: 1,2 or 3)
gradlogP               RefineCrit(1)
divB                   RefineCrit(2)
curlB                  RefineCrit(3)
\end{alltt}

This option allows the user to specify the physical criteria 
that are used in deciding which cells to refine or coarsen.  Each 
of the refinement criteria is weighted equally in the following sense.
All blocks are sorted three times, once for each 
refinement criteria.  When refining, the code looks at 
refinement criteria 1 and flags the first block for refinement,
it then  goes to criteria 2 and flags the first block, etc.
It iterates across  the criteria and down the lists until enough blocks
have been flagged for refinement.  Because
some blocks may be on each list, the true weighting will be somewhat 
different.

Default values for {\tt \#AMRCRITERIA} are based on the problem
type.  A list of the possible criteria are listed here:
\begin{tabbing}
gradT \hspace{1.0in} \= gradient of temperature \\
gradP           \> gradient of pressure \\
gradlogrho	\> gradient of log(rho) \\
gradlogP	\> gradient of log(P) \\
gradE		\> gradient of electric field magnitude \\
curlV,curlU 	\> magnitude of curl of velocity \\
curlB		\> magnitude of current  (magnetopause, tail current sheet)\\
divU, divV	\> divergence of velocity \\
divB		\> div B \\
vAlfven,Valfven	\> Alfven speed \\
heliobeta       \> special function for heliosphere $R^2B^2/\rho$ ?? \\
flux		\> radial mass flux \\
heliocurrentsheet \> refinement in the currentsheet of the heliosphere \\
Rcurrents	\>refinement near Rcurrents value (mapping to the ionosphere)
\end{tabbing}
All the names can also be spelled with all lower case letters.
\ \ \\

\begin{alltt}
#LOADBALANCE    \hfill {\bf No Restriction}
0 32 64 8 8 8 0        balance_string 
\end{alltt}

The {\tt balance\_string} contains a space seperated list of integers that
indicate the number of blocks out of load balance the code is allowed
to get at each refinement level.  Allowing the code to get out of
balance lets more contiguous blocks be grouped together on a processor.
This reduces many of the message passes to copies and greatly speeds the code
on message-passing-dominate systems like a Beowulf.  A value of -1
has the code calculate a rough estimate of what is optimal.  In most
cases the values set by default in {\tt read\_inputs.f90} are good enough and
the user should not need to change them.  
\ \ \\


%======================================================================

\subsection{Plots and Logfiles \label{section:plot_logfiles}}

\begin{alltt}
#PROGRESS  \hfill {\bf No Restriction}
\end{alltt}

This command lets the user control the frequency of periodic progress
reports to stdout.
\ \ \\

\begin{alltt}
#SAVELOGFILE  \hfill {\bf No Restriction}
T                      save_logfile Rest of parameters read if true
VAR  step date         log_string
100                    dn_output(logfile_)
-1.                    dt_output(logfile_) in sec. Read only if time accurate!
rho p rhoflx pntflx    log_vars (variable to write) Read when variable form.
4.0  10.0              R_log  Read only when log_vars includes flx.
\end{alltt}

By default, {\tt save\_logfile} is false.  When it is true the logfile is written 
to the file {\tt log\_nXXXXXX.log} in the {\tt IO2} directory, where {\tt XXXXXX}
is the time step for which the logfile is first written. 

This command controls the frequency and the information that is written
to the log file.  If {\tt save\_logfile} is {\tt .true.} then additional
lines are read.  In a way similar to {\tt \#SAVEPLOTS}, the user
can specify a set of variables to write out as well as a frequency.
As with other frequencies, in time accurate mode the frequency can either
be in time steps or in simulation time in seconds.  The choice  of which
number to use follows the standard timing interpretation.

The first line read after the {\tt save\_logfile} flag, is a string, {\tt log\_string}
which can contain several strings seperated by spaces.  Although order is
arbitrary, the usual format is {\tt  logvar log\_time}.  
As an example,  the second line above reads: {\tt VAR step date}, where {\tt VAR}
is the {\tt logvar} and {\tt step date} is the {\tt log\_time}.

The {\tt logvar} string {\bf is not optional}, but the {\tt log\_time} 
strings are optional.
When not specified, {\tt log\_time} is set to a reasonable value as indicated below.

The {\tt logvar} string defines the variables to print in the log file.
It also controls whether or not the variables will come out in
dimensional or non-dimensional form.  {\bf If the string is in all capitals,
the output is dimensioned according to the user's definitions in 
{\tt set\_physics.f90},
all lower case indicates dimensionless, or normalized, output}. 
The {\tt logvar} string can have several different values, most of
which assign a predefined list of output variables. The options are
\begin{tabbing}
{\tt logvar}     \hspace{1.25in} \=  Assigned Variables \\
-------------------- \> -------------------------------------------------------------------- \\

MHD,mhd \> rho, rhoUx, rhoUy, rhoUz, Bx, By, Bz, E, PMin, Pmax \\
        \> {\tt log\_time}: step date time \\
raw     \> dt, rho, rhoUx, rhoUy, rhoUz, Bx, By, Bz, E, PMin, Pmax \\
        \> {\tt log\_time}: step time \\
FLX, flx \> rhoflx Bflx B2flx pntflx \\
        \> {\tt log\_time}: step date time \\
VAR,var \> READ FROM PARAMETER FILE \\
        \> {\tt log\_time}: step time
\end{tabbing}

When {\tt logvar} is set to {\tt var} or {\tt VAR} the user can include a list of
variables to output.
The following is the currently implemented list of
variable names and their meanings.
\begin{tabbing}
Symbols \hspace{2.75in} \= Variable Details \\
--------------------------------------------------- \> 
-------------------------------------------------------------------- \\
dt          \> Global time step.  Value is 0.0 for local time stepping. \\
rho, rhoUx, rhoUy, rhoUz, Bx, By, Bz, P, E \> Value is the average over the entire grid \\
rhopnt rhoUxpnt rhoUypnt rhoUxpnt Uxpnt Uypnt Uzpnt  \> 
                                               Density and velocity at the test point \\
Bxpnt Bypnt Bzpnt B1xpnt B1ypnt B1zpnt \> Magnetic field at the test point \\
Epnt Ppnt Jxpnt Jypnt Jzpnt   \> Current density at the test point \\
theta1pnt theta2pnt phi1pnt phi2pnt statuspnt \> Ray tracing quantities at the test point \\
Pmin, Pmax  \> The minimum or maximum value anywhere on \\ 
               \> \hspace{.25in} the entire grid \\
rhoflx, Bflx, B2flx, pntflx \> Fluxes of $\rho$, B, B$^2$ and the Poynting vector  
                            through \\ \> \hspace{.25in} 
                            a sphere of radius given by {\tt R\_log}. \\
cpcpn, cpcps   \> Ionospheric cross polar cap potential in the northern \\
               \> \hspace{.25in} and southern hemispheres
\end{tabbing}
Note that the variable names work as indicated and also as all lower case.
Variables listed should be separated by spaces, {\bf not by commas or any other
character}.  Since the list is read as a string, the comment should be separated
from the list by a tab character or 3 or more spaces.

Logfile output for variables that end with ``pnt'' is determined by the test
commands {\tt \#TESTIJK} or {\tt \#TESTXYZ}.  These define a test point either
in terms of a set of indicies or a location on the grid.  When the test point is
defined, the ``pnt'' variables indicate that values at the test point should
be written to the logfile.  When using {\tt \#TESTXYZ} the location of the
test point also written to the logfile since it is not at the user input X,Y,Z
but at the nearest cell center to these and this location can change during AMR.

When any of the variables is a {\tt flx} variable, the command reads a list of 
radii at which to calculate the flux.  {\tt R\_log} can be a list of radii.  Again,
this list is read as a string and so comments should be seperated by at least 3
spaces or a tab. 

The {\tt log\_time} strings determine the output format of time in the logfile.
The allowed values and associated output format is as follows:
\begin{tabbing}
{\tt log\_time}     \hspace{.5in} \=  Output Format \\
------------ \> ------------------------------------------------------------------------------------------------------ \\
none  \> There will be no indication of time in the logfile (not even a 
               number of steps) \\
step  \> The number of time steps (n\_steps) is output as the first column \\
date  \> Time \=is given as an array of 7 integers:  year mo dy hr mn sc msc.  This option \\
      \>      \>work in conjunction with the {\tt \#SETREALTIME} command. \\
time  \> Time is given as a real number representing the  elapsed time since the start of \\
      \>      \>  the run.  The time units are determined by log\_var and unitUSER\_t
\end{tabbing}
The  {\tt log\_time} strings can be used in arbitrary order and can be combined in
any fashion to give the desired combination of time formats in the output file.


\begin{alltt}
#SATELLITE
2                      nsatellite
MHD file step date     satellite_string (variables, traj type, sat_time)
100                    dn_output(satellite_)
-1.                    dt_output(satellite_) in sec. ALWAYS READ!
satellite1.dat         Filename or satellite name (Satellite_name(satellite_))
VAR eqn                satellite_string  (variables, traj type, sat_time)
100                    dn_output(satellite_)
-1.                    dt_output(satellite_) in sec. ALWAYS READ!
satellite2.dat         Filename or satellite name (Satellite_name(satellite_))
rho p                  satellite_vars (variable to write) Read when 'var' used above.
\end{alltt}

If {\tt nsatelllite} is not 0 then additional
lines are read.  A number of groups of input parameters will be read equal
to the value of {\tt nplotfile}.  
Satellite trajectories are either read in from files or are calculated from
equations.  The position of the satellite and the values of the MHD quantities
interpolated to these positions is written to output files.  Output files are 
written in the {\tt IO2} directory and are of
the form {\tt satellite\_NN\_satellitename.sat} where {\tt NN} is the 
number of the satellite and {\tt satellitename} is either the filename
from which the trajectory is read or the name indicating which equation to
use.  

The first line read for each satellite is a string, {\tt satellite\_string}
which can contain three groups of strings seperated by spaces.  Although order is
arbitrary, the usual format is {\tt  satellitevar trajectory\_type sat\_time}.  
As an example,  the second line above reads: {\tt MHD file step date}, where {\tt MHD}
is the {\tt satellitevar}, {\tt file} is the {\tt trajectory\_type} and 
{\tt step date} is the {\tt sat\_time}.

The {\tt satellitevar} string {\bf is not optional}, but the {\tt trajectory\_type}
and {\tt sat\_time} are optional. The {\tt trajectory\_type} is {\tt file} by default.
When not specified, {\tt sat\_time} is set to a reasonable value as indicated below.

The {\tt satellitevar} string defines the variables to write to the satellite output files.
It also controls whether or not the variables will be written in
dimensional or non-dimensional form.  {\bf If the string is in all capitals,
the output is dimensioned according to the user's definitions in 
{\tt set\_physics.f90},
all lower case indicates dimensionless, or normalized, output}. 
The {\tt satellitevar} string can have several different values, most of
which assign a predefined list of output variables. The options are
\begin{tabbing}
{\tt satellitevar}     \hspace{1.25in} \=  Assigned Variables \\
-------------------- \> -------------------------------------------------------------------- \\

MHD,mhd \> rho, Ux, Uy, Uz, Bx, By, Bz, P, Jx, Jy, Jz \\
FUL, ful \> rho, Ux, Uy, Uz, Bx, By, Bz, P, Jx, Jy, Jz, 
             theta1, phi1, theta2, phi2, status \\
VAR,var \> READ FROM PARAMETER FILE
\end{tabbing}

When {\tt satellitevar} is set to {\tt var} the user can include a list of
variables to output.  The following is the currently implemented list of
variable names and their meanings.
\begin{tabbing}
{\tt plotvar}\\
Physical Quantity                    \hspace{2.0in} \= Symbols \\
--------------------------------------------  \>
 ------------------------------------------- \\
Density, Pressure, Energy, Velocity   \> rho, P, E, Ux, Uy, Uz        \\
Momentum                              \> rhoUx, mx, rhoUy, my, rhoUz, mz \\
Total and Deviative Magnetic Field    \> Bx, By, Bx, B1x, B1y, B1z   \\
Current                               \> Jx, Jy, Jz \\
Ray Tracing Variables                 \> theta1, phi1, theta2, phi2, status \\
\end{tabbing}

Note that the variable names work as indicated and also as all lower case.
Variables listed should be separated by spaces, {\bf not by commas or any other
character}.  Since the list is read as a string, the comment should be separated
from the list by a tab character or 3 or more spaces.


The {\tt sat\_time} strings determine the output format of time in the satellite files.
The allowed values and associated output format is as follows:
\begin{tabbing}
{\tt log\_time}     \hspace{.5in} \=  Output Format \\
------------ \> ------------------------------------------------------------------------------------------------------ \\
none  \> There will be no indication of time in the logfile (not even a 
               number of steps) \\
step  \> The number of time steps (n\_steps) is output as the first column \\
date  \> Time \=is given as an array of 7 integers:  year mo dy hr mn sc msc.  This option \\
      \>      \>work in conjunction with the {\tt \#SETREALTIME} command. \\
time  \> Time is given as a real number representing the  elapsed time since the start of \\
      \>      \>  the run.  The time units are determined by log\_var and unitUSER\_t
\end{tabbing}
The  {\tt log\_time} strings can be used in arbitrary order and can be combined in
any fashion to give the desired combination of time formats in the output file.

The {\tt  Filename or satellite name} field is a string that indicates where to
find the information about the satellite trajectory.  If the {\tt trajectory\_type} is
{\tt file} the string should contain the full path from the {\tt run} directory to
the trajectory file.  These files have the following format:
\begin{verbatim}
notes....
yyyy mm dd hh mm ss  ms    x    y    z   
					 
#START					 
2000 03 21 10 45 00  00  0.00  0.00  5.00
2000 03 21 10 46 00  00  0.00  0.00  2.50
2000 03 21 10 47 00  00  0.00  0.00  0.00
\end{verbatim}
Data in this file must start with the {\tt \#START} line.  Anything before
this line in the file is ignored on reading.  The data is given in the order shown with
fields seperated by spaces.  The time (integers) in 
year (yy), month (mm), day (dd), hour (hh), minute (mm), second (ss), 
and millisecond (ms) comes first followed by the satellite position (real numbers).

When the {\tt trajectory\_type} is {\tt eqn} then the {\tt  Filename or satellite name} field
should contain a string naming the satellite.  This string is used in the routine
{\tt satellite\_trajectory\_formula} in the file {\tt satellites.f90} to determine
which set of equations to use to get the trajectory.
\ \ \\


\begin{alltt}
#SAVEPLOT  \hfill {\bf No Restriction}
5                      nplotfile
3d MHD tec             plot_string
100                    dn_output(1)
-1.                    dt_output(1)  (in s) Read only if time_accurate
y=0 VAR idl            plot_string
-1                     dn_output(2)
100.                   dt_output(2)  (in s) Read only if time_accurate
2.                     plot_dx(1,2)  Read only for format 'idl'
jx jy jz               plot_vars(2)  Read only for content 'var'
g unitx unitv unitn    plot_pars(2)  Read only for content 'var'
cut ray idl            plot_string
1                      dn_output(3)
-1.                    dt_output(3)  (in s) Read only if time_accurate
-10.                   plot_range(x1,3) Read only for area 'cut'
10.                    plot_range(x2,3) Read only for area 'cut'
-10.                   plot_range(y1,3) Read only for area 'cut'
10.                    plot_range(y2,3) Read only for area 'cut'
-10.                   plot_range(z1,3) Read only for area 'cut'
10.                    plot_range(z2,3) Read only for area 'cut'
1.                     plot_dx(1,3)     Read only for format 'idl'
sph flx tec            plot_string
-1                     dn_output(4)
100.                   dt_output(4)  (in s) Read only if time_accurate
4.                     R_plot - R of spherical cut, Read only for area 'sph'
ion MAX idl            plot_string
-1                     dn_output(5)
100.                   dt_output(5)  (in s) Read only if time_accurate
\end{alltt}

{\tt \#SAVEPLOT} controls the types of plot files and the  frequency and 
the variables which are written.  
The parameter {\tt nplotfile} indicates the number of different kinds of plotting
output that the user wishes. By default this value is 0. 
If {\tt nplotfile} is not 0 then additional
lines are read.  A number of groups of input parameters will be read equal
to the value of {\tt nplotfile}.  

The first line read for each different plot is a string, {\tt plot\_string}
which must contain three strings of length three each (or less).  Although order is
arbitrary, the usual format is {\tt plotarea plotvar plotform}.  
An example above, is the second line which reads: {\tt 3d  MHD tec}.

The 
{\tt plotarea} string controls the spatial shape of the plot.  The allowed values
are
\begin{tabbing}
{\tt plotarea} String  \hspace{0.5in}  \= Description \\
-------------------------  \> --------------------------------------------------------------------------------------------------- \\
3d                    \> Plots the entire 3-D area of the computation region. \\
x=0                   \> Plots the x=0 plane \\
y=0                   \> Plots the y=0 plane \\
z=0                   \> Plots the z=0 plane \\
cut                   \> Plots data over a user specified range. \\
sph                   \> Plots the actual face centered values for faces that 
                          intersect a sphere of a specified  \\
                      \> \hspace{.25in} radius.  This option is still experimental. \\ 
ion                   \> Plots the ionosphere. Special case that does not have 
                          all the features of the other cases. \\
\end{tabbing}


In a way similar to {\tt \#SAVELOGFILE}, the user
can specify a set of variables to write.
The {\tt plotvar} string defines the variables to print and also
controls whether or not the variables will come out in
dimensional or non-dimensional form.  {\bf If the {\tt plotvar} is in all capitals,
the output is dimensioned according to the user's definitions in 
{\tt set\_physics.f90},
all lower case indicates dimensionless, or normalized, output}. 
The {\tt plotvar} string can have several different values, most of
which assign a predefined list of output variables. In addition
to the {\tt plotvar} parameter, there is also a {\tt plotpar}
parameter which allows the use to output into the plot header,
some values that may be needed to do physics later.  The options are
\begin{tabbing}
{\tt plotvar}     \hspace{1.0in} \=  Assigned Variables \\
-------------- \> ------------------------------------------------------------------------------------- \\
MHD,mhd       \> vars: \=rho, Ux, Uy, Uz, Bx, By, Bz, P, Jx, Jy, Jz \\
              \> pars: \>g, c \\
FUL,ful       \> vars: \>rho, Ux, Uy, Uz, Bx, By, Bz, B1x, B1y, B1z, P, Jx, Jy, Jz \\
              \> pars: \>g, c \\
RAW,raw       \> vars: \>rho, rhoUx, rhoUy, rhoUz, E, Bx, By, Bz, P,
           	      b1x, b1y, b1z, divb \\
              \> pars: \>g, c \\
RAY,ray       \> vars: \>Bx, By, Bz, theta1, phi1, theta2, phi2, status, blk \\
              \> pars: \>R\_ray \\
FLX,flx       \> vars: \>rho, rhoUr, rhoUtheta, rhoUphi, Br, Btheta, Bphi, P \\
              \> pars: \>g, c \\
MIN,min ('ion' only)       \> vars: \>Psi, SigmaH, SigmaP, Jr, Phi \\
              \> pars: unused \\
MAX,max ('ion' only)      \> vars: \>X, Y, Z, Theta, Psi, SigmaH, SigmaP, Jr, Ex, 
                      Ey, Ez, Jx, Jy, Jz, Ux, Uy, Uz \\
              \> pars: unused \\
VAR,var       \> vars: \>READ FROM PARAMETER FILE \\
              \> pars: \>READ FROM PARAMETER FILE
\end{tabbing}

When {\tt plotvar} is set to {\tt var} the user can include a list of
variables to output {\bf The exception is when plotarea is 'ion'.  For
this case, only plotvar MIN, min, Max and max work and output is always
dimensional}.  Plotvar
MIN, min, MAX only work for {\tt plotarea} 'ion'.  The following is 
the currently 
implemented list of variable names and their meanings that can be used
in the 'var' list.
\begin{tabbing}
{\tt plotvar}\\
Physical Quantity                    \hspace{2.0in} \= Symbols \\
--------------------------------------------  \>
 ------------------------------------------- \\
Density, Pressure, Energy, Velocity   \> rho, P, E, Ux, Uy, Uz        \\
Momentum                              \> rhoUx, mx, rhoUy, my, rhoUz, mz \\
Total and Deviative Magnetic Field    \> Bx, By, Bx, B1x, B1y, B1z   \\
Current                               \> Jx, Jy, Jz \\
Div B (different discretizations)     \> divB, divB\_CD, divB\_CT \\
Ray Tracing Variables                 \> theta1, phi1, theta2, phi2, status \\
Grid Variables                        \> PE, blk, child \\
Flux Variables ('sph' only)           \> rhoflx, Bflx, B2flx, pntflx \\
Spherical momentum and velocity ('sph' only)      \> rhoUr, rhoUtheta, rhoUphi,Ur, Utheta, Uphi \\
Spherical Magnetic Field ('sph' only)    \> Br, Btheta, Bphi, B1r, B1theta, B1phi
\end{tabbing}
\begin{tabbing}
{\tt plotpar}\\
Physical Quantity      \hspace{2.0in} \= Symbols \\
--------------------------------------------  \>
 ------------------------------------------- \\
$\gamma$ (specific heat ratio)        \> g   \\
Speed of light                        \> c   \\
$\eta$ (resistivity, always 0)        \> eta \\
Normalization factors                 \> unitx, unitn, unitv, unitu \\
Radius of Ray Trace Footprints        \> R\_ray 
\end{tabbing}
Note that the variable names work as indicated and also as all lower case.
Variables listed should be separated by single spaces, {\bf not by commas or any other
character}.  Since the list is read as an string, the comment should be seperated
from the list by a tab character or a minimum of three spaces.

The final entry in the {\tt plot\_string} is the {\tt plotform}
which indicates the output format.
The choices are to write output appropriate for IDL (idl) or Tecplot (tec).
There are two main difference between these outputs formats. IDL output is
cell centered while Tecplot format uses cell corners.  The
other difference is the header to the files.

The {\tt plotvar} option 'flx' is only valid for use with 
{\tt plotarea} set to 'sph'.  All variables in spherical 
coordinates and those containing 'flx' are valid for {\tt plotarea} 'sph' only.
Finally, {\tt plotarea} 'ion' does not have the same functionality as the other
{\tt plotarea} values.  With this case you cannot specify 'VAR' as the 
{\tt plotvar} and if using 'idl' as the plotform the user does not need to
input the typical idl values of {\tt plot\_range} and {\tt plot\_dx}.

After the {\tt plot\_string} is the plotting frequency.  These two lines
follow the typical output frequency formats.

Following this, further information is read depending on the values of 
{\tt plot\_string}.  The information is in the following order with lines
left out when they are not needed.
\begin{tabbing}
Parameter \hspace{0.5in} \= Conditions for Being Read \\
--------------              \>
--------------------------------------------------------------------- \\
plot\_range		 \> Read if {\tt plotarea} is 'cut'. \\
plot\_dx		         \> Read if {\tt plotform} is 'idl' and 
                            {\tt plotarea} is not 'sph'. \\
R\_plot		         \> Read if {\tt plotarea} is 'sph'. \\
plot\_vars		 \> Read if {\tt plotform} is 'var' or 'VAR' \\
plot\_pars		 \> Read if {\tt plotform} is 'var' or 'VAR'
\end{tabbing}

The {\tt plot\_range} is described by 6 coordinates. If the width in one or two 
dimensions is less than the smallest cell size within the plotarea, 
then the plot file will be 2 or 1 dimensional. If the range is thin but
symmetric about one of the x=0, y=0, or z=0 planes, data will be averaged
in the post processing.

The parameter {\tt plot\_dx} controls the resolution of the plots for IDL
files.  The allowed values  are:
\begin{tabbing}
Value \hspace{1.0in} \= Resulting resolution in plotfile\\
------------------ \> ------------------------------------------------------------------------------ \\
 REAL ($>$ 0.0)	       \> Structured Cartesian mesh at the indicated resolution. \\
 0.0	               \> Structured Cartesian mesh based on the smallest cell 
                          in the plotting area. \\
 -1.	               \> Original, unstructured grid will be produced by PostIDL.exe.
\end{tabbing}


If the {\tt plotarea} is 'sph' then {\tt R\_plot} is read and gives
the radius at which to make the spherical plot.
\ \ \\

\begin{alltt}
#SAVEBINARY    \hfill {\bf No Restriction}
\end{alltt}

This command determines whether IDL plot files will be written in ASCII
or in binary.  The flag has no effect on other output.  Binary format
is smaller, faster and more accurate, ASCII format is machine independent
and human readable.
\ \ \\

\begin{alltt}
#SAVEPLOTSAMR    \hfill {\bf No Restriction}
\end{alltt}

When {\tt saveplotsamr} is set {\tt .true.}, all plot files listed in
the {\tt \#SAVEPLOTS} command will be saved before AMR occurs.  This
command is useful developing new grids to be used in ``prespecified''
refinement.
\ \ \\

\begin{alltt}
#SPACECRAFT    \hfill {\bf Inoperative}
\end{alltt}

\begin{alltt} 
#PLANET    \hfill {\bf Inoperative}
\end{alltt}


%======================================================================

\subsection{Saving and Restarting \label{section:restart}}

\begin{alltt}
#RESTART \hfill {\bf Session 1 Only}
\end{alltt}

This command flags if the user wished to start the current run from a restart 
file or whether the user wish to begin a new run.
\ \ \\

\begin{alltt}
#SAVERESTART   \hfill {\bf No Restriction}
T                      save_restartfile  Rest of parameters read if true
100                    dn_output(restart_)
-1.                    dt_output(restart_) in s. Read if time_accurate!
\end{alltt}

This command controls the writing of restart files.
The default is {\tt save\_restartfile} = {\tt .true.} with 
{\tt dn\_output(restart\_)} = $-1$, {\tt dt\_output(restart\_)}=$-1$ which
will print a restart file only at the end of a run.

{\bf IMPORTANT:} Restart filenames do not have an iteration number in them,
so {\bf restart files are overwritten every time a new restart file is
written}.  Rename the {\tt restartOUT} directory if you want to save the restart
files.  Make sure you create a new {\tt restartOUT} directory!

{\bf Note for Beowulf systems with local disk writing}.  Each processor
writes its own restart files.  These will have to be collected to one
location for storage and redistributed to each node for restarting.
{\bf We strongly recommend using NFS mounted disks for a Beowulf cluster}.

%======================================================================

\subsection{Physics \label{section:physics}}

\begin{alltt}
#GAMMA   \hfill {\bf Session 1 Only}
\end{alltt}

This command sets the ratio of specific heats.  Default value is 5/3.
\ \ \\

\begin{alltt}
#SHOCKTUBE   \hfill {\bf Session 1 Only}
\end{alltt}
No default values are set for this case, because the input values load
the initial conditions that the user wants.  The plasma parameters are
loaded for a state to the left of an interface and to the right of an
interface.  The shock tube can be tilted so that no ordinal direction
of the grid is along the shock tube axis.
\ \ \\


\begin{alltt}
#SOLARWIND  \hfill {\bf Session 1 Only} -- {\bf Required for Many Problem Types}
\end{alltt}

This command allows the user to input solar wind values.  These values
are used in problem types where the central body has the solar wind impinging
on it, and in fact the {\tt \#SOLARWIND} command must be used for these
cases. The values are used to set initial conditions on the entire
simulation domain.  Additionally, they are used to enforce boundary
conditions on the inflow boundary (when {\tt UseUpstreamInputFile} 
is not set) and on the side boundaries (when the boundary condition is
set to {\tt fixed}).  They {\bf cannot be changed} because they are also
used to do the normalization.  Changing the upstream conditions should
be done through the {\tt \#UPSTREAM\_INPUT\_FILE} command.

Restart is a tricky thing for this command.  Since the restart files are
written out in dimensionless numbers and since the normalizations are
done with these variables, these number must be read in with exactly
the same values as when making the restart file.
\ \ \\


\begin{alltt}
#BODY    \hfill {\bf Session 1 Only}
T                      body1   !Others read only if Body1=.true.
3.0                    Rbody
4.0                    Rcurrents
1.0                    Body_rho_dim (/ccm) density for fixed BC for rho_BLK
10000.0                Body_T_dim (K) temperature for fixed BC for P_BLK
\end{alltt}

The parameters in {\tt \#BODY} are used to control the use
of the central body ({\tt body1} and {\tt Rbody}), to supply values to be used as 
boundary conditions at the central body  ({\tt Body\_rho\_dim} and 
{\tt Body\_T\_dim})
and to set the radius at which the field aligned current
are calculated ({\tt Rcurrent}).  Note that if the innerboundary is moved in, 
the density and temperature should probably by increased.
\ \ \\

\begin{alltt} 
#MASSLOADING \hfill {\bf No Restriction}
\end{alltt}

These parameters let the user turn mass loading on and off and also to control
time dependence of the mass loading rate.
\ \ \\

\begin{alltt}
#SETREALTIME   \hfill {\bf No Restriction}
\end{alltt}

This command allows the user to set the real world date and time for the current run.
The real time is used by other commands to set things like the dipole tilt,  the
rotation axis tilt and various ionosphere parameters.
It is also used to set the real time in other models to which the MHD code
is coupled.
\ \ \\

\begin{alltt}
#AXES  \hfill {\bf Session 1 Only}
GSM                    CoordinateSystemString
user user              AxesType
31100.0                Bdp_dim (in nT)
30.0                   ThetaTilt (rotation from +Z direction)
30.0                   CorotationTilt (rotation from +Z direction)
90.0                   CorotationLon (rotation from +X direction)
39600.0                rot_period (in seconds)
\end{alltt}

The principle axes of the simulation (the dipole axis and the rotation
axis) are controlled with this command.  While the {\tt \#DIPOLE} and 
{\tt \#COROTATION} commands still work, the {\tt \#AXES} command 
replaces them and adds new functionality.  All the new functionality is
not directly controlled by the user at input, but exists to make 
the axis orientations more physical.

The input string {\tt CoordinateSystemString} indicates the coordinate 
system in which the code is run.  Currently the only option is
\begin{verbatim}
GSM
\end{verbatim}
or, Geocentric Solar Magnetic.  In this system the $X$-axis points to sun, 
and the magnetic dipole axis is contained in the $XZ$-plane.

The {\tt AxesType} line contains two strings that indicate the 
functionality of the magnetic dipole  and the rotation axes.  The first string
controls the magnetic dipole while the second controls the corotation axis.  
{\bf If only one string is given, the same value is used for both}.  

Possible values are:
\begin{tabbing}
String   \hspace{0.25in} \= Mag\=netic Dipole meaning  \hspace{1.0in} \= Cor\=otation meaning\\
--------                 \>  --------------------------------------  
                       \> \> --------------------------------------\\
none     \> dipole strength (Bdp\_dim) = 0.0  \> \> UseCorotation = false\\
\\
ideal    \> 0.0 degree dipole tilt            \> \> 0.0 degree corotation axis tilt\\
         \> Bdp\_dim set by problem\_type      \>  \> rotation rate set by problem\_type\\
\\
planet   \> Dipole tilt and Bdp\_dim set     \> \> Rotation axis tilt and rate set\\
         \>   \>by problem\_type according to  \>   \>by problem\_type according to\\
         \>   \>the date set in \#SETREALTIME. \>   \>the date set in \#SETREALTIME.\\
         \> Values are updated in time.     \> \> Values are updated in time.\\
\\	   				         
user     \> User specified values:            \> \> User specified values:\\
         \>   \>Bdp\_dim                       \>   \> rot\_period \\
         \>   \>ThetaTilt                     \>   \> CorotationTilt \\
         \> Not updated in time.              \> \> Not updated in time.
\end{tabbing}

The user specified values {\tt Bdp\_dim} and {\tt ThetaTilt} are read only when
the {\tt AxesType} string dipole is set for 'user'.  The values of {\tt CorotationTilt},
{\tt CorotationLon}, and {\tt rot\_period} are read only if the {\tt AxesType} 
for corotation is 'user'.  

When using {\tt AxesType} 'planet', \BATSRUS\ automatically updates the locations
of the dipole and/or rotation axes with time according to the date and time set
in {\tt \#SETREALTIME}.  For other type the axis are static in time.
\ \ \\


\begin{alltt}
#DIPOLE    \hfill  {\bf Session 1 Only}
-31100.0               DipoleStrength (equatorial field strength at R=1 in nT)
F                      SetDipoleTilt
0.0                    ThetaTilt
0.0                    dt_UpdateB0
\end{alltt}

This command has been superceeded by the command {\tt \#AXES}, but still functions
as indicated.

The dipole magnetic field of the central body is controlled with this command.
The user sets the strength by setting the magnetic field magnitude at the equator.
The sign of {\tt DipoleStrength} determines the direction of the dipole moment vector.  Solar system
north (opposite of Earth) is positive.  In other words, Earth should use a negative
and Saturn would use a positive.
If {\tt SetDipoleTilt} is {\tt .false.}, then the dipole tilt angle is set
according to the time of day and day of year specified by the {\tt \#SETREALTIME}
command.  So far, this is implemented only for {\tt problem\_earth}.
If {\tt SetDipoleTilt} = {\tt .true.}, the dipole tilt angle is set 
according to {\tt ThetaTilt}.
When running in time accurate mode and if {\tt SetDipoleTilt} = {\tt .false.},
the user may want the dipole to move
as it would physically.  The parameter {\tt dt\_UpdateB0} sets the interval
at which the dipole is updated.
\begin{tabbing}
Value \hspace{0.5in} \= Update Frequency \\
-----------          \> ----------------------------------------------------------\\
 $>$ 0.0	     \> The update rate in seconds. \\
 = 0.0	             \> Use the default value in the code. (approx. 34 s)\\\
 $<$ 0.0             \> Do not update the angle. \\
\end{tabbing}
Again, this is currently only implemented for {\tt problem\_earth}.  Note that
the dipole moment vector lies in the x-z plane which means that we are using
Geocentric Solar Magnetic (GSM) coordinates.
\ \ \\

\begin{alltt}
#COROTATION   \hfill   {\bf Session 1 Only}
T                      UseCorotation
F                      AlignDipoleCorotation 
F                      SetCorotationTilt
0.0                    CorotationTilt
\end{alltt}

This command has been superceeded by the command {\tt \#AXES}, but still functions
as indicated.

The rotation of the central body is set with this command.  The rate of rotation
is problem dependent and is set in {\tt set\_physics.f90}.  This command allows
the user to choose to apply rotation or not.  Additionally, the user can choose
to have the rotation axis aligned with the dipole axis by setting 
{\tt AlignDipoleCorotation} = {\tt .true.}.  If it is set {\tt .false.}, then the
user can specify whether the tilt is set manually or automatically 
as with the {\tt \#DIPOLE} command.  If {\tt SetCorotationTilt} is {\tt .true.}
the the value of  {\tt CorotationTilt} is used to set the tilt.  Otherwise the
tilt is based on the values in {\tt \#SETREALTIME}.  Since the rotation axis
varies on a yearly basis as the body orbits the sun, the angle does not need
to be updated with time.  The user should note that when using this command
instead of {\#AXES} the of the rotation tilt that is perpendicular to the 
x-z plane is ignored.
\ \ \\

\begin{alltt}
#SECONDBODY  \hfill {\bf Session 1 Only}
\end{alltt}

This command allows the user to turn on a second body in the simulation and to
indicate the location of this body.  The user will need to ensure that there
is enough resolution so that the body is resolved or the body will have no
effect.
\ \ \\

\begin{alltt}
#IONOSPHERE \hfill {\bf No Restriction}
T                      UseIonosphere  ! Rest of the parameters read if.true.
3                      conductance_model
150.                   f107_flux
0.5                    StarLightPedConductance
1.0                    PolarCapPedConductance
100                    dn_couple_ionosphere
60.0                   dt_couple_ionosphere
\end{alltt}

Aaron needs to document this since I really have no idea how it works!
\ \ \\

\begin{alltt}
#UAM     \hfill  {\bf No Restriction}
\end{alltt}

This command is used to couple the MHD code with the TIEGCM code.
This option is experimental.
\ \ \\

\begin{alltt}
#IMM    \hfill {\bf Inoperative}
\end{alltt}

This command will couple the MHD code with the Inner Magnetosphere
Model (IMM) when operative.  IMM will be a parallelized, updated
version of the Rice Convection Model (RCM).
\ \ \\

\begin{alltt}
#AMIE   \hfill {\bf Inoperative}
\end{alltt}

This command will couple the MHD code with the AMIE ionosphere
code when operative.
\ \ \\

\begin{alltt}
#RAM     \hfill {\bf Inoperative}
\end{alltt}

This command will couple the MHD code with the RAM ring
current code when operative.
\ \ \\

\begin{alltt}
#HELIOSPHERE  \hfill  {\bf Not Updated - Status Unknown}
\end{alltt}

This command sets parameters that are only used by the {\tt problem\_heliosphere}.
Since this case has not been run for a while, it may or may not work.
\ \ \\

\begin{alltt}
#COMET      \hfill {\bf No Restriction}
\end{alltt}

This command sets parameters that are only used by the {\tt problem\_comet}.
\ \ \\


%======================================================================

\subsection{Numerics: Time Discretization \label{section:time}}

\begin{alltt}
#TIMESTEPPING    \hfill {\bf No Restriction}
T                      time_accurate          (default is false)
2                      nSTAGE                 (default is 1 stage)
0.80                   cfl                    (default is 0.8)
\end{alltt}

Allow the user to control whether local time stepping of time accurate
time stepping are used (see section~\ref{section:time_stepping}).
When time accurate is used this command must
be called before other commands that need times.  Specifically, since
many time, output, and plotting commands read two parameters when time
accurate, but only one when using local time stepping this command
must be called first or the correct parameters will not be read.
{\tt nSTAGE} controls whether or not 2 stage, second order, time stepping
or 1 stage, first order, time stepping is used, see equations~(\ref{q-one-stage})-
(\ref{q-two-stage}).  The cfl number 
(see equations~(\ref{q-local-dt}) -(\ref{eq:cfl_limit}))
is
a multiplier of the time step.  When cfl=1 the time step is marginally
stable.  Investigation has shown that a value of 0.8 is stable generally.
This value will be problem dependent, however, and may need to be changed.
Lower numbers are more stable, but mean smaller time steps. 
\ \ \\

\begin{alltt}
#BORIS   \hfill    {\bf No Restriction}
T                      boris_correction
0.10                   boris_cLIGHT_factor !Only if boris_correction is true
\end{alltt}

This command controls the Boris correction.  See section~\ref{section:boris}.
The {\tt boris\_cLIGHT\_factor} is the factor by which the speed of light is
reduced.
\ \ \\


\begin{alltt}
#IMPLICIT \hfill {\bf No Restriction}
\end{alltt}

While \BATSRUS\ currently uses an explicit time step, the source term
can be easily updated in a point implicitly way.  This helps with stiffness
problems in the source terms.  The default for this command is {\tt .false.},
but if there are stiff source terms, this can be changed to true.  There
is some question about the implementation of this in the code.  This will
be corrected in future distributions. See section~\ref{section:point_implicit}.
\ \ \\


\subsection{Numerics: Spatial Discretization \label{section:space}}

\begin{alltt}
#SCHEME \hfill {\bf No Restrictions}
2                      nORDER (1 or 2)
2                      fluxfcn_type  1=Roe, 2=Rusanov, 3=Linde
minmod                 limiter_type ! Only for norder=2
\end{alltt}

This command lets the user control the details of the method that is used
to calculate fluxes and the order of the calculation.  See 
section~\ref{section:numerical_schemes}.
\ \ \\

\begin{alltt}
#NONCONSERVATIVE   \hfill    {\bf No Restriction}
6.0                    Rconservative
\end{alltt}

This controls whether energy (conservative) or pressure (nonconservative) is
advanced near the body.  The variable {\tt Rconservative} controls the radius
inside which pressure is advanced.  Outside of this radius, energy is advanced.
A value of -1. will force energy advance everywhere.  Advancing pressure near
the body where ${\bf B}$ is large, prevents negative pressures.
\ \ \\

\begin{alltt}
#DIVB     \hfill    {\bf No Restriction}
T                      UseDivbSource
F                      UseDivbDiffusion
F                      UseProjection
F                      UseConstrainB
\end{alltt}

Lets the user control the divergence B control method.
If UseProjection or UseConstrainB are true, all others should be false.
At least one of the options should be true.  See section~\ref{section:divb}.
\ \ \\

\begin{alltt}
#PROJECTION  \hfill  {\bf No Restriction}
bicgstab               proj_method:   'cg' or 'bicgstab' for iterative scheme
rel                    proj_typestop: 'rel' or 'max' error for stop condition
0.1                    proj_divbcoeff relative limit
0.0                    proj_divbconst absolute limit 
50                     proj_matvecmax	(upper limit on matrix.vector multipl.)
\end{alltt}

If {\tt UseProjection} is true, the numerical solution of the Poisson 
problem (see section \ref{section:projection}) is governed by the above parameters.
The default settings (shown above) are acceptable for typical applications.
One may change them to reduce the $\divB$ error or to reduce
the amount of work spent on the projection. 
To project the initial solution for the CT scheme,
the defaults should definitely be changed.

The {\tt proj\_method} parameter determines which Krylov type scheme is used
to solve the Poisson equation (\ref{q-poisson}). The Conjugate Gradient (CG) 
\cite{hestenes-stiefel}
method works for symmetric matrices that arise for a uniform Cartesian grid.
It may reduce the residual to some extent for non-symmetric problems too,
which occurs for the AMR grid, but it cannot find an accurate solution.
For that the Bi-Conjugate Gradient (Bi-CGSTAB) method 
\cite{vandervorst}
must be used, which is twice as expensive as the simple CG scheme.

The stopping criterion {\tt proj\_typestop} can be based on the relative change
('rel') of the second norm, or on the maximum norm ('max'). In the first
case the stopping condition is $||\divB^{n+1}||<\epsilon||\divB^*||$,
where $\epsilon$ is given by {\tt proj\_divbcoeff}. 
In the second case there are
two possibilities: if {\tt proj\_divbcoeff} is positive, the stopping condition
is $\max(\divB^{n+1})<\epsilon\max(\divB^*)$, otherwise it is
$\max(\divB^{n+1})<\delta$ where $\delta$ is given by {\tt proj\_divbconst}. 

Finally the number of matrix vector multiplications (1 per iteration for CG
and 2 per iteration for BiCGSTAB) can also be limited by the 
{\tt proj\_matvecmax} parameter. To obtain an accurate projection 
for the Constrained Transport scheme try something like
\begin{verbatim}
#PROJECTION
bicgstab
max
0.0
0.0001
400
\end{verbatim}
which requires that $\divB<0.0001$ and allows 400 matrix vector multiplications
(200 iterations) at most to achieve this accuracy. This is costly, but it is
only done once before the first time step with the Constrained Transport 
scheme.
\ \ \\

\begin{alltt}
#DIVBDIFFUSION   \hfill   {\bf No Restriction}
0.4                    divb_diffcoeff  
\end{alltt}

Controls the amount  of divergence B diffusion to use if {\tt UseDivbDiffusion}
is {\tt .true.} in the {\tt \#DIVB} command.
See section~\ref{section:diffusive_control}.
\ \ \\

\begin{alltt}
#UPDATECHECK     \hfill    {\bf No Restriction}
T                      UseUpdateCheck
40.                    rhomin[\%]
400.                   rhomax[\%]
40.                    Pmin[\%]
400.                   Pmax[\%]
\end{alltt}

When {\tt UseUpdateCheck} is {\tt .true.} if the density or pressure
change by more that the given percentages in a time step, the timestep 
is reduced so that the change in density and pressure are reduced below the
values given above. This option should almost always be used.
\ \ \\

\begin{alltt}
#CORRECTP        \hfill    {\bf No Restriction}
0.000001               Pratio_min (lowest thermal energy ratio allowed)
0.01                   Pratio_lo  (below this ratio only E is corrected)
0.1                    Pratio_hi  (above this ratio only P is corrected)
\end{alltt}

These values set the minimum allowable ratio of thermal energy to total
energy and how the value is corrected when it is lower.  This happens at
the time of the message pass.  This option is most important for 
projection and constrained transport but could affect other things. It
is less critical now with the addition of the {\tt \#UPDATECHECK} and
the {\tt \#NONCONSERVATIVE} commands which can fix the root cause of
the low thermal energy (pressure) problem.
\ \ \\

\begin{alltt}
#PROLONGATION   \hfill  {\bf No Restriction}
2                      prolong_order (1 or 2 for ghost cells)
lr                     prolong_type  ! Only for prolong_order=2
\end{alltt}

The default is {\tt prolong\_order} = 1.  When {\tt prolong\_order} = 2,
the default for {\tt prolong\_type}=lr.
The {\tt \#PROLONGATION} command controls the way that data
from small cells is merged into a larger cell and how the 
information in a large cells in interpolated to smaller cells.
The parameter {\tt prolong\_order} determines whether the
prolongation will use first of second order interpolation.
When {\tt prolong\_order} =2,  there are several different 
values for {\tt prolong\_type}:
\begin{tabbing}
{\bf CASE 1} - in message\_pass\_dir (used if {\tt limiter\_type} is not 'LSG') \\
\\
prolong\_type \hspace{0.5in} \= Type of interpolation \\
-----------------            \> ----------------------------------------------- \\
lr		             \> Interpolate only with left and right slopes  \\
central	                     \> Interpolate only with central difference slope\\
minmod 	                     \> Interpolate only with minmod limited slope\\
lr2		             \> Like 'lr' but extrapolate when necessary\\
central2	             \> Like 'central' but extrapolate when necessary\\
minmod2	                     \> Like 'minmod' but extrapolate when necessary\\
lr3		             \> Only experimental
\end{tabbing}
\begin{tabbing}
{\bf CASE 2} - in message\_pass\_all (used if {\tt limiter\_type} is 'LSG') \\
\\
prolong\_type \hspace{0.5in} \= Type of interpolation \\
-----------------            \> ---------------------------------------------- \\
lr, lr2		             \> Left and right slopes (all interpolation) \\
central, central2'	     \> Central differences (all interpolation) \\
minmod, minmod2'	     \> To be implemented
\end{tabbing}
\ \ \\


\begin{alltt}
#OPTIMIZE  \hfill  {\bf No Restriction}
F                      optimize_faceflux
F                      optimize_conservativeflux
dir                    optimize_message_pass
\end{alltt}

This command allows the user to control the use of subroutines that
have been optimized.  The default values are shown above. 
The message passing of ghost cells information
is controlled by the {\tt optimize\_message\_pass} variable. It has the following
options:
\begin{tabbing}
\hspace{0.65in}   \= Message Pass \hspace{1.0in}   \= Grouping of messages and  \\
String           \> Subroutines Called            \> Which Messages are Passed \\      
-----------      \> ------------------------------------  \> ----------------------------------------------------------------------\\
dir              \> message\_pass\_dir            \>  group messages direction by direction \\
face             \> message\_pass\_dir            \>  group messages face by face \\
min              \> message\_pass\_dir            \>  send equal, restricted and prolonged 
                                                      messages face by face \\
\\
all              \> messagepass\_all              \>  all corners and edges for each variable \\
\\
old              \> message\_pass\_equal          \>  equal \\
                 \> message\_pass\_reschange      \>  restricted and prolonged - 
			                              no corners, variable by variable \\
\> \> \\
oldopt           \> message\_pass\_equal\_opt     \>  equal - optimized \\
                 \> message\_pass\_reschange\_opt \>  restricted and prolonged - 
                                                      no corners, all variables together - optimized
\end{tabbing}

Note that ray tracing and constrained transport cannot be used if corners
are not passed.  Projection uses message\_pass\_dir for 
for efficiency, although it does not need corners.
\ \ \\


\begin{alltt}
#RAYTRACE    \hfill  {\bf No Restriction}
T                      UseRayTrace    ! Rest of the parameters read if .true.
F                      check_rayloop print info for loops
100                    dn_raytrace   how often
3.0                    R_raytrace    where to stop with ray tracing
\end{alltt}

Raytracing is still experimental. 
\ \ \\





