#!/usr/bin/perl -s
#^CFG COPYRIGHT UM

my $Help          = ($h or $help or $H or $HELP);
my $Keep          = ($k or $keep or $K or $KEEP);
my $MakeMovie     = ($m or $M or $movie or $MOVIE);
my $KeepMovieOnly = ($M or $MOVIE);
my $Verbose       = ($v or $V or $verbose or $VERBOSE);
my $Quiet         = ($q or $quiet or $Q or $QUIET);
my $Ccmc          = ($CCMC or $ccmc);
my $nThread       = ($n or 4);

use strict;

my $ERROR = "ERROR in pIDL";
my $WARNING = "WARNING in pIDL";

&print_help if $Help;

my $Pwd     = `pwd`; chop $Pwd;
my $PostIdl = "$Pwd/PostIDL.exe";

my $Pattern = "IO2/";
$Pattern = $ARGV[0] if $ARGV[0];

# Split $Pattern into a directory and the basename for the files
my $Dir;
if($Pattern =~ /\/([^\/]*)$/){
    $Dir = $`;
    $Pattern = $1;
}else{
    $Dir = $Pattern;
    $Pattern = '';
}
print "Dir = $Dir Pattern = $Pattern\n" if $Verbose;

die "$ERROR: no plot directory found in argument $ARGV[0]\n" unless $Dir;
die "$ERROR: plot directory $Dir does not exist\n" unless -d $Dir;

# Change into the plot directory
print "chdir $Dir\n" if $Verbose;
chdir $Dir or die "$ERROR: could not change directory into $Dir\n";

# Collect header files
opendir(DIR,'.');
my @HeaderFiles = sort grep /^$Pattern.*\.h$/, readdir(DIR);
closedir(DIR);

if(@HeaderFiles){
    die "$ERROR: $PostIdl is not available, please make PIDL\n" 
	unless -x $PostIdl;
}elsif(not $MakeMovie){
    die "$WARNING: no header files were found\n";
}

# Success, go ahead and process files
my $nHeaderFile = $#HeaderFiles+1;
print "Number of header files=$nHeaderFile\n" unless $Quiet;
my $HeaderFile;

if($nThread > 1){
    foreach my $iThread (1..$nThread){
	# parent process does nothing
	next if fork();
	for (my $iFile = $iThread-1; $iFile<$nHeaderFile; $iFile+=$nThread){
	    $HeaderFile = $HeaderFiles[$iFile];
	    &process_file($HeaderFile);
	}
	exit;
    }
    foreach (1..$nThread){wait};
}else{
    foreach $HeaderFile (@HeaderFiles){&process_file($HeaderFile)}
}

# Done unless movie is to be made from the .out files
exit 0 unless $MakeMovie;

# Collect the .out files
opendir(DIR,'.');
my @OutFiles = sort(grep /\.out$/, readdir(DIR));
closedir(DIR);

# Group the .out files and save the last and first steps
my %Series;
my $OutFile;
for $OutFile (@OutFiles){
    my $BaseName = $OutFile;

    # Remove extension
    $BaseName =~ s/(_t[\.\d]+)?_n\d+\.out$// or
	die "$ERROR: file name $OutFile does not match _nSTEPNUM.out format\n";

    # Store outfile
    push @{$Series{$BaseName}}, $OutFile;
}

my $BaseName;
foreach $BaseName (sort keys %Series){
    # Do not create movie if there is only one element in the series
    my @Series = @{$Series{$BaseName}};

    $_ = $Series[0];
    my $FirstStep;
    ($FirstStep) = /_n(\d+)/;

    $_ = $Series[-1];
    my $LastStep;
    ($LastStep) = /_n(\d+)/;

    # Convert step strings to numbers
    $FirstStep += 0;
    $LastStep  += 0;

    # Check if there is an old movie file
    my @OldMovieFiles; 
    @OldMovieFiles = glob("$BaseName*.outs");
    my $OldMovieFile;

    if(@OldMovieFiles){
	die "$ERROR: multiple .outs files with the same base name: ".
	    "@OldMovieFiles\n" if $#OldMovieFiles > 0;

	my $OldMovieFile = $OldMovieFiles[0];

	$OldMovieFile =~ /$BaseName\_n(\d+)_(\d+)\.outs/
	    or die "$ERROR: file name $OldMovieFile does not match ".
	    "_nFIRST_LAST.outs\n";

	my $OldFirstStep = $1;
	my $OldLastStep  = $2;

	my $NewMovieFile = "${BaseName}_n${OldFirstStep}_${LastStep}.outs";
	if($FirstStep > $OldLastStep){
	    print "Creating $Dir/$NewMovieFile from $Dir/$OldMovieFile\n" 
		unless $Quiet;
	    &system("cat @Series >> $OldMovieFile");
	    &system("mv $OldMovieFile $NewMovieFile");
	}elsif($FirstStep == $OldFirstStep and $LastStep == $OldLastStep){
	    print "Rewriting $Dir/$OldMovieFile\n" unless $Quiet;
	    unlink($OldMovieFile);
	    &system("cat @Series > $OldMovieFile");
	}elsif($FirstStep == $OldFirstStep and $LastStep > $OldLastStep){
	    print "Replacing $Dir/$OldMovieFile with $Dir/$NewMovieFile\n" 
		unless $Quiet;
	    unlink($OldMovieFile);
	    &system("cat @Series > $NewMovieFile");
	}else{
	    warn "$WARNING: movie file $Dir/$OldMovieFile does not seem to ".
		"belong\nto the $Dir/$Series[0] ... $Dir/$Series[-1] files\n";
	    next;
	}
    }else{
	# do not make movie file from a single file
	next if $FirstStep eq $LastStep;

	my $NewMovieFile = "${BaseName}_n${FirstStep}_${LastStep}.outs";

	print "Creating $Dir/$NewMovieFile\n" unless $Quiet;

	&system("cat @Series > $NewMovieFile");
    }
    # Remove the .out files if requested
    &system("rm -f @Series") if $KeepMovieOnly;
}

exit 0;

##############################################################################

sub system{
    my $Command = join(' ',@_); 
    print "$Command\n" if $Verbose;
    `$Command`;
}

sub process_file{
    my $HeaderFile = shift;
    my $BaseFile = $HeaderFile; $BaseFile =~ s/\.h$//;
    print "PostIDL.exe < $HeaderFile\n" unless $Quiet;
    my $OutFile = "$BaseFile.out";
    my $Output= `$PostIdl < $HeaderFile 2>&1` unless -s $OutFile and $Ccmc;
    my $Error = ($Output =~ /error/i or $?);
    my $Warning = join("\n",grep /warning/i, split("\n",$Output));
    print "$Warning\n" if $Warning and not ($Quiet or $Error);
    print $Output if $Verbose or $Error;
    die "$ERROR: error found in the output of $PostIdl\n" if $Error; 
    die "$ERROR: no out file $OutFile was produced\n" unless -s $OutFile;
    unless($Keep){
	if($BaseFile =~ /3d_/){
	    unless($Ccmc){
		rename $HeaderFile, $BaseFile.".info";
	    }
	}else{
	    unlink $HeaderFile;
	}
	unlink glob("$BaseFile*.idl");
	print "unlink ",join(" ",glob("$BaseFile*.idl")),"\n" if $Verbose;
    }
}

##############################################################################

sub print_help{
    print "
Purpose: 
   Combine *.idl files written out separately by the processors 
   into .out files using the PostIDL.exe code. 
   Create .outs movies from the .out files if requested.

Usage:
   pIDL [-h] [-v] [-k] [-m|M] [-n=NUMBER] [BASENAME]

   -h -help    - print this help message
   -v -verbose - print verbose information
   -q -quiet   - do not print any information
   -k -keep    - keep the .h and .idl files. Default is to delete them.
   -m -movie   - create movie from the .out files and keep the .out files
   -M -MOVIE   - create movie from the .out files and delete the .out files
   -n=NUMBER   - execute PostIDL.exe in parallel on NUMBER cores. Default is 4.
   BASENAME    - the beginning of the filenames to be processed.
                 Default value is BASENAME='IO2/'

Examples:
   Process all files in the IO2/ directory and remove .idl files:
pIDL

   Do the same in parallel using 8 threads
pIDL -n=8

   Process all files in the IO2/ directory, create .outs movies and remove
   all the .h, .idl and .out files:
pIDL -M

   Process all files in the Plots/ directory, create .outs movies
   and keep the .idl and .out files as well:
pIDL -k -m Plots/

   Process files starting with Plots/y=0 and print verbose information:
pIDL -v Plots/y=0
";
   exit 0;
}

