<!-- The syntax is described by share/Scripts/CheckParam.pl and the manual -->

<commandList name="BATSRUS: GM, EE, SC, IH and OH Components">

List of MH (GM, EE, SC, IH, and OH) commands used in the PARAM.in file

<!-- Grid size array is transformed into scalars to simplify rules -->
<set name="MaxBlock"     type="integer" value="$_GridSize[3]" />
<set name="MaxImplBlock" type="integer" value="$_GridSize[4]" />

<!-- Set max for total number of blocks if both _nProc and MaxBlock are set -->
<set name="MaxBlockALL" type="integer"
        value="$_nProc and $MaxBlock and $_nProc*$MaxBlock" />

<set name="NameComp"          type="string" value="$_NameComp"/>
<set name="NameRestartOutDir" type="string" value="$NameComp/restartOUT"/>
<set name="NamePlotDir"       type="string" value="$NameComp/IO2"/>

<commandgroup name="STAND ALONE MODE">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!! STAND ALONE PARAMETERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

<command name="COMPONENT">
	<parameter name="NameComp" type="string" input="select">
		<option name="GM" default="T" />
		<option name="EE" />
		<option name="SC" />
		<option name="IH" />
		<option name="OH" />
	</parameter>
	<set name="NameRestartOutDir" type="string" 
						value="$NameComp/restartOUT"/>
	<set name="NamePlotDir"       type="string" 
						value="$NameComp/IO2"/>
#COMPONENT
GM			NameComp

This command can be used in the stand-alone mode to make BATSRUS behave as
if it was the Global Magnetosphere (GM), Eruptive Event (EE), 
Solar Corona (SC), Inner Heliosphere (IH) or Outer Heliosphere (OH) 
component of the SWMF. The NameComp
variable contains the two-character component ID of the selected component.
If NameComp is different from the default component value, then
the default values for all parameters (including the component dependent 
defaults, like coordinate system) are reset, therefore it should occur 
as the first command if it is used to change the behavior of BATSRUS.
The default behavior is Global Magnetosphere (GM) for the stand-alone BATSRUS.

The command is also saved into the restart header files.

In the SWMF the BATSRUS codes are configured to the appropriate components,
so the default components should not be changed by this command.
</command>

<command name="DESCRIPTION" if="$_IsStandAlone">
	<parameter name="StringDescription" type="string" length="100" />

#DESCRIPTION
This is a test run for Jupiter with no rotation.

This command is only used in the stand alone mode.

The StringDescription string can be used to describe the simulation
for which the parameter file is written. The #DESCRIPTION command and
the StringDescription string are saved into the restart file,
which helps in identifying the restart files.

The default value is ``Please describe me!", which is self explanatory.
</command>

<command name="ECHO" if="$_IsStandAlone">
        <parameter name="DoEcho" type="logical" default="F"/>

#ECHO
T                       DoEcho

This command is only used in the stand alone mode.

If the DoEcho variable is true, the input parameters are echoed back.
The default value for DoEcho is .false., but it is a good idea to
set it to true at the beginning of the PARAM.in file.
</command>

<command name="PROGRESS" if="$_IsStandAlone">
	<parameter name="DnProgressShort" type="integer" min="-1" 
		default="10"  />
	<parameter name="DnProgressLong"  type="integer" min="-1" 
		default="100" />
#PROGRESS
10			DnProgressShort
100			DnProgressLong

The frequency of short and long progress reports for BATSRUS in
stand alone mode. These are the defaults. Set -1-s for no progress reports.
</command>

<command name="TIMEACCURATE" if="$_IsStandAlone">
        <parameter name="DoTimeAccurate" type="logical" default="T" />

#TIMEACCURATE
F               DoTimeAccurate

This command is only used in stand alone mode.

If DoTimeAccurate is set to true, BATSRUS solves
a time dependent problem. If DoTimeAccurate is false, a steady-state
solution is sought for. It is possible to use steady-state mode
in the first few sessions to obtain a steady state solution,
and then to switch to time accurate mode in the following sessions.
In time accurate mode saving plot files, log files and restart files,
or stopping conditions are taken in simulation time, which is the
time relative to the initial time. In steady state mode the simulation
time is not advanced at all, instead the time step or iteration number
is used to control the frequencies of various actions.

The steady-state mode allows BATSRUS to use local time stepping
to accelerate the convergence towards steady state.

The default value depends on how the stand alone code was installed.
See the description of the NEWPARAM command.
</command>

<command name="BEGIN_COMP" multiple="T" if="$_IsStandAlone">

This command is allowed in stand alone mode only for the sake of the 
test suite, which contains these commands when the framework is tested.
</command>

<command name="END_COMP" multiple="T" if="$_IsStandAlone">

This command is allowed in stand alone mode only for the sake of the 
test suite, which contains these commands when the framework is tested.
</command>

<command name="RUN" if="$_IsStandAlone">

#RUN

This command is only used in stand alone mode.

The #RUN command does not have any parameters. It signals the end
of the current session, and makes BATSRUS execute the session with
the current set of parameters. The parameters for the next session
start after the #RUN command. For the last session there is no
need to use the #RUN command, since the #END command or simply
the end of the PARAM.in file makes BATSRUS execute the last session.
</command>

<command name="END">

#END

The #END command signals the end of the included file or the
end of the PARAM.in file. Lines following the #END command are
ignored. It is not required to use the #END command. The end
of the included file or PARAM.in file is equivalent with an 
#END command in the last line.
</command>

</commandgroup>


<commandgroup name="PLANET PARAMETERS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!! PLANET PARAMETERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

The planet commands can only be used in stand alone mode.
The commands allow to work with an arbitrary planet.
It is also possible to change some parameters of the planet relative
to the real values.

By default Earth is assumed with its real parameters.
Another planet (moon, comet) can be selected with the #PLANET
(#MOON, #COMET) command. The real planet parameters can be modified 
and simplified with the other planet commands listed in this subsection.
These modified commands cannot precede the #PLANET command!

<command name="PLANET" alias="MOON,COMET"
	if="$_IsFirstSession and $_IsStandAlone">
	<parameter name="NamePlanet" type="string" case="upper" input="select">
		<option name="NONE"			/>
		<option name="NEW" 			/>
		<option name="MERCURY"			/>
		<option name="VENUS"			/>
		<option name="EARTH" default="T"	/>
		<option name="MARS"			/>
		<option name="JUPITER"			/>
		<option name="SATURN"			/>
		<option name="URANUS"			/>
		<option name="NEPTUNE" 			/>
		<option name="PLUTO" 			/>
		<option name="MOON"			/>
		<option name="IO"			/>
		<option name="EUROPA"			/>
		<option name="TITAN"			/>
		<option name="ENCELADUS"		/>
		<option name="HALLEY"			/>
		<option name="COMET1P"			/>
		<option name="BORRELLY"			/>
		<option name="COMET19P"			/>
		<option name="CHURYUMOVGERASIMENKO"	/>
		<option name="COMET67P"			/>
		<option name="HALEBOPP"			/>
	</parameter>
	<if expr="$NamePlanet eq 'NEW'">
		<parameter name="RadiusPlanet" type="real" min="0" />
		<parameter name="MassPlanet"   type="real" min="0" />
		<parameter name="OmegaPlanet"  type="real" min="0" />
		<parameter name="TiltRotation" type="real" min="0" />
		<parameter name="TypeBField"   type="string" input="select">
			<option name="NONE" />
			<option name="DIPOLE" default="T" />
		</parameter>
	</if>
	<if expr="$TypeBField eq 'DIPOLE'">
		<parameter name="MagAxisThetaGeo" type="real" 
						min="0" max="180"/>
		<parameter name="MagAxisPhiGeo"   type="real"
						min="0" max="360"/>
		<parameter name="DipoleStrength"  type="real"    />
	</if>
	<rule expr="not $PlanetCommand">
		PLANET should precede $PlanetCommand
	</rule>

#PLANET
NEW			NamePlanet (rest of parameters read for unknown planet)
6300000.0		RadiusPlanet [m]
5.976E+24		MassPlanet   [kg]
0.000000199		OmegaPlanet  [radian/s]
23.5			TiltRotation [degree]
DIPOLE			TypeBField
11.0			MagAxisThetaGeo [degree]
289.1			MagAxisPhiGeo   [degree]
-31100.0E-9		DipoleStrength  [T]

The NamePlanet parameter contains the name of the planet
with arbitrary capitalization. In case the name of the planet
is not recognized, the following variables are read:
RadiusPlanet is the radius of the planet,
MassPlanet is the mass of the planet, 
OmegaPlanet is the angular speed relative to an inertial frame, and
TiltRotation is the tilt of the rotation axis relative to ecliptic North,
TypeBField, which can be "NONE" or "DIPOLE". 
TypeBField="NONE" means that the planet does not have magnetic field. 
If TypeBField is set to "DIPOLE" then the following variables are read:
MagAxisThetaGeo and MagAxisPhiGeo are the colatitude and longitude
of the north magnetic pole in corotating planetocentric coordinates.
Finally DipoleStrength is the equatorial strength of the magnetic dipole
field. The units are indicated in the above example, which shows the
Earth values approximately.

The default value is NamePlanet="Earth". Although many other planets
and some of the moons are recognized, some of the parameters, 
like the equinox time are not yet properly set.
</command>

<command name="ROTATIONAXIS" if="$_IsStandAlone">
	<parameter name="IsRotAxisPrimary" type="logical" default="T" />
	<if expr="$IsRotAxisPrimary">
		<parameter name="RotAxisTheta" type="real" min="0" max="180"/>
		<parameter name="RotAxisPhi"   type="real" min="0" max="360"/>
	</if>
	<set name="PlanetCommand" type="string" value="ROTATIONAXIS" />

#ROTATIONAXIS
T			IsRotAxisPrimary (rest of parameters read if true)
23.5			RotAxisTheta
198.3			RotAxisPhi

If the IsRotAxisPrimary variable is false, the rotational axis
is aligned with the magnetic axis. If it is true, the other two variables
are read, which give the position of the rotational axis at the
initial time in the GSE coordinate system. Both angles are read in degrees
and stored internally in radians.

The default is to use the true rotational axis determined by the
date and time given by #STARTTIME.
</command>

<command name="ROTATION" if="$_IsStandAlone">
	<parameter name="UseRotation" type="logical" default="T" />
	<if expr="$UseRotation">
		<parameter name="RotationPeriod" type="real" />
	</if>
	<set name="PlanetCommand" type="string" value="ROTATION" />

#ROTATION
T			UseRotation
24.06575		RotationPeriod [hour] (read if UseRotation is true)

If UseRotation is false, the planet is assumed to stand still, 
and the OmegaPlanet variable is set to zero. 
If UseRotation is true, the RotationPeriod variable is read in hours, 
and it is converted to the angular speed OmegaPlanet given in radians/second.
Note that OmegaPlanet is relative to an inertial coordinate system,
so the RotationPeriod is not 24 hours for the Earth, but the
length of the astronomical day.

The default is to use rotation with the real rotation period of the planet.
</command>

<command name="MAGNETICAXIS" if="$_IsStandAlone">
	<parameter name="IsMagAxisPrimary" type="logical" default="T" />
	<if expr="$IsMagAxisPrimary">
		<parameter name="MagAxisTheta" type="real" min="0" max="180"/>
		<parameter name="MagAxisPhi"   type="real" min="0" max="360"/>
	</if>
	<set name="PlanetCommand" type="string" value="MAGNETICAXIS" />

#MAGNETICAXIS
T			IsMagAxisPrimary (rest of parameters read if true)
34.5			MagAxisTheta [degree]
0.0			MagAxisPhi   [degree]

If the IsMagAxisPrimary variable is false, the magnetic axis
is aligned with the rotational axis. If it is true, the other two variables
are read, which give the position of the magnetic axis at the
initial time in the GSE coordinate system. Both angles are read in degrees
and stored internally in radians.

The default is to use the true magnetic axis determined by the
date and time given by #STARTTIME.
</command>

<command name="MAGNETICCENTER" if="$_IsStandAlone">
	<parameter name="MagCenterX" type="real" default="0.0" />
	<parameter name="MagCenterY" type="real" default="0.0" />
	<parameter name="MagCenterZ" type="real" default="0.0" />
	<set name="PlanetCommand" type="string" value="MAGNETICCENTER" />

#MAGNETICCENTER
0.1			MagCenterX
-0.02			MagCenterY
0.0			MagCenterZ

Shifts the magnetic center (e.g. the center of the dipole) to the location
given by the three parameters. The default is no shift 
(at least for most planets).
</command>

<command name="DIPOLE" if="$_IsStandAlone">
	<parameter name="DipoleStrength" type="real" />

#DIPOLE
-3.11e-5		DipoleStrength [Tesla]

The DipoleStrength variable contains the
magnetic equatorial strength of the dipole magnetic field in Tesla.

The default value is the real dipole strength for the planet.
For the Earth the default is taken to be -31100 nT.
The sign is taken to be negative so that the magnetic axis can
point northward as usual.
</command>

<command name="UPDATEB0" if="$_IsStandAlone">
	<parameter name="DtUpdateB0" type="real" min="-1" default="0.0001" />

The DtUpdateB0 variable determines how often the position of
the magnetic axis is recalculated. A negative value indicates that
the motion of the magnetic axis during the course of the simulation
is neglected. This is an optimization parameter, since recalculating
the values which depend on the orientation of the magnetic
field can be costly. Since the magnetic field moves relatively
slowly as the planet rotates around, it may not be necessary
to continuously update the magnetic field orientation.

The default value is 0.0001, which means that the magnetic axis
is continuously followed.
</command>

<command name="IDEALAXES" if="$_IsStandAlone">

#IDEALAXES

The #IDEALAXES command has no parameters. It sets both the rotational
and magnetic axes parallel with the ecliptic North direction. In fact
it is identical with the commands:

#ROTATIONAXIS
T               IsRotAxisPrimary
0.0             RotAxisTheta
0.0             RotAxisPhi

#MAGNETICAXIS
F               IsMagAxisPrimary

but much shorter.
</command>

</commandgroup>

<commandgroup name="USER DEFINED INPUT">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!  USER DEFINED INPUT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

<command name="USERFLAGS" alias="USER_FLAGS">
	<parameter name="UseUserInnerBcs"          type="logical" default="F"/>
	<parameter name="UseUserSource"	           type="logical" default="F"/>
	<parameter name="UseUserPerturbation"      type="logical" default="F"/>
	<parameter name="UseUserOuterBcs"          type="logical" default="F"/>
	<parameter name="UseUserICs"               type="logical" default="F"/>
	<parameter name="UseUserSpecifyRefinement" type="logical" default="F"/>
	<parameter name="UseUserLogFiles"          type="logical" default="F"/>
	<parameter name="UseUserWritePlot"         type="logical" default="F"/>
	<parameter name="UseUserAMR"               type="logical" default="F"/>
	<parameter name="UseUserEchoInput"         type="logical" default="F"/>
	<parameter name="UseUserB0"                type="logical" default="F"/>
	<parameter name="UseUserInitSession"       type="logical" default="F"/>
	<parameter name="UseUserUpdateStates"      type="logical" default="F"/>

#USERFLAGS
F			UseUserInnerBcs
F			UseUserSource
F			UseUserPerturbation
F                       UseUserOuterBcs
F                       UseUserICs
F                       UseUserSpecifyRefinement
F                       UseUserLogFiles
F                       UseUserWritePlot
F                       UseUserAMR
F                       UseUserEchoInput
F                       UseUserB0
F                       UseUserInitSession
F                       UseUserUpdateStates

This command controls the use of user defined routines in ModUser.f90.
For each flag that is set, an associated routine will be called in 
the user module.  Default is .false. for all flags.
</command>

<command name="USERINPUTBEGIN" multiple="T">

#USERINPUTBEGIN

This command signals the beginning of the section of the file which 
is read by the subroutine user\_read\_inputs in the ModUser.f90 file.
The section ends with the #USERINPUTEND command. 
There is no XML based parameter checking in the user section.
</command>

<command name="USERINPUTEND" multiple="T">

#USERINPUTEND

This command signals the end of the section of the file which 
is read by the subroutine user\_read\_inputs in the ModUser.f90 file.
The section begins with the #USERINPUTBEGIN command. 
There is no XML based parameter checking in the user section.
</command>

</commandgroup>

<commandgroup name="TESTING AND TIMING">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!  TESTING AND TIMING PARAMETERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="TEST">
	<parameter name="TestString" type="string" length="100"/>
#TEST
read_inputs

A space separated list of subroutine names. Default is empty string.

Examples:\\
  read_inputs  - echo the input parameters following the #TEST line\\
  project_B    - info on projection scheme\\
  implicit     - info on implicit scheme\\
  krylov       - info on the Krylov solver\\
  message_count- count messages\\
  initial_refinement\\
  ...

Check the subroutines for call setoktest("...",oktest,oktest_me) to
see the appropriate strings.
</command>

<command name="TESTIJK">
	<parameter name="iTest"      type="integer" min="-2"
		max="$_GridSize[0]+2" default="1" />
	<parameter name="jTest"      type="integer" min="-2"
		max="$_GridSize[1]+2" default="1" />
	<parameter name="kTest"      type="integer" min="-2"
		max="$_GridSize[2]+2" default="1" />
	<parameter name="iBlockTest" type="integer" min="1"
		max="$_GridSize[3]"   default="1" />
	<parameter name="iProcTest"  type="integer" min="0" />
#TESTIJK
1                       iTest           (cell index for testing)
1                       jTest           (cell index for testing)
1                       kTest           (cell index for testing)
1                       iBlockTest      (block index for testing)
0                       iProcTest       (processor index for testing)

The location of test info in terms of indices, block and processor number.
Note that the user should set #TESTIJK or #TESTXYZ, not both.  If both
are set, the final one in the session will set the test point.
</command>

<command name="TESTXYZ">
	<parameter name="xTest" type="real" 
				min="$xMin" max="$xMax" />
	<parameter name="yTest" type="real" 
				min="$yMin" max="$yMax" />
	<parameter name="zTest" type="real" 
				min="$zMin" max="$zMax" />
#TESTXYZ
1.5                     xTest           (X coordinate of cell for testing)
-10.5                   yTest           (Y coordinate of cell for testing)
-10.                    zTest           (Z coordinate of cell for testing)

The location of test info in terms of coordinates.
Note that the user should set #TESTIJK or #TESTXYZ, not both.  If both
are set, the final one in the session will set the test point.
</command>

<command name="TESTTIME">
	<parameter name="nIterTest" type="integer" min="-1" default="-1"   />
	<parameter name="TimeTest"  type="real"    min="-1" default="1e30" />

#TESTTIME
-1                      nIterTest       (iteration number to start testing)
10.5                    TimeTest        (time to start testing in seconds)

The time step and physical time to start testing.
</command>

<command name="TESTVAR">
	<parameter name="iVarTest" type="integer" min="1" default="1"/>
#TESTVAR
1                       iVarTest

Index of variable to be tested. Default is rho_="1", i.e. density.
</command>

<command name="TESTDIM">
	<parameter name="iDimTest" type="integer" input="select">
		<option name="all" value="0" />
		<option name="x"   value="1" default="T" />
		<option name="y"   value="2" />
		<option name="z"   value="3" />
        </parameter>
#TESTDIM
1                       iDimTest

Index of dimension/direction to be tested. Default is X dimension.
</command>

<command name="STRICT" multiple="T">
	<parameter name="UseStrict" type="logical" default="T" />
#STRICT
T                       UseStrict

If true then stop when parameters are incompatible. If false, try to
correct parameters and continue. Default is true, i.e. strict mode
</command>

<command name="VERBOSE">
	<parameter name="lVerbose" type="integer" input="select">
		<option name="errors and warnings only"  value="-1" />
		<option name="start and end of sessions" value="0"  />
		<option name="default"                 value="1" default="T"/>
		<option name="calls on test processor"   value="10" />
		<option name="calls on all processors"   value="100" />
        </parameter>
#VERBOSE
-1                      lVerbose

Verbosity level controls the amount of output to STDOUT. Default level is 1.
\\
  lVerbose $\leq -1$ only warnings and error messages are shown.\\
  lVerbose $\geq  0$ start and end of sessions is shown.\\
  lVerbose $\leq  1$ a lot of extra information is given.\\
  lVerbose $\leq 10$ all calls of set_oktest are shown for the test processor.\\
  lVerbose $\leq 100$ all calls of set_oktest are shown for all processors.\\
</command>

<command name="DEBUG">
	<parameter name="DoDebug"      type="logical" default="F" />
	<parameter name="DoDebugGhost" type="logical" default="F" />
#DEBUG
F                       DoDebug         (use it as if(okdebug.and.oktest)...)
F                       DoDebugGhost    (parameter for show_BLK in library.f90)

Excessive debug output can be controlled by the global okdebug parameter
</command>

<command name="CODEVERSION" if="$_IsFirstSession">
	<parameter name="CodeVersion" min="0" default="7.50" type="real" />
#CODEVERSION
7.50                    CodeVersion

Checks CodeVersion. Prints a WARNING if it differs from the CodeVersion
defined in ModMain.f90. 
</command>

<command name="USERMODULE" if="$_IsFirstSession">
	<parameter name="NameUserModule" type="string" length="100"
						default="EMPTY" />
	<parameter name="VersionUserModule" type="real" min="0" 
						default="1.0" />

#USERMODULE
TEST PROBLEM Smith
1.3			VersionUserModule

Checks the selected user module. If the name or the version number
differs from that of the compiled user module, a warning is written,
and the code stops in strict mode (see #STRICT command). 
This command and its parameters are written into the restart header file too,
so the user module is checked when a restart is done. 
There are no default values. If the command is not present, the user 
module is not checked.
</command>

<command name="EQUATION" if="$_IsFirstSession">
	<parameter name="NameEquation" type="string" length="100" 
						default="MHD" />
	<parameter name="nVar" type="integer" default="8" />
#EQUATION
MHD			NameEquation
8			nVar

Define the equation name and the number of variables.
If any of these do not agree with the values determined 
by the code, BATSRUS stops with an error. Used in restart
header files and can be given in PARAM.in as a check
and as a description.
</command>

<command name="PRECISION" if="$_IsFirstSession">
	<parameter name="nByteReal" type="integer" input="select">
		<option name="single precision" value="4" 
			default="$_nByteReal==4"/>
		<option name="double precision" value="8"
			default="$_nByteReal==8" />
	</parameter>
	<rule expr="$nByteReal==$_nByteReal or not $UseStrict">
		nByteReal in file must agree with _nByteReal in strict mode.
	</rule>

#PRECISION
8                       nByteReal

Define the number of bytes in a real number. If it does not agree
with the value determined by the code, BATSRUS stops with an error
unless the strict mode is switched off.
This is used in restart header files to store (and check) the precision
of the restart files. It is now possible to read restart files with
a precision that differs from the precision the code is compiled with,
but strict mode has to be switched off with the #STRICT command.
The #PRECISION command may also be used to enforce a certain precision.
</command>

<command name="CHECKGRIDSIZE" if="$_IsFirstSession">
	<parameter name="nI" type="integer" default="8"
		min="$_GridSize[0]" max="$_GridSize[0]" />
	<parameter name="nJ" type="integer" default="8"
		min="$_GridSize[1]" max="$_GridSize[1]" />
	<parameter name="nK" type="integer" default="8"
		min="$_GridSize[2]" max="$_GridSize[2]" />
	<parameter name="MinBlockALL" type="integer" default="4000"
		min="1" max="$MaxBlockALL" />

#CHECKGRIDSIZE
       4                        nI
       4                        nJ
       4                        nK
     576                        MinBlockALL

Checks block size and number of blocks. Stops with an error message,
if nI, nJ, or nK differ from those set in ModSize. 
Also stops if number_of_blocks exceeds nBLK*numprocs, where nBLK 
is defined in ModSize and numprocs is the number of processors.
This command is used in the restart headerfile to check consistency,
and it is also useful to check if the executable is consistent with the 
requirements of the problem described in the PARAM.in file.
</command>

<command name="BLOCKLEVELSRELOADED">
#BLOCKLEVELSRELOADED

This command means that the restart file contains the information about
the minimum and maximum allowed refinement levels for each block.
This command is only used in the restart header file.
</command>

<command name="TIMING" if="$_IsStandAlone">
	<parameter name="UseTiming" type="logical" default="T" />
	<if expr="$UseTiming">
		<parameter name="DnTiming" type="integer" min="-3" 
							default="-2" />
		<parameter name="nDepthTiming" type="integer" min="-1" 
							default="-1" />
		<parameter name="TypeTimingReport" type="string" 
							input="select">
			<option name="cumulative" value="cumu" default="1" />
			<option name="list" />
			<option name="tree" />
		</parameter>
	</if>
#TIMING
T                       UseTiming      (rest of parameters read if true)
-2                      DnTiming       (-3 none, -2 final, -1 each session)
-1                      nDepthTiming   (-1 for arbitrary depth)
cumu                    TypeTimingReport   ('cumu', 'list', or 'tree')

This command can only be used in stand alone mode. In the SWMF the
#TIMING command should be issued for CON.

If UseTiming=.true., the TIMING module must be on.
If UseTiming=.false., the execution is not timed.

Dntiming determines the frequency of timing reports.
If DnTiming .ge.  1, a timing report is produced every dn_timing step.
If DnTiming .eq. -1, a timing report is shown at the end of each session.
If DnTiming .eq. -2, a timing report is shown at the end of the whole run.
If DnTiming .eq. -3, no timing report is shown.

nDepthTiming determines the depth of the timing tree. A negative number
means unlimited depth. If TimingDepth is 1, only the full BATSRUS execution
is timed.

TypeTimingReport determines the format of the timing reports:
'cumu' - cumulative list sorted by timings
'list' - list based on caller and sorted by timings
'tree' - tree based on calling sequence

The default values are shown above.
</command>

</commandgroup>
<commandgroup name="INITIAL AND BOUNDARY CONDITIONS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!! MAIN INITIAL AND BOUNDARY CONDITION PARAMETERS  !!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="NORMALIZATION" if="$_IsFirstSession">
	<parameter name="TypeNormalization" type="string" case="upper"
		input="select">
		<option name="SI"/>
		<option name="PLANETARY" default="T"/>
		<option name="SOLARWIND"/>
		<option name="NONE"/>
		<option name="USER"/>
                <option name="READ"/>
	</parameter>
	<if expr="$TypeNormalization =~ /READ/">
		<parameter name="No2SiUnitX" type="real" min="0" default="1"/>
		<parameter name="No2SiUnitU" type="real" min="0" default="1"/>
		<parameter name="No2SiUnitRho" type="real" min="0" 
								default="1"/>
	</if>
#NORMALIZATION
READ			TypeNormalization
1000.0			No2SiUnitX   (only read if TypeNormalization=READ)
1000.0			No2SiUnitU   (only read if TypeNormalization=READ)
1.0e-6			No2SiUnitRho (only read if TypeNormalization=READ)

This command determines what units are used internally in BATSRUS.
The units are normalized so that several physical constants become
unity (e.g. the permeability of vacuum), so the equations are simpler
in the code. The normalization also helps to keep the various
quantities within reasonable ranges. For example density of space
plasma is very small in SI units, so it is better to use some normalization,
like amu/cm$^3$. Also note that distances and positions (like grid size,
grid resolution, plotting resolution, radius of the inner body etc) 
are always read in normalized units from the PARAM.in file.
Other quantities are read in I/O units (see the #IOUNITS command).

The normalization of the distance, velocity and density are 
determined by the TypeNormalization parameter. The normalization
of all other quantities are derived from these three values.
It is important to note that the normalization of number density
(defined as the density normalization divided by the proton mass)
is usually not consistent with the inverse cube of the normalization 
of distance. 

Possible values for TypeNormalization are NONE, PLANETARY, SOLARWIND, 
USER and READ. 

If TypeNormalization="NONE" then the distance, velocity and density
units are the SI units, i.e. meter, meter/sec, and kg/m$^3$.
Note that the magnetic field and the temperature are still normalized
differently from SI units so that the Alfven speed is $B/\sqrt{\rho}$
and the ion temperature is simply $p/(\rho/AverageIonMass)$,
where the AverageIonMass is given relative to the mass of proton.

If TypeNormalization="PLANETARY" then the distance unit is the
radius of the central body (moon, planet, or the Sun). If there is
no central body, the length normalization is 1km. The velocity unit
is km/s, and the density unit is amu/cm3.

If TypeNormalization="SOLARWIND" then the distance unit is the 
same as for PLANETARY units, but the velocity and density are normalized to
the density and the sound speed of the solar wind. This normalization
is very impractical, because it depends on the solar wind values
that are variable, and may not even make sense (e.g. for a shock tube test
or a Tokamak problem). This normalization is only kept for sake of 
backwards compatibility.

If TypeNormalization="USER" the normalization is set in the user module.
This may be useful if the normalization depends on some input parameters.

Finally TypeNormalization="READ" reads the three basic normalization units from
the PARAM.in file as shown in the example. This allows arbitrary normalization.

The restart header file saves the normalization with TypeNormalization="READ"
and the actual values of the distance, velocity and density normalization
factors. This avoids the problem of continuing the run with inconsistent
normalization (e.g. if the SOLARWIND normalization is used and the
solar wind parameters have been changed). It also allows other programs
to read the data saved in the restart files and convert them to appropriate
units. 

The default normalization is PLANETARY for GM 
and SOLARWIND for all other components.
</command>

<command name="IOUNITS" if="$_IsFirstSession">
	<parameter name="TypeIoUnit" type="string" input="select">
		<option name="SI"/>
		<option name="PLANETARY"    default="$NameComp eq 'GM'"/>
		<option name="HELIOSPHERIC" default="$NameComp ne 'GM'"/>
		<option name="NONE"/>
		<option name="USER"/>
	</parameter>
#IOUNITS
PLANETARY			TypeIoUnit

This command determines the physical units of various parameters read from the
PARAM.in file and written out into log files and plot files (if they are
dimensional. The units are determined by the TypeIoUnit string.
Note that distances and positions are always read in normalized units from 
PARAM.in but they are written out in I/O units. 
In most cases the two coincides.

Also note that the I/O units are NOT necessarily physically consistent units. 
For example one cannot divide distance with time and compare it with
the velocity because they may be in inconsistent units. 
One needs to convert into some consistent units before the various quantities 
can be combined.

If TypeIoUnits="SI" the input and output values are taken in SI units
(m, s, kg, etc).

The PLANETARY units use the radius of the planet for distance, 
seconds for time, amu/cm$^3$ for mass density, cm$^-3$ for number denisty, 
km/s for speed, nPa for pressure, nT for magnetic field, micro Amper/m$^2$ 
for current density, mV/m for electric field, nT/planet radius for div B,
and degrees for angles. For any other quantity SI units are used.
If there is no planet (see the #PLANET command) then the distance
unit is 1 km.

The HELIOSPHERIC units use the solar radius for distance, seconds for time,
km/s for velocity, degrees for angle, and
CGS units for mass density, number density, pressure,
magnetic field, momentum, energy density, current, and div B.

When TypeIoUnit="NONE" the input and output units are the same as
the normalized units (see the #NORMALIZATION command).

Finally when TypeIoUnit="USER", the user can modify the I/O units 
(Io2Si_V) and the names of the units (NameTecUnit_V and NameIdlUnit_V)
in the subroutine user_io_units of the user module.
Initially the values are set to SI units.

The #IOUNITS command and the value of TypeIoUnits is saved into the 
restart header file so that one continues with the same I/O units 
after restart.

The default is "PLANETARY" unit if BATSRUS is used as the GM component
and "HELIOSPHERIC" otherwise (EE, SC, IH or OH). 
</command>

<command name="RESTARTINDIR" if="$_IsFirstSession">
	<parameter name="NameRestartInDir" type="string" length="100"
				default="GM/restartIN" />
	<rule expr="-d $NameRestartInDir">
		Restart input directory $NameRestartInDir must exist!
	</rule>

#RESTARTINDIR
GM/restart_n5000	NameRestartInDir

The NameRestartInDir variable contains the name of the directory
where restart files are saved relative to the run directory.
The directory should be inside the subdirectory with the name 
of the component.

Default value is "GM/restartIN".
</command>

<command name="RESTARTINFILE" if="$_IsFirstSession">
	<parameter name="StringRestartInFile" type="strings" min="1" max="2">
		<part name="TypeRestartInFile" type="string" input="select" 
								required="T">
			<option name="single data.rst file" value="one"/>
			<option name="separate files/proc"  value="proc"/>
			<option name="separate files/block" value="block"
								default="T"/>
		</part>
		<part name="StringSeries" type="string" input="select"
								required="F">
			<option name="series"/>
		</part>
	</parameter>

#RESTARTINFILE
one series			TypeRestartInFile

This command is saved in the restart header file which is included during
restart, so normally the user does not have to use this command at all.
The TypeRestartInFile parameter describes how the restart data was saved: 
into separate files for each processor ('proc'),
into separate files for each grid block ('block')
or into a single direct access file ('one').
The optional 'series' string means that a series of restart files
were saved with the iteration number added to the beginning of the file names.

The default value is 'block' for sake of backwards compatibility.
</command>

<command name="NEWRESTART" if="$_IsFirstSession">
	<parameter name="DoRestartBFace" type="logical" default="F" />

#NEWRESTART
T		DoRestartBFace

The RESTARTINDIR/restart.H file always contains the #NEWRESTART command.
This command is really used only in the restart headerfile.  Generally
it is not inserted in a PARAM.in file by the user.

The #NEWRESTART command sets the following global variables:
DoRestart=.true. (read restart files),
DoRestartGhost=.false.  (no ghost cells are saved into restart file)
DoRestartReals=.true.   (only real numbers are saved in blk*.rst files).

The DoRestartBFace parameter tells if the face centered magnetic field
is saved into the restart files. These values are used by the 
Constrained Transport scheme.
</command>

<command name="OUTERBOUNDARY">
	<foreach name="Side" values=
	"TypeBcEast,TypeBcWest,TypeBcSouth,TypeBcNorth,TypeBcBot,TypeBcTop">
		<parameter name="$Side" type="string" input="select">
			<option name="inflow/vary"
					default="$Side eq 'TypeBcWest'" />
			<option name="float/outflow"
					default="$Side ne 'TypeBcWest'" />
			<option name="heliofloat"/>
			<option name="reflect"/>
			<option name="periodic"/>
			<option name="fixed"/>
			<option value="fixedb1" name="fixed B1"/>
			<option name="shear"/>
			<option name="linetied"/>
			<option name="raeder"/>
			<option name="user"/>
			<option name="coupled" />
			<option name="none" />
			<option name="ihbuffer" />
		</parameter>
	</foreach>
	<rule
	expr="not($TypeBcEast eq 'periodic' xor $TypeBcWest eq 'periodic')">
		East and west BCs must be both periodic or neither
	</rule>
	<rule
	expr="not($TypeBcSouth eq 'periodic' xor $TypeBcNorth eq 'periodic')">
		South and North BCs must be both periodic or neither
	</rule>
	<rule
	expr="not($TypeBcBot eq 'periodic' xor $TypeBcTop eq 'periodic')">
		Bottom and top BCs must be both periodic or neither
	</rule>
#OUTERBOUNDARY
outflow                 TypeBcEast
inflow                  TypeBcWest
float                   TypeBcSouth
float                   TypeBcNorth
float                   TypeBcBottom
float                   TypeBcTop

Default depends on problem type.\\
Possible values:
\begin{verbatim}
coupled       - GM coupled to the IH component (at the 'west' boundary)
fixed         - fixed solarwind values
fixedB1       - fixed solarwind values without correction for the dipole B0
float/outflow - zero gradient
heliofloat    - floating for the SC component (requires #FACEOUTERBC)
linetied      - float P, rho, and B, reflect all components of U
raeder        - Jimmy Raeder's BC
reflect       - reflective
periodic      - periodic
vary/inflow   - time dependent BC (same as fixed for non time_accurate)
shear         - sheared (intended for shock tube problem only)
arcadetop     - intended for arcade problem only
arcadebot     - intended for arcade problem only
arcadebotcont - intended for arcade problem only
user          - user defined
\end{verbatim}
</command>

<command name="OUTFLOWPRESSURE">
	<parameter name="UseOutflowPressure" type="logical" default="F"/>
	<parameter name="pOutflowSi" type="real" min="0" defaulte="1e5"
						if="$UseOutflowPressure"/>

#OUTFLOWPRESSUURE
T			UseOutflowPressure
1e5			pOutflowSi (read if UseOutflowPressure is true)

Set pressure for "outflow" boundary condition. This matters for
subsonic outflow. Default is UseOutflowPressure=.false.
</command>

<command name="INNERBOUNDARY">
	<parameter name="TypeBcInner" type="string" case="lower"
	input="select">
		<option name="reflect"				/>
		<option name="float"				/>
		<option name="fixed"				/>
		<option name="ionosphere"	default="T"	/>
		<option name="ionosphereb0"			/>
		<option name="ionospherefloat"			/>
		<option name="buffergrid"			/>
		<option name="polarwind"			/>
		<option name="ionosphereoutflow"		/>
		<option name="user"				/>
	</parameter>
	<if expr="$UseBody2">
		<parameter name="TypeBcBody2" type="string" case="lower"
		input="select">
			<option name="reflect"		default="T"	/>
			<option name="float"				/>
			<option name="fixed"				/>
			<option name="ionosphere"			/>
			<option name="ionosphereb0"			/>
			<option name="ionospherefloat"			/>
		</parameter>
	</if>
	<rule
	expr="not($TypeBcBody2 =~ /ionosphere/)"> 
	For the second body COROTATION AND AN IONOSPHERIC BOUNDARY DO NOT WORK.
	</rule>
#INNERBOUNDARY
ionosphere              TypeBcInner
ionosphere              TypeBcBody2  !read only if UseBody2=T

This command should appear after the #SECONDBODY command when using 
two bodies. Note: for the second body COROTATION AND AN IONOSPHERIC 
BOUNDARY DO NOT WORK.

Default value for TypeBcBody2 is 'reflect'.

Possible values for TypeBcInner are:
\begin{verbatim}
'reflect'         - reflect Vr, reflect Vphi to rotation, float Vtheta,
                    reflect Br, float Bphi, float Btheta, float rho, float P
'float'           - float Vr, reflect Vphi to rotation, float Vtheta,
                    float B, float rho, float P
'fixed'           - Vr=0, Vphi=rotation, Vtheta=0
                    B=B0 (ie B1=0), fix rho, fix P
'ionosphere'      - set V as if ionosphere gave V_iono=0
                    float B, fix rho, float P
'ionospherefloat' - set V as if ionosphere gave V_iono=0
                    float B, float rho, float P
'buffergrid'      - IH(OH) component obtains inner boundary from the SC(IH)
		    component, through a buffer grid. The buffer grid is set
		    by the #BUFFERGRID or #HELIOBUFFERGRID commands.
'polarwind'       - GM component obtains the inner boundary from PW component
'ionosphereoutflow' - empirical inner boundary setup in (Hp,Op,All) multifluid
'user'            - user defined
\end{verbatim}
For 'ionosphere' and 'ionospherefloat' types and a coupled GM-IE run,
the velocity at the inner boundary is determined by the ionosphere model.

The boundary condition on Br can be changed with the #MAGNETICINNERBOUNDARY
command.

Default value for TypeBcInner is 'ionosphere' for the GM component,
and 'unknown' for the EE, SC, IH and OH components, so the inner boundary 
must be set for these components.
</command>

<command name="MAGNETICINNERBOUNDARY">
	 <parameter name="DoReflectInnerB1" type="logical" default="F"/>

#MAGNETICINNERBOUNDARY
T		DoReflectInnerB1

If DoReflectInnerB1 is true, the B1 part of the magnetic field is reflected
for the ionosphere type inner boundary conditions, i.e. the radial 
component of the total magnetic field is forced to coincide with the B0
value.

The default value is DoReflectInnerB1 false, which makes B1 float.
</command>

<command name="BUFFERGRID">
	 <parameter name="nRBuff" type="integer" min="2" default="2" />
	 <parameter name="nPhiBuff" type="integer" min="2" default="90" />
	 <parameter name="nThetaBuff" type="integer" min="2" default="45" />
	 <parameter name="rBuffMin" type="real" min="1" default="19" />
	 <parameter name="rBuffMax" type="real" min="$rBuffMin" default="21" />
	 <parameter name="PhiBuffMin" type="real" min="0" max="360"
	 	    		      		  	   default="0" />
	 <parameter name="PhiBuffMax" type="real" min="$PhiBuffMin" max="360"
	 	    		      		  	   default="360" />
	 <parameter name="LatBuffMin" type="real" min="-90" max="90"
	 	    		      		  	   default="-90" />
         <parameter name="LatBuffMax" type="real" min="$LatBuffMin" max="90"  
	 	    		      		  	   default="90" />

#BUFFERGRID
2	nRBuff
90	nPhiBuff
45	nThetaBuff
19.0	rBuffMin
21	rBuffMax
0.0	PhiBuffMin
360.0	PhiBuffMax
-90.0	LatBuffMin
90.0	LatBuffMax

Define the radius, angular extent and the grid resolution of the
uniform spherical buffer grid used to pass information between two
coupled components running BATSRUS. 

The parameters nRBuff, nPhiBuff and nThetaBuff determine the number of
points in the radial, azimuthal and latitudinal directions,
respectively.

The parameters rBuffMin and rBuffMax determine the inner and outer
radii of the spherical shell.

PhiBuffMin, PhiBuffMax, LatBuffMin and LatBuffMax determine the
limits (in degrees) of the buffer grid in the azimuthal and
latitudinal directions. 

When used to pass information from the SC(IH)
component to the IH(OH) component, the entire shperical shell should
be used (alternativly, use the #HELIOBUFFERGRID command), but in
certain application only a part of the shell may be needed. The buffer
should be placed in a region where the two components overlap, and the
grid resolution should be similar to the grid resolution of the
coarser of the two component grids.  This command can only be used in
the first session by the IH(OH) component.  The buffer grid will only
be used if 'buffergrid' is chosen for TypeBcInner in the
#INNERBOUNDARY command of the target component.  Default values are
shown above.

</command>

<command name="EXTRABOUNDARY">
	<parameter name="UseExtraBoundary" type="logical" default="F"/>
	<if expr="$UseExtraBoundary">
		<parameter name="TypeExtraBoundary" type="string"/>
	</if>

#EXTRABOUNDARY
T		UseExtraBoundary
user		TypeExtraBoundary

If UseExtraBoundary is true, the user can define an extra boundary
condition in the user files. The TypeExtraBoundary parameter can be used
to select from multiple boundary conditions implemented in the user module.
</command>

<command name="FACEBOUNDARY" if="$_IsFirstSession">
	<parameter name="MinFaceBoundary" type="integer" min="-2" max="6"
							default="-1" />
	<parameter name="MaxFaceBoundary" type="integer" min="-2" max="6"
							default="0" />
#FACEBOUNDARY
6		MinFaceBoundary
-2		MaxFaceBoundary

General notes: face based boundary conditions are 1st order accurate 
in general, while cell based boundary conditions can be 2nd order accurate.
Sometimes, however, it is easier to define a face value than the state 
of the ghost cells that are outside the computational domain. Depending
on the shape of the boundary it can also happen that the same ghost cell
is used by multiple physical cells and this may be a problem. In our
current implementation cell based boundaries can be used only when the
physical boundary coincides with the boundary of the grid blocks.

Face based boundaries are allowed even when the physical boundary cuts
through the grid blocks. In this case each cell center is marked as either
physical or boundary cell, and the boundary conditions are applied at 
cell faces between a physical and a boundary cell center.

For Cartesian coordinates the inner (body2=-2 and body1=-1) 
and extra (0) boundaries have to be face based because these are
not aligned with the block boundaries.
The outer boundaries (east=1 to top=6) are cell based by default,
but they can also be face based if desired.

For spherical and cylindircal grids the default is face based boundaries
everywhere. The outer boundaries have to be face based if a brick-shaped
computational domain is cut out from the sphere/cylinder 
(see the #LIMITRADIUS and #GRID commands) because the boundary is
not aligned with the block boundaries.
If the computational domain is the full sphere/cylinder, then
cell based boundaries can be used (by applying this command).
For spherical grids the 'inner boundary' is simply at the minimum radius
that normally coincides with the body radius, therefore it can be cell or 
face based. 

This command allows setting the first and the last boundaries that are
handled as faces. It also allows switching off the face boundary 
conditions for generalized coordinate grids (as shown by the example). 
</command>

<command name="POLARBOUNDARY">
	<parameter name="PolarNDim" type="real" min="0" default="20"/>
	<parameter name="PolarTDim" type="real" min="0" default="1e5"/>
	<parameter name="PolarUDim" type="real" min="0" default="1"/>
	<parameter name="PolarLatitude" type="real" min="0" default="75"/>
#POLARBOUNDARY
20.0		PolarNDim [amu/cc] for fluid 1
100000.0	PolarTDim [K]      for fluid 1
1.0		PolarUDim [km/s]   for fluid 1
2.0		PolarNDim [amu/cc] for fluid 2
20000.0		PolarTDim [K]      for fluid 2
1.5		PolarUDim [km/s]   for fluid 2
75.0		PolarLatitude [deg] 

This command defines the boundary conditions in the polar region. The number 
density, temperature and velocity can be given (for all fluids in multifluid
calculations). This mimics polar wind like inner boundary
conditions when GM is not coupled with the PW component. 
The PolarLatitude parameter determines the latitudinal extent 
of the polar boundary where the outflow is defined.
</command>

<command name="CPCPBOUNDARY">
	<parameter name="UseCpcpBc" type="logical" default="F"/>
	<if expr="$UseCpcpBc">
	    <parameter name="Rho0Cpcp" type="real" min="0" default="18"/>
	    <parameter name="RhoPerCpcp" type="real" min="0" default="0.2"/>
	</if>
#CPCPBOUNDARY
T                       UseCpcpBc  (rest is read if true)
28.0                    Rho0Cpcp   [amu/cc]
0.1                     RhoPerCpcp [amu/cc / kV]

This command only works for single fluid MHD. The inner boundary type has to
be "ionosphere" and the GM and IE components have to be coupled together.

If UseCpcpBc is true, the density at the inner boundary will depend on 
the cross polar cap potential (CPCP) in a linear fashion:

RhoBc = Rho0Cpcp + RhoPerCpcp * Cpcp

where RhoBc and Rho0Cpcp are in I/O units (typically amu/cc), the 
Cpcp is given in [kV], and the RhoPerCpcp factor is in density units per kV. 
The Cpcp is the average of the northern and southern CPCPs. 
The example shows some reasonable values. For CPCP = 0 kV RhoBc = 28 amu/cc,
while for CPCP = 400 kV RhoBc = 68 amu/cc.

By default the density at the inner boundary is determined by the body 
density given in the #BODY (same as #MAGNETOSPHERE) command.
</command>

<command name="IMCOUPLINGSMOOTH">
	<parameter name="dLatSmoothIm" type="real" min="-1" default="-1"/>

#IMCOUPLINGSMOOTH
10.0			dLatSmoothIm [deg]

Smooth out the pressure nudging at the edge of the RCM boundary. 
Default is -1.0, which means no smoothing.
</command>

</commandgroup>

<commandgroup name="GRID GEOMETRY">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!! GRID GEOMETRY !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

<command name="GRID" required="$_IsFirstSession" if="$_IsFirstSession">
	<parameter name="nRootBlock1" type="integer" min="1"  default="2" />
	<parameter name="nRootBlock2" type="integer" min="1"  default="1" />
	<parameter name="nRootBlock3" type="integer" min="1"  default="1" />
	<parameter name="xMin"   type="real"             default="-192.0" />
	<parameter name="xMax"   type="real" min="$xMin" default="  64.0" />
	<parameter name="yMin"   type="real"             default=" -64.0" />
	<parameter name="yMax"   type="real" min="$yMin" default="  64.0" />
	<parameter name="zMin"   type="real"             default=" -64.0" />
	<parameter name="zMax"   type="real" min="$zMin" default="  64.0" />

	<rule expr="$xMin != $xMax">
	      xMin has to be smaller than xMax
	</rule>
	<rule expr="$yMin != $yMax">
	      yMin has to be smaller than yMax
	</rule>
	<rule expr="$zMin != $zMax">
	      zMin has to be smaller than zMax
	</rule>

#GRID
2                       nRootBlock1
1                       nRootBlock2
1                       nRootBlock3
-224.                   xMin	   
 32.                    xMax	   
-64.                    yMin	   
 64.                    yMax	   
-64.                    zMin	   
 64.                    zMax

The nRootBlock1, nRootBlock2 and nRootBlock3 parameters define the 
number of blocks of the base grid, i.e. the roots of the octree. 
By varying these parameters, one can setup a grid which is elongated
in some direction. The xMin, ..., zMax parameters define a brick shaped
computational domain. An inner boundary may be cut out from the domain
with the #BODY and/or #LIMITRADIUS commands. It is also possible to define 
a shperical, cylindrical computational domain using 
the #GRIDGEOMETRY and the #LIMITRADIUS commands.

There are no default values, the grid size must always be given in the
first session (even if the component is switched off in the first session!).
</command>

<command name="GRIDSYMMETRY">
	<parameter name="IsMirrorX" type="logical" default="F"/>
	<parameter name="IsMirrorY" type="logical" default="F"/>
	<parameter name="IsMirrorZ" type="logical" default="F"/>

#GRIDSYMMETRY
F			IsMirrorX
T			IsMirrorY
T			IsMirrorZ

For symmetric test problems one can model only a part of the computational
domain. Providing the symmetry directions with this command allows 
the proper calculation of line-of-sight plots.
</command>

<command name="COORDSYSTEM" alias="COORDINATESYSTEM" multiple="T">
	<parameter name="TypeCoordSystem" type="string" input="select">
		<option name="GSM" default="$NameComp eq 'GM'"/>
		<option name="GSE"                            />
		<option name="HGR" default="$NameComp eq 'SC'"/>
		<option name="HGI" default="$NameComp eq 'IH'"/>
		<option name="HGI" default="$NameComp eq 'OH'"/>
		<option name="HGC" 		              />
	</parameter>

#COORDSYSTEM
GSM			TypeCoordSystem

TypeCoordSystem defines the coordinate system for the component.
The coordinate systems are defined in share/Library/src/CON_axes.
Here we provide general suggestions.

For GM (Global Magnetopshere) the default coordinate system is "GSM" 
with the X axis pointing towards the Sun, and the (moving) 
magnetic axis contained in the X-Z plane. The inertial forces are
neglected. The essentially inertial "GSE" system is also available,
but it is not fully tested. 

For SC (Solar Corona) one should always use the corotating HGR system to get 
an accurate solution even for complicated active regions. 
Using an inertial frame would result in huge numerical errors near the Sun.

For time accurate IH solutions (e.g. CME propagation)
one should use the inertial HGI system so the grid can be refined
along the Sun-Earth line.
To obtain a steady state initial condition, the corotating HGC system 
can be used which is aligned with the HGI system for the initial time 
of the simuation (see #STARTTIME command). When the
run is switched to time accurate mode, the coordinate system should be
switched to HGI. The necessary transformation of the velocity 
(adding the corotating velocity) is automatically performed.

For quiet steady state IH solutions the HGR system can be used.
Note however that the corotating systems may not work well if the IH
domain is extended way beyond 1AU, becasue the boundary
condition can become inflow type at the corners of a Cartesian domain.
In this case the inertial HGI system should be used in time accurate mode
even for obtaining the initial state.

For OH one should always use the inertial HGI system. A rotating frame
would have extremeley fast rotational speeds.

Note that the HGR and HGI systems can be rotated with a fixed angle
using the #ROTATEHGR and #ROTATEHGI commands of the SWMF. This can be used to
align the interesting plane of the simulation with the grid.

The default is component dependent: 
"GSM" for GM, "HGR" for SC, and "HGI" for IH and OH.
</command>

<command name="GRIDGEOMETRY" if="$_IsFirstSession">
	<parameter name="TypeGeometry" type="string" input="select">
		<option name="cartesian" default="T"	/>
		<option name="rotatedcartesian"         />
		<option name="rz"                       />
		<option name="cylindrical"		/>
		<option name="cylindrical_lnr"		/>
		<option name="cylindrical_genr"		/>
		<option name="spherical"		/>
		<option name="spherical_lnr"		/>
		<option name="spherical_genr"		/>
	</parameter>
#GRIDGEOMETRY
spherical_lnr			TypeGeometry
		
This command determines the geometry of the grid. Possible values
are Cartesian, rotated Cartesian, RZ geometry, cylindrical and spherical. 
The cylindrical and spherical grids can have logarithmic (cylindrical_lnr and spherical_lnr)
or arbitrarily stretched (spherical_genr, cylindrical_genr) radial coordinates.

The "RZ" geometry is a 2D grid with axial symmetry.
In our particular implementation the "X" axis is the axis of symmetry, 
and the "Y" axis is used for the radial direction.

The spherical coordinates are ordered as r, longitude, latitude. The longitude
is between 0 and 360 degrees, the latitude is between -90 and 90 degrees. The
cylindrical coordinates are r, phi, z with phi between 0 and 360 degrees. 

The rotated Cartesian geometry can be used for debugging the generalized
coordinate code. It allows setting up a Cartesian test on a rotated
generalized coordinate grid. The rotation is around the Z axis
with an angle alpha that has sin(alpha)=0.6 and cos(alpha)=0.8 for sake
of getting nice rational numbers. The PostIDL code unrotates the grid
and the vector variables so it can be directly compared with 
a Cartesian simulation. The initial conditions and the boundary conditions,
however, are not rotated automatically (yet), so they require some attention.

The default is Cartesian geometry.
</command>

<command name="LIMITRADIUS" if="$_IsFirstSession">
	<parameter name="rMin" type="real" default="0"/>
	<parameter name="rMax" type="real" min="$rMin" default="1000"/>
#LIMITRADIUS
 10.0			rMin
100.0			rMax

Note: 
for the #LIMITRADIUS command the linear radii can and should be given even
if TypeGeometry is 'spherical_lnr' with a logarithmic radius 
(see command #GRIDGEOMETRY). 

This command allows setting the mimimum and maximum values for the 
first generalized coordinate (usually the radius). Setting rMin to
a positive value excludes the origin of a spherical grid, 
or the axis of the cylindrical grid. 

The rMax parameter can be used to choose a spherical or cylinrical domain 
instead of the brick defined by the #GRID. To achieve this, rMax has to be
set to a radius that fits inside the brick defined by #GRID.

By default the inner radius is set to the radius of the inner body 
(if it is present, see the #BODY command) and the outer radius is set 
to the largest radial distance of the eight corners of the domain defined 
by the #GRID command. If there is no inner body, the default inner radius
is set to 0.0 for spherical and cylindrical grids, 
and to 1.0 for logarithmic spherical grid.
</command>

<command name="UNIFORMAXIS" if="$_IsFirstSession">
	 <parameter name="UseUniformAxis" type="logical" default="T"/>

#UNIFORMAXIS
T			UseUniformAxis

This command can only be used in the first session. 
If UseUniformAxis is true, there can be no resolution change AROUND the
axis of a spherical or cylindrical grid. This is required by the supercell
algorithm that can be activated by the #FIXAXIS command. Note that there can
still be resolution changes ALONG the axis.

If UseUniformAxis is false, the AMR can produce resolution changes around 
the axis of the grid. The super-cell algorithm cannot be used. 
For restarted runs the false setting has to be repeated in the PARAM.in file 
used for the restart.

The default is UseUniformAxis=T.
</command>

<command name="FIXAXIS">
	<parameter name="UsePoleDiffusion" type="logical" default="F"/>
	<parameter name="DoFixAxis" type="logical" default="F"/>
	<parameter name="rFixAxis"  type="real" min="0" default="0"/>
	<parameter name="r2FixAxis" type="real" min="0" 
				max="$rFixAxis" default="0"/>
#FIXAXIS
F			UsePoleDiffusion
T			DoFixAxis
5.0			rFixAxis
1.5			r2FixAxis

The computational cells become very small near the symmetry axis 
of a spherical or cylindrical grid. When UsePoleDiffusion is true,
some numerical diffusion applied between the cells on the opposite
side of the axis. This diffusion may smooth out some artifacts that 
show up when a discontinuity crosses the axis.

When DoFixAxis is true, the cells around the pole are merged into one 
'supercell' for the blocks that are (partially) inside radius rFixAxis. 
For blocks within r2FixAxis, the radius of the supercell is 2 normal
cells. Merging the small cells allows larger time steps in time accurate runs:
about a factor of 2 if only rFixAxis is used, and around factor of 3 
if r2FixAxis is also used. 

Note that the super-cell algorithm requires that there is no 
resolution change around the axis in the phi direction. See
the #UNIFORMAXIS command for more discussion.

Default is false for both UsePoleDiffusion and DoFixAxis.
</command>

</commandgroup>

<commandgroup name="INITIAL TIME">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!! INITIAL TIME AND STEP !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="STARTTIME" alias="SETREALTIME" if="$_IsFirstSession">
	<parameter name="iYear"  type="integer" default="2000" />
	<parameter name="iMonth" type="integer" min="1" max="12" default="3"/>
	<parameter name="iDay"   type="integer" min="1" max="31" default="21"/>
	<parameter name="iHour"   type="integer" min="0" max="23" default="0"/>
	<parameter name="iMinute" type="integer" min="0" max="59" default="0"/>
	<parameter name="iSecond" type="integer" min="0" max="59" default="0"/>
#STARTTIME
2000                    iYear
3                       iMonth
21                      iDay
10                      iHour
45                      iMinute
0                       iSecond

The #STARTTIME command sets the initial date and time for the
simulation in Greenwich Mean Time (GMT) or Universal Time (UT)
in stand alone mode. 
In the SWMF this command checks start times against the SWMF start time 
and warns if the difference exceeds 1 millisecond.
This time is stored in the BATSRUS restart header file.

The default values are shown above.
This is a date and time when both the rotational and the magnetic axes
have approximately zero tilt towards the Sun.
</command>

<command name="TIMESIMULATION" if="$_IsFirstSession">
	<parameter name="tSimulation" type="real" min="0" default="0.0" />

#TIMESIMULATION
3600.0			tSimulation [sec]

The tSimulation variable contains the simulation time in seconds
relative to the initial time set by the #STARTTIME command.
The #TIMESIMULATION command and tSimulation are saved into the restart 
header file, which provides human readable information about the restart state.

In SWMF the command is ignored (SWMF has its own #TIMESIMULATION command).
In stand alone mode time\_simulation is set, but in case of a restart,
it gets overwritten by the binary value saved into the .rst binary files. 

The default value is tSimulation=0.
</command>

<command name="NSTEP" if="$_IsFirstSession">
	<parameter name="nStep" type="integer" min="0" default="0" />

#NSTEP
100			nStep

Set nStep for the component. Typically used in the restart.H header file.
Generally it is not inserted in a PARAM.in file by the user.

The default is nStep=0 as the starting time step with no restart.
</command>

<command name="NPREVIOUS" if="$_IsFirstSession">
	<parameter name="nPrevious" type="integer" min="-1" default="-1" />

#NPREVIOUS
100			nPrev
1.5			DtPrev

This command should only occur in the restart.H header file.
If it is present, it indicates that the restart file contains
the state variables for the previous time step.
nPrev is the time step number and DtPrev is the length of the previous 
time step in seconds.
The previous time step is needed for a second order in time restart 
with the implicit scheme. 

The default is that the command is not present and no previous time step 
is saved into the restart files.
</command>
</commandgroup>
<commandgroup name="TIME INTEGRATION">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!  TIME INTEGRATION PARAMETERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="TIMESTEPPING" alias="RUNGEKUTTA,RK">
	<parameter name="nStage" type="integer" min="1" max="4" default="2" />
	<parameter name="CflExpl" type="real" min="0" max="1" default="0.8" />

#TIMESTEPPING
1                       nStage
0.4                     CflExpl

#RUNGEKUTTA
2			nStage
0.8			CflExpl

#RK
4			nStage
1.3			CflExpl

These commands set the parameters for time integration.
For explicit time integration nStage is the number of stages.
Setting nStage=1 selects a temporally first order forward Euler scheme.
The nStage=2 corresponds to a temporally second order scheme. 
The #TIMESTEPPING command uses half time step for the first stage,
and full time step for the second stage. The #RUNGEKUTTA or #RK commands
select a TVD Runge-Kutta scheme that employs full time step in both stages 
and then takes their average.
The nStage=3 selects a 3rd order TVD Runge-Kutta scheme. 
The nStage=4 selects the classical 4th order Runge-Kutta scheme.
These temporally high order options are useful in combination with
spatially higher order schemes (to be implemented).

For implicit time stepping nStage=2 corresponds to the BDF2 (Backward Differene
Formula 2) scheme that uses the previous time step to make the scheme 
2nd order accurate in time.

For explicit time stepping the CPU time is proportional to the number of 
stages. In time accurate runs the 1-stage explicit time stepping scheme 
may work reasonably well with second order spatial discretization, 
especially if the time step is limited to a very small value. 
Using a one stage scheme can speed up the code by a factor of two with 
little compromise in accuracy.

For local time stepping (steady state mode) one should always use the 
2-stage scheme with 2-nd order spatial accuracy to avoid oscillations
(or use the 1-stage scheme with CflExpl=0.4).

For implicit scheme the second order BDF2 scheme is more accurate 
but not more expensive than the first order backward Euler scheme, 
so it is a good idea to use nStage=nOrder (or at least nStage=3 for
high order schemes). 

To achieve consistency between the spatial and temporal orders of accuracy,
the #SCHEME command always sets nStage to be the same as nOrder
except for 5th order scheme, which sets nStage=3.
The #TIMESTEPPING (or #RUNGEKUTTA or #RK) command can be used AFTER the
#SCHEME command to overwrite nStage if required.

If the #SCHEME command is not used, then the defaults are 
nStage=2 with the half-step predictor and CflExpl=0.8.
</command>

<command name="FIXEDTIMESTEP">
	<parameter name="UseDtFixed" type="logical" default="F" />
	<parameter name="DtFixedDim" type="real" min="0" default="1.0" 
							if="$UseDtFixed" />
#FIXEDTIMESTEP
T                       UseDtFixed
10.                     DtFixedDim [sec] (read if UseDtFixed is true)

Default is UseDtFixed=.false. Effective only if DoTimeAccurate is true.
If UseDtFixed is true, the time step is fixed to DtFixedDim.

This is useful for debugging explicit schemes.

The real application is, however, for implicit and partially
implicit/local schemes. The time step is set to DtFixedDim unless the
update checking decides to reduce the time step for the sake of robustness.
</command>

<command name="PARTSTEADY">
	<parameter name="UsePartSteady" type="logical" default="F" />

#PARTSTEADY
T			UsePartSteady

If UsePartSteady is true, the partially steady state algorithm is used.
Only blocks which are changing or next to changing blocks are evolved.
This scheme can speed up the calculation if part 
of the domain is in a numerical steady state. 
In steady state runs the code stops when a full steady state is
achieved. The conditions for checking the numerical steady state are set 
by the #PARTSTEADYCRITERIA command.
Default value is UsePartSteady = .false.
</command>

<command name="PARTSTEADYCRITERIA" alias="STEADYCRITERIA">
	<parameter name="MinCheckVar" type="integer" 
		min="1" default="1"/>
	<parameter name="MaxCheckVar" type="integer" 
		min="$MinCheckVar" default="8" />
	<for from="$MinCheckVar" to="$MaxCheckVar">
		<parameter name="RelativeEps" type="real" 
				min="0" max="1" default="0.001" />
		<parameter name="AbsoluteEps" type="real"
				min="0"		default="0.0001" />
	</for>
#PARTSTEADYCRITERIA
5               MinCheckVar
8               MaxCheckVar
0.001           RelativeEps(bx)
0.0001          AbsoluteEps(bx)
0.001           RelativeEps(by)
0.0001          AbsoluteEps(by)
0.001           RelativeEps(bz)
0.0001          AbsoluteEps(bz)
0.001           RelativeEps(p)
0.0001          AbsoluteEps(p)

The part steady scheme only evolves blocks which are changing,
or neighbors of changing blocks. The scheme checks the neighbor blocks
every time step if their state variable has changed significantly.
This command allows the user to select the variables to be checked,
and to set the relative and absolute limits for each variable.
Only the state variables indexed from MinCheckVar to MaxCheckVar are checked.
The change in the block is significant if 
\begin{verbatim}
max(abs(State - StateOld)) / (RelativeEps*abs(State) + AbsoluteEps)
\end{verbatim}
exceeds 1.0 for any of the checked variables in any cells of the block.
(including body cells but excluding ghost cells).
The RelativeEps variable determines the maximum ratio of the change
and the norm of the old state. The AbsoluteEps variable is only needed
if the old state is very close to zero. It should be set to a positive
value which is much smaller than the typical significantly non-zero
value of the variable.

Default values are such that all variables are checked with
relative error 0.001 and absolute error 0.0001.
</command>

<command name="POINTIMPLICIT">
	<parameter name="UsePointImplicit" type="logical" default="F"/>
	<if expr="$UsePointImplicit">
		<parameter name="BetaPointImplicit" type="real" 
			min="0.5" max="1" default="0.5"/>
		<parameter name="IsAsymmetric" type="logical" default="T"/>
		<parameter name="DoNormalizeCell" type="logical" default="F"/>
	</if>
#POINTIMPLICIT
T		UsePointImplicit
0.5		BetaPointImplicit (read if UsePointImplicit is true)
T		IsAsymmetric
T		DoNormalizeCell

Switches on or off the point implicit scheme. The BetaPointImplicit
parameter (in the 0.5 to 1.0 range) determines the order of accuracy 
for a 2-stage scheme. If BetaPointImplicit=0.5 the point implicit scheme 
is second order accurate in time when used in a 2-stage scheme. 
Larger values may be more robust, but only first order accurate in time.
For a 1-stage scheme or for local timestepping the BetaPointImplicit 
parameter is ignored and the coefficient is set to 1.

If the IsAsymmetric parameter is true, the numerical Jacobian is calculated
with a one-sided (asymmetric) difference formula. Otherwise a two-sided
symmetric difference is used. The latter is slower somewhat but more accurate.

If DoNormalizeCell is true, the normalization of variables (this is needed
to make small perturbations for the calculation of numerical derivatives)
is done cell-by-cell. The default is false, so normalization is done 
on a block-by-block basis.

For single-ion MHD the default is UsePointImplicit=.false.
For multi-ion MHD the default values are 
UsePointImplicit=.true., BetaPointImplicit=1.0 and IsAsymmetric=.true.
</command>

<command name="IMPLICIT">
	<parameter name="UsePointImplicit" type="logical" default="F"/>
	<parameter name="UsePartImplicit" type="logical" default="F"/>
	<parameter name="UseFullImplicit" type="logical" default="F"/>
	<parameter name="CflImpl" type="real" min="0" default="100"
		if="$UsePartImplicit or $UseFullImplicit"/>
	<rule expr="not ($UsePartImplicit and $UseFullImplicit)">
		UsePartImplicit and UseFullImplicit cannot be both true!
	</rule>
	<rule expr="not ($UsePointImplicit and $UseFullImplicit)">
		UsePointImplicit and UseFullImplicit cannot be both true!
	</rule>

#IMPLICIT
F               UsePointImplicit
F               UsePartImplicit
T               UseFullImplicit
100.0           CflImpl (read if UsePartImplicit or UseFullImplicit is true)

If UsePointImplicit=T is set, the source terms defined in the user module
are evaluated with a point implicit scheme. See the #POINTIMPLICIT command
for additional parameters (and another way of switching the point implicit 
scheme on).

If UsePartImplicit=T is set, the code uses the explicit/implicit scheme.
This means that some of the grid blocks are advanced with explicit
time stepping, while the rest is advance with implicit time stepping.
See the #FIXEDTIMESTEP and #IMPLICITCRITERIA command on how the 
explicit and implicit blocks get selected.

If UseFullImplicit=T is set, the code uses a fully implicit time
stepping scheme. This is usually more costly than the explicit/implicit
scheme unless the whole computational domain requires implicit
time stepping. 

Note 1: If UseFullImplicit is true, UsePartImplicit and UsePointImplicit 
must be false.

Note 2: UsePartImplicit=T and UsePointImplicit=T may be used together:
source terms are point implicit in the explicit blocks. 

The ImplCFL parameter determines the CFL number used in the implicit blocks 
of the fully or partially implicit schemes. This is ignored if UseDtFixed=T 
is set in the #FIXEDTIMESTEP command.

Default is false for all logicals. 
</command>

<command name="SEMIIMPLICIT">
	<parameter name="UseSemiImplicit" type="logical" default="F"/>
	<parameter name="TypeSemiImplicit" type="string" input="select"
							if="$UseSemiImplicit">
		<option name="radiationsplit" default="T"/>
		<option name="radiation"/>
		<option name="radcondsplit"/>
		<option name="radcond"/>
		<option name="parcond"/>
		<option name="cond"/>
		<option name="resistivity"/>
	</parameter>
#SEMIIMPLICIT
T                       UseSemiImplicit
radiation               TypeSemiImplicit (read if UseSemiImplicit is true)

If UseSemiImplicit is true then most of the terms are evaluated explicitly,
but some of them are evaluated implicitly. 

The TypeSemiImplicit parameter determines which terms and corresponding 
variables are done semi-implicitly. The "radiation" option solves for the 
gray or multigroup diffusion energy density. For gray diffusion the 
internal energy and pressure is calculated in a point implicit manner. 

The "radiationsplit" option solves each radiation group separately.
The energy exchange term is calculated point-implicitly. The
internal energy is updated in a conservative way.

The "radcond" option solves implicitly the radiation diffusion
and electron heat conduction together with
the radiation and internal energy densities being the unknowns.
To use gray diffusion configure BATSRUS with the default:
Config.pl -nWave=1
To use the multi-group radiation select nWave larger than one.

The "radcondsplit" option will solve each radiation group and the 
electrons separately...

The "parcond" option solves for field aligned electron heat conduction only.

The "cond" option solves for electron heat conduction only.

The "resistivity" option solves for the magnetic field with
dissipative and/or Hall Resistivity.

The default is UseSemiImplicit false.
</command>
</commandgroup>

<commandgroup name="IMPLICIT PARAMETERS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!! PARAMETERS FOR FULL AND PART IMPLICIT TIME INTEGRATION !!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="IMPLICITENERGY" alias="IMPLENERGY">
	<parameter name="UseImplicitEnergy" type="logical" default="T" />

#IMPLICITENERGY
F			UseImplicitEnergy

If UseImplicitEnergy is true, use the energy variable(s) as unknown(s) in the 
implicit scheme, otherwise use the pressure variables(s). Note that the
explicit scheme that provides the right hand side of the implicit scheme
may still be conservative, and thus the overall scheme can provide 
correct jump conditions across standing (or slowly moving) shocks.
Away from shocks, using pressure as an implicit variable provides a more 
accurate and robust scheme than using the energy variable.

The default is UseImplicitEnergy=T for sake of backwards compatibility.
</command>

<command name="IMPLICITCRITERIA" alias="STEPPINGCRITERIA">
	<parameter name="TypeImplCrit" type="string" case="lower"
	input="select">
		<option name="Time step"	value="dt" default="T"	/>
		<option name="Radial distance"	value="r"		/>
		<option name="Test block"	value="test"		/>
	</parameter>
	<parameter name="rImplicit" type="real" min="0"
		if="$TypeImplCrit eq 'r'" />

#IMPLICITCRITERIA
r		TypeImplCrit (dt or r or test)
10.0		rImplicit    (only read for TypeImplCrit = r)

Both #IMPLICITCRITERIA and #STEPPINGCRITERIA are acceptable.
Only effective if PartImplicit is true in a time accurate run.
Default value is ImplCritType='dt'.

The options are
\begin{verbatim}
if     (TypeImplCrit =='dt'  ) then blocks with DtBLK .lt. DtFixed
elseif (TypeImplCrit =='r'   ) then blocks with rMinBLK .lt. rImplicit
elseif (TypeImplCrit =='test') then block iBlockTest on processor iProcTest
\end{verbatim}
are handled with the implicit scheme. Here DtBlock is the time step
allowed by the CFL condition for a given block, while rMinBLK is the
smallest radial distance for all the cells in the block.\\

\noindent
The iBlockTest and iProcTest can be defined in the #TESTIJK command.\\
DtFixed must be defined in the #FIXEDTIMESTEP command.
</command>

<command name="PARTIMPL" alias="PARTIMPLICIT">
	<parameter name="UsePartImplicit2" type="logical" default="F" />

#PARTIMPLICIT
T		UsePartImplicit2

If UsePartImplicit2 is set to true, the explicit scheme is executed in all
blocks before the implicit scheme is applied in the implicit blocks. This way
the fluxes at the explicit/implicit interface are second order accurate,
and the overall part implicit scheme will be fully second order in time.
When this switch is false, the explicit/implicit interface fluxes are only
first order accurate in time.
A potential drawback of the second order scheme is that the explicit scheme 
may crash in the implicit blocks. This could be avoided with a more 
sophisticated implementation. There may also be a slight speed penalty, 
because the explicit scheme is applied in more blocks. 

The default is UsePartImplicit2 = false for now, which is safe and 
backward compatible.
</command>

<command name="IMPLSTEP" alias="IMPLICITSTEP">
	<parameter name="ImplCoeff" type="real" min="0" max="1" default="1"/>
	<parameter name="UseBdf2"   type="logical" default="T" />
	<parameter name="UseSourceImpl" type="logical" default="F" />

#IMPLSTEP
0.5			ImplCoeff
F			UseBdf2
F			UseSourceImpl

The ImplCoeff is the beta coefficient in front of the implicit terms
for the two-level implicit scheme.
The UseBdf2 parameter decides if the 3 level BDF2 scheme is used or 
a 2 level scheme.
UseSourceImpl true means that the preconditioner should take point
source terms into account. 

For steady state run the default is the backward Euler scheme, which 
corresponds to ImplCoeff=1.0 and UsedBdf2=F.
For second order time accurate run the default is UseBdf2=T, since
BDF2 is a 3 level second order in time and stable implicit scheme.
In both cases the default value for UseSourceImpl is false.

The default values can be overwritten with #IMPLSTEP, but only
after the #TIMESTEPPING command!
For example one could use the 2-level trapezoid scheme with
ImplCoeff=0.5 and UseBDF2=F as shown in the example above. 
The BDF2 scheme determines the coefficient for the implicit terms itself, 
but ImplCoeff is still used in the first time step and after AMR-s, when
the code switches back to the two-level scheme for one time step.
</command>

<command name="SEMICOEFF" alias="SEMIIMPLCOEFF,SEMIIMPLICITCOEFF">
	<parameter name="SemiImplCoeff" type="real" min="0.5" max="1" default="1"/>

#SEMICOEFF
0.5			SemiImplCoeff

The SemiImplCoeff is the coefficient in front of the implicit part of the
semi-implicit terms. The value should be in the range 0.5 to 1. 
The 0.5 value will make the semi-implicit term 2nd order accurate in time,
but currently the operator splitting still renders the full scheme first 
order in time only. Using 1.0 is the most robust option, as it makes the
semi-implicit term to be evaluated fully implicitly, but it is first order
accurate in time only. The default value is 1.
</command>

<command name="IMPLSCHEME" alias="IMPLICITSCHEME">
	<parameter name="nOrderImpl" type="integer" min="1" max="2" 
								default="1"/>
	<parameter name="TypeFluxImpl" type="string" case="upper"
	input="select">	    
	    <option name="Rusanov" value="RUSANOV/2" default="T"/>
	    <option name="Linde"   value="LINDE"/>
	    <option name="Sokolov" value="SOKOLOV"/> 
	    <option name="HLLD"                   /> 
	    <option name="Roe"     value="ROE"/>
	    <option name="RoeOld"  value="ROEOLD"/>
	    <option name="Godunov" value="GODUNOV"/>
	</parameter>
#IMPLSCHEME
1               nOrderImpl
Rusanov         TypeFluxImpl

This command defines the scheme used in the implicit part ('left hand side').
The default order is first order. The default scheme is the same as the
scheme selected for the explicit part. 
</command>

<command name="IMPLCHECK" alias="IMPLICITCHECK">
	<parameter name="RejectStepLevel"  type="real" 
			min="0"  max="0.9" default="0.3" />
	<parameter name="RejectStepFactor" type="real" 
			min="0"  max="0.9" default="0.5" />
	<parameter name="ReduceStepLevel"  type="real" 
			min="0"  max="0.9" default="0.6" />
	<parameter name="ReduceStepFactor" type="real" 
			min="0"  max="1"   default="0.9" />
	<parameter name="IncreaseStepLevel" type="real" 
			min="0"  max="1"   default="0.8" />
	<parameter name="IncreaseStepFactor" type="real" 
			min="1"  max="2"   default="1.05"/>

#IMPLCHECK
0.3		RejectStepLevel
0.5		RejectStepFactor
0.6		ReduceStepLevel
0.95		ReduceStepFactor
0.8		IncreaseStepLevel
1.05		IncreaseStepFactor

The update checking of the implicit scheme can be tuned with this command.
Update checking is done unless it is switched off (see UPDATECHECK command).
After each (partially) implicit time step, the code computes pRhoRelMin,
which is the minimum of the relative pressure and density drops over 
the whole computational domain. The algorithm is the following:

If pRhoRelMin is less than RejectStepLevel,
the step is rejected, and the time step is reduced by RejectStepFactor;
else if pRhoRelMin is less than ReduceStepLevel,
the step is accepted, but the next time step is reduced by ReduceStepFactor;
else if pRhoRelMin is greater than IncreaseStepFactor,
the step is accepted and the next time step is increased by IncreaseStepFactor,
but it is never increased above the value given in the FIXEDTIMESTEP command.

Assigning ReduceStepFactor=1.0 means that the
time step is not reduced unless the step is rejected.
Assigning IncreaseStepFactor=1.0 means that the 
time step is never increased, only reduced.

Default values are shown.
</command>

<command name="NEWTON">
	<parameter name="UseNewton" type="logical" default="F"/>
	<if expr="$UseNewton">
		<parameter name="UseConservativeImplicit" type="logical" 
			   				  	default="F"/>
		<parameter name="MaxIterNewton" type="integer" min="1"
							   default="10" />
	</if>
#NEWTON
T               UseNewton (rest of parameters read if true)
F		UseConservativeImplicit
10              MaxIterNewton 

If UseNewton is true a full non-linear Newton iteration is performed.
If UseConservativeImplicit is true, the Newton iteration is finished 
with a conservative fix (back substitution of the solution
into the non-linear implicit equations).
MaxIterNewton is the maximum number of Newton iterations before giving up.

Default is UseNewton=F, i.e. we do a single "Newton" iteration, which
is the linearized implicit scheme. In most cases that is the best choice.
</command>

<command name="JACOBIAN">
	<parameter name="DoPrecond" type="logical" default="T"/>
	<parameter name="JacobianEps" type="real" min="0" max="1.e-5" 
						  default="1.E-12"/>
#JACOBIAN
T               DoPrecond
1.E-12          JacobianEps

The Jacobian matrix is always calculated with a matrix free approach,
however it can be preconditioned if DoPrecond is set to true.  
JacobianEps contains the machine round off error for numerical derivatives.
The default value is 1.E-12 for 8 byte reals and 1.E-6 for 4 byte reals.

The default values are shown by the example.
</command>

<command name="PRECONDITIONER">
	<parameter name="TypePrecondSide" type="string" input="select">
		<option name="left"			/>
		<option name="symmetric" default="T"	/>
		<option name="right"			/>
	</parameter>
	<parameter name="TypePrecond" type="string" input="select"
							case="upper">
		<option value="JACOBI"      name="Jacobi"/>
		<option value="BLOCKJACOBI" name="block-Jacobi"/>
		<option value="GS"          name="Gauss-Seidel"/>
		<option name="BILU"                            />
		<option name="MBILU"        default="T"        />
	</parameter>
	<parameter name="PrecondParam" type="real" min="-1" max="1" 
		default="0.5" if="$TypePrecond eq 'MBILU'"/>
#PRECONDITIONER
symmetric       TypePrecondSide (left, symmetric, right)
MBILU           TypePrecond (JACOBI, BLOCKJACOBI, GS, BILU, MBILU) 
0.5             GustafssonPar (0 to 1, read for MBILU preconditioner only)

TypePrecondSide can be left, right or symmetric. There seems to be little
difference between these in terms of performance. Right preconditioning 
does not affect the normalization of the residual. The JACOBI and BLOCKJACOBI
preconditioners are implemented to always use left preconditioning. 

The TypePrecond parameter can be set to JACOBI, GAUSS-SEIDEL, BLOCKJACOBI, BILU, MBILU.

The simplest Jacobi preconditioner is mainly useful for code development purposes. 
It uses the inverse of the diagonal elements of the approximate Jacobian matrix.
The block-Jacobi preconditioner uses the invese of the diagonal blocks of the 
Jacobian matrix. It coincides with the Jacobi preconditioner for a scalar equation.
The Gauss-Seidel (GS) preconditioner gives better performance
than Jacobi, however, the BILU and MBILU preconditioners are usually more efficient.
The Modified BILU (MBILU) preconditioner allows a Gustafsson modification 
relative to BILU. In some cases the modification improves the preconditioner, 
but sometimes it makes it worse.

The GustafssonPar parameter is only read for the MBILU preconditioner.
If it is 0, the standard block (BILU) preconditioning is done.
This seems to be optimal for diffusion+relaxation type problems.
Setting a positive GustafssonPar up to 1 results in the modified (MBILU) 
preconditioner. The maximum 1 corresponds to the full Gustafsson modification.
The default 0.5 value seems to be optimal for matrices resulting from 
hyperbolic (advection) type problems.

Default parameters are shown by the first example.
</command>

<command name="SEMIPRECONDITIONER" alias="SEMIPRECOND">
	<parameter name="DoPrecond" type="logical" default="T"/>
	<if expr="$DoPrecond">
		<parameter name="TypePrecond" type="string" input="select"
							case="upper">
			<option name="JACOBI" />
			<option value="BLOCKJACOBI" name="block-Jacobi"/>
			<option value="GS"          name="Gauss-Seidel"/>
			<option name="DILU"  />
			<option name="BILU"  />
			<option name="MBILU" default="T" />
			<option name="HYPRE" />
		</parameter>
		<parameter name="PrecondParam" type="real" min="-1" max="1" 
			   default="0.5" if="$TypePrecond eq 'MBILU'"/>
	</if>
#SEMIPRECONDITIONER
T               DoPrecond (rest of parameters are read if true)
MBILU           TypePrecond (MBILU, BILU, DILU, GS, BLOCKJACOBI, JACOBI, HYPRE)
0.5             GustafssonPar (0 to 1, read for MBILU preconditioner only)

#SEMIPRECOND
T		DoPrecond
HYPRE		TypePrecond

Similar to the #PRECONDITIONER command but for the semi-implicit scheme.

If DoPrecond is false, no preconditioner is used. This will result in
slower convergence. It is almost always preferable to use a preconditioner.
The semi-implicit scheme always uses left side preconditioning.

The TypePrecond parameter can be set to the following values:
JACOBI, BLOCKJACOBI, GS, DILU, BILU, MBILU or HYPRE. 
Most of these options are described in some detail for the #PRECONDITIONER
command.

The Diagonal Incomplete Lower-Upper (DILU) preconditioner assumes that the 
off-diagonal blocks are diagonal matrices, and it gives the same result 
but faster performance than BILU in that case. This assumption
holds if the derivative of a variable in the semi-implicit terms only 
affects the same variable (true for heat conduction, radiative diffusion,
dissipative resistivity, but not for Hall resistivity).

The HYPRE preconditioner can only be used if the HYPRE library
has been checked out into the util/ directory and Config.pl -hypre has 
been set. The HYPRE preconditioning only works if the semi-implicit 
scheme solves for 1 variable at a time (split semi-implicit scheme).

Default values are shown by the first example.
</command>

<command name="KRYLOV">
	<parameter name="TypeKrylov" type="string" input="select" case="upper">
		<option name="GMRES"	default="T"	/>
		<option name="BICGSTAB" 		/>
		<option name="CG" 			/>
	</parameter>
	<parameter name="TypeInitKrylov" type="string" input="select">
                <option name="0" 	value="nul" default="T"	/>
                <option name="previous" value="old"		/>
                <option name="explicit"				/>
                <option name="scaled explicit" value="explicit"	/>
	</parameter>
	<parameter name="ErrorMaxKrylov" type="real" min="0" max="0.1"
							default="0.001" />
	<parameter name="MaxMatvecKrylov" type="integer" min="1"
							default="100" />
#KRYLOV
GMRES           TypeKrylov  (GMRES, BICGSTAB, CG)
nul             TypeInitKrylov (nul, old, explicit, scaled)
0.001           ErrorMaxKrylov
100             MaxMatvecKrylov

Default values are shown. 

The TypeKrylov parameter selects the iterative Krylov solver.
The GMRES solver is the most robust and it converges the fastest 
among all Krylov solvers. It uses one matrix-vector product per iteration.
On the other hand it needs to store one copy of the vector of the unknowns 
per iteration. GMRES also has to invert an NxN matrix in the N-th iteration.
This means that GMRES is the optimal choice if the
number of iterations is relatively small, typically less than 100. 
This is almost always true when the HYPRE preconditioner is used
(see the #PRECONDITIONER command). 

BICGSTAB is a robust Krylov scheme that only uses 4 copies of the unknown 
vector, and it uses two  matrix-vector products per iteration.
It usually requires somewhat more matrix-vector products than GMRES to
achieve the same accuracy (defined by the tolerance ErrorMaxKrylov).
On the other hand all iterations have the same computational cost.

The preconditioned Conjugate Gradient (CG) scheme only
works for symmetric matrices. It only uses two copies of the unknown vector. 
For symmetric matrices it is more efficient than BiCGSTAB. 
In case many iterations are needed, it is more efficient than GMRES.
The CG scheme currently does not work together with the HYPRE preconditioner. 

Initial guess for the Krylov type iterative scheme
can be 0 ('nul'), the previous solution ('old'), the explicit solution
('explicit'), or the scaled explicit solution ('scaled'). The iterative
scheme stops if the required accuracy is achieved or the maximum number
of matrix-vector multiplications is exceeded.

The ErrorMaxKrylov parameter defines the relative accuracy of the solution.
The iteration stops when the residual (measured in the second norm)
drops below the initial residual times ErrorMaxKrylov.

The MaxMatvecKrylov parameter limits the number of Krylov iterations.
It also defines the maximum number of copies of the unknown vector
for the GMRES solver, although this can be overwritten with the
#KRYLOVSIZE command (see the description for more detail). 
If the Krylov solver does not succeed in achieving the desired accuracy 
within the maximum number of iterations, an error message is printed.
</command>

<command name="SEMIKRYLOV">
	<parameter name="TypeKrylov" type="string" input="select" case="upper">
		<option name="GMRES"	default="T"	/>
		<option name="BICGSTAB" 		/>
		<option name="CG" 			/>
	</parameter>
	<parameter name="ErrorMaxKrylov" type="real" min="0" max="0.1"
							default="0.001" />
	<parameter name="MaxMatvecKrylov" type="integer" min="1"
							default="100" />
#SEMIKRYLOV
GMRES           TypeKrylov  (GMRES, BICGSTAB, CG)
0.001           ErrorMaxKrylov
100             MaxMatvecKrylov

Same as the #KRYLOV command, but for the semi-implicit scheme.
The initial guess is always zero, so there are only 3 parameters.

Default values are shown. 
</command>

<command name="KRYLOVSIZE">
	<parameter name="nKrylovVector" type="integer" min="1" 
						default="$MaxMatvecKrylov"/>
#KRYLOVSIZE
10		nKrylovVector

The number of Krylov vectors only matters for GMRES (TypeKrylov='gmres').
If GMRES does not converge within nKrylovVector iterations, it needs
a restart, which usually degrades its convergence rate and robustness.
So nKrylovVector should exceed the number of iterations, but
it should not exceed the maximum number of iterations MaxMatvecKrylov.
On the other hand the dynamically allocated memory is also proportional 
to nKrylovVector. The default is nKrylovVector=MaxMatvecKrylov (in #KRYLOV)
which can be overwritten by #KRYLOVSIZE after the #KRYLOV command (if any).
</command>

<command name="SEMIKRYLOVSIZE">
	<parameter name="nKrylovVector" type="integer" min="1" 
						default="$MaxMatvecKrylov"/>
#SEMIKRYLOVSIZE
10		nKrylovVector

Same as #KRYLOVSIZE but for the semi-implicit scheme. This command should
be used after the #SEMIKRYLOV command (if present).
</command>

</commandgroup>
<commandgroup name="STOPPING CRITERIA">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!! STOPPING CRITERIA !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

The commands in this group only work in stand alone mode.

<command name="STOP" required="$_IsStandAlone" if="$_IsStandAlone">
	<parameter name="MaxIteration" type="integer" min="-1" default="-1" />
	<parameter name="tSimulationMax" type="real"  min="-1" default="-1" />

#STOP
100			MaxIteration
10.0			tSimulationMax [sec]

This command is only used in stand alone mode.

The MaxIteration variable contains the
maximum number of iterations {\it since the beginning of the current run}
(in case of a restart, the time steps done before the restart do not count).
If nIteration reaches this value the session is finished.
The tSimulationMax variable contains the maximum simulation time
relative to the initial time determined by the #STARTTIME command.
If tSimulation reaches this value the session is finished.

Using a negative value for either variables means that the
corresponding condition is  not checked. The default values
are MaxIteration=0 and tSimulationMax = 0.0, so the #STOP command
must be used in every session.
</command>

<command name="CHECKSTOPFILE" if="$_IsStandAlone">
	<parameter name="DoCheckStopFile" type="logical" default="T" />

#CHECKSTOPFILE
T			DoCheckStopFile

This command is only used in stand alone mode.

If DoCheckStopFile is true then the code checks if the
BATSRUS.STOP file exists in the run directory. This file is deleted at
the beginning of the run, so the user must explicitly create the file
with e.g. the "touch BATSRUS.STOP" UNIX command.
If the file is found in the run directory,
the execution stops in a graceful manner.
Restart files and plot files are saved as required by the
appropriate parameters.

The default is DoCheckStopFile=.true.
</command>

<command name="CPUTIMEMAX" if="$_IsStandAlone">
	<parameter name="CpuTimeMax" type="real" min="-1" default="-1" />

#CPUTIMEMAX
3600                    CpuTimeMax [sec]

This command is only used in stand alone mode.

The CpuTimeMax variable contains the maximum allowed CPU time (wall clock
time) for the execution of the current run. If the CPU time reaches
this time, the execution stops in a graceful manner.
Restart files and plot files are saved as required by the
appropriate parameters.
This command is very useful when the code is submitted to a batch
queue with a limited wall clock time.

The default value is -1.0, which means that the CPU time is not checked.
To do the check the CpuTimeMax variable has to be set to a positive value.
</command>
</commandgroup>
<commandgroup name="OUTPUT PARAMETERS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!  OUTPUT PARAMETERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="RESTARTOUTDIR">
	<parameter name="NameRestartOutDir" type="string" length="100"
						default="GM/restartOUT" />
	<rule expr="-d $NameRestartOutDir">
		Restart output directory $NameRestartOutDir must exist
	</rule>

#RESTARTOUTDIR
GM/restart_n5000	NameRestartOutDir

The NameRestartOutDir variable contains the name of the directory
where restart files are saved relative to the run directory.
The directory should be inside the subdirectory with the name 
of the component.

Default value is "GM/restartOUT".
</command>

<command name="RESTARTOUTFILE">
	<parameter name="StringRestartOutFile" type="strings" min="1" max="2">
		<part name="TypeRestartOutFile" type="string" input="select" 
								required="T">
			<option name="separate files/proc" value="proc" 
					       		   	default="T" />
			<option name="single data.rst file" value="one" />
			<option name="separate files/block" value="block"  />
		</part>
		<part name="StringSeries" type="string" input="select"
								required="F">
			<option name="series"/>
		</part>
	</parameter>

#RESTARTOUTFILE
one series			TypeRestartOutFile

This command determines if the restart information is saved as an individual 
file for each block (block), as direct access files for each processor (proc)
or into a single direct access file containing all blocks (one).  

Normally saving restart files overwrites the previous files.
Adding 'series' after the type results in a series of restart files
with names starting as nITERATION_. This will be used by the adjoint method.

The most reliable format is 'proc'. If there is any issue with restarting
with the 'one' format (some machines write empty records into the file), 
the 'proc' should be used. The 'block' format can fail due to too many files.

The default value is 'proc'.
</command>

<command name="SAVERESTART">
	<parameter name="DoSaveRestart" type="logical" default="T" />
	<if expr="$DoSaveRestart">
		<parameter name="DnSaveRestart" type="integer" min="-1" 
							default="-1" />
		<parameter name="DtSaveRestart" type="real"    min="-1" 
							default="-1" />
	</if>
#SAVERESTART
T			DoSaveRestart Rest of parameters read if true
100			DnSaveRestart
-1.			DtSaveRestart [seconds]

Default is DoSaveRestart=.true. with DnSaveRestart=-1 and 
DtSaveRestart=-1. This results in the restart file being 
saved only at the end.  A binary restart file is produced for every 
block and named as RESTARTOUTDIR/blkGLOBALBLKNUMBER.rst.
In addition the grid is described by RESTARTOUTDIR/octree.rst
and an ASCII header file is produced with timestep and time info:
RESTARTOUTDIR/restart.H

The restart files are overwritten every time a new restart is done,
but one can change the name of the RESTARTOUTDIR with the #RESTARTOUTDIR
command from session to session. The default directory name is 'restartOUT'.
</command>

<command name="PLOTDIR">
	<parameter name="NamePlotDir" type="string" length="100"
				default="GM/IO2" />
	<rule expr="-d $NamePlotDir">
		Plot directory $NamePlotDir must exist
	</rule>

The NamePlotDir variable contains the name of the directory
where plot files and logfiles are saved relative to the run directory.
The directory should be inside the subdirectory with the name
of the component.

Default value is "GM/IO2".
</command>

<command name="SAVELOGFILE">
	<parameter name="DoSaveLogfile" type="logical" default="F" />
	<if expr="$DoSaveLogfile">
		<parameter name="StringLog" type="strings" min="1" max="4">
			<part name="NameLogVar" type="string" input="select"
							required="T">
				<option name="MHD variables"     value="MHD"
								 default="T" />
				<option name="MHD vars. scaled"  value="mhd" />
				<option name="Flux variables"    value="FLX" />
				<option name="Flux vars. scaled" value="flx" />
				<option name="Raw variables"     value="RAW" />
				<option name="Raw vars. scaled"  value="raw" />
				<option name="Set variables"     value="VAR" />
				<option name="Set vars. scaled"  value="var" />
			</part>
			<part name="StringLogTime" type="string" input="select"
				required="F" multiple="T">
				<option name="none" exclusive="T" />
				<option name="step" 		/>
				<option name="date" 		/>
				<option name="time" 		/>
			</part>
		</parameter>
		<parameter name="DnSaveLogfile" type="integer" min="-1" 
								default="1" />
		<parameter name="DtSaveLogfile" type="real"    min="-1"
								default="-1" />
		<parameter name="NameLogVars" type="string" length="100"
			if="$NameLogVar =~ /var/i" />
		<parameter name="StringLogRadii" type="strings" 
			min="1" max="10" length="100"
			if="($NameLogVar=~/flx/i or $NameLogVars=~/flx/i)">
			<part name="LogRadii" type="real" min="$rBody" 
								multiple="T"/>
		</parameter>
	</if>
#SAVELOGFILE
T                       DoSaveLogfile, rest of parameters read if true
VAR step date           StringLog
100                     DnSaveLogfile
-1.                     DtSaveLogfile [sec]
rho p rhoflx            NameLogVars (read if StrigLog is 'var' or 'VAR')
4.0  10.0               rLog  (radii for the flux. Read if vars include 'flx')

Default is DoSaveLogfile=.false.
The logfile can contain averages or point values and other scalar
quantities.  It is written into an ASCII file named as\\

NAMEPLOTDIR/log_TIMESTEP.log\\

\noindent
where NAMEPLOTDIR can be defined with the #PLOTDIR command (default is IO2).\\
The StringLog can contain two groups of information in arbitrary order.
The first is LogVar which is a single 3 character string that indicates
the type of variables that are to be written.  The second group indicates
the type of time/iteration output format to use.  This second group is
not required and defaults to something standard for each logvar case.\\
Any of the identifiers for the timetype can be included in arbitrary order.

\begin{verbatim}
logvar   = 'mhd', 'raw', 'flx' or 'var' - unitless output
logvar   = 'MHD', 'RAW', 'FLX' or 'VAR' - dimensional output
timetype = 'none', 'step', 'time', 'date'
\end{verbatim}

The logvar string is not optional and must be found on the line.
The timetype is optional - when not specified a logical choice is made
 by the code.

The log_var string defines the variables to print in the log file
It also controls whether or not the variables will come out in
dimensional or non-dimensional form by the capitalization of the log_var
string.
\begin{verbatim}
ALL CAPS  - dimensional
all lower - dimensionless

'raw' - vars: dt rho rhoUx rhoUy rhoUz Bx By Bz E Pmin Pmax
      - time: step time
'mhd' - vars: rho rhoUx rhoUy rhoUz Bx By Bz E Pmin Pmax
      - time: step date time
'flx' - vars: rho Pmin Pmax rhoflx pvecflx e2dflx
      - time: step date time
'var' - vars: READ FROM PARAMETER FILE
      - time: step time
\end{verbatim}
log_vars is read only when the log_string contains var or VAR.  The choices
for variables are currently:
\begin{verbatim}
Average value on grid:   rho rhoUx rhoUy rhoUz Ux Uy Uz Bx By Bz P E
Value at the test point: rhopnt rhoUxpnt rhoUypnt rhoUxpnt Uxpnt Uypnt Uzpnt
                         Bxpnt Bypnt Bzpnt B1xpnt B1ypnt B1zpnt
                         Epnt Ppnt Jxpnt Jypnt Jzpnt
                         theta1pnt theta2pnt phi1pnt phi2pnt statuspnt
Ionosphere values:       cpcpn cpcps

Max or Min on grid:  Pmin Pmax
Flux values:         Aflx rhoflx Bflx B2flx pvecflx e2dflx
Other variables:     dt
\end{verbatim}
timetype values mean the following:
\begin{verbatim}
 none  = there will be no indication of time in the logfile (not even an
               # of steps)
 step  = # of time steps (n_steps)
 date  = time is given as an array of 7 integers:  year mo dy hr mn sc msc
 time  = time is given as a real number - elapsed time since the start of
         the run.  Units are determined by log_var and unitUSER_t
\end{verbatim}
these can be listed in any combination in the log_string line.\\
R_log is read only when one of the variables used is a 'flx' variable.  R_log
is a list of radii at which to calculate the flux through a sphere.
</command>

<command name="SATELLITE" if="$_IsFirstSession">
	<parameter name="nSatellite" type="integer" min="0" default="0" />
	<for from="1" to="$nSatellite">
		<parameter name="StringSatellite" type="strings"
							min="1" max="5">
			<part name="NameSatelliteVar" type="string" 
						 input="select" required="T">
				<option name="MHD variables"    value="MHD"
								default="T" />
				<option name="MHD vars. scaled" value="mhd" />
				<option name="All variables"    value="FUL" />
				<option name="All vars. scaled" value="ful" />
				<option name="Set variables"    value="VAR" />
				<option name="Set vars. scaled" value="var" />
			</part>
			<part name="OptionalVar" type="string" input="select"
						required="F" multiple="T">
				<option name="none" exclusive="T"/>
				<option name="step" />
				<option name="date" />
				<option name="time" />
				<option value="ray"/>
			</part>
		</parameter>
		<parameter name="DnOutput" type="integer" min="-1" 
							default="1" />
		<parameter name="DtOutput" type="real"    min="-1"
							default="-1" />
		<parameter name="NameTrajectoryFile" type="string" 
			length="100" />
		<rule expr="-f $NameTrajectoryFile">
			Trajectory file $NameTrajectoryFile must exist
		</rule>
		<parameter name="NameSatelliteVars" type="string" length="100"
			if="$NameSatelliteVar =~ /\bvar\b/i" />
	</for>
#SATELLITE
2                       nSatellite
MHD ray                 StringSatellite (variables and optional ray tracing)
100                     DnOutput
-1.                     DtOutput [sec]
satellite1.dat          NameTrajectoryFile
VAR step date           StringSatellite
100                     DnOutput
-1.                     DtOutput [sec]
satellite2.dat          NameTrajectoryFile
rho p                   NameSatelliteVars ! Read if StringSatellite 
                                          ! contains 'var' or 'VAR'
The numerical solution can be extracted along one or more satellite
trajectories. The number of satellites is defined by the 
nSatellite parameter (default is 0).

For each satellite the StringSatellite parameter determines what
is saved into the satellite file(s).
The StringSatellite can contain the following parts in arbitrary order
\begin{verbatim}
satellitevar   = 'mhd', 'ful' or 'var' (unitless output)
                 'MHD', 'FUL' or 'VAR' (dimensional output)
optionalvar    = 'ray', 'none', 'step', 'time', and/or 'date'
\end{verbatim}
The 'satellitevar' part is required and determines the list
of variables to be saved along the satellite trajectory. 
It also controls whether or not the variables will come out in
dimensional or non-dimensional form by the capitalization of the
satellitevars string: ALL CAPS means dimensional, all lower means 
dimensionless. 

If 'satellitevar' is set to 'mhd', the variables 
'rho ux uy uz bx by bz p jx jy jz' will be saved, while 'ful' implies
'rho ux uy uz bx by bz b1x b1y b1z p jx jy jz'.

If satellitevar is set to 'var' then the list of variables is read 
from the NameSatelliteVar parameter as a space separated list. 
The choices for variables are currently:
\begin{verbatim}
rho, rho, rhouy, rhouz, ux, uy, uz,Bx, By, Bz, B1x, B1y, B1z,
E, P, Jx, Jy, Jz, theta1, theta2, phi1, phi2, status.
\end{verbatim}

If the optional 'optionalvar' part contains 'ray' then the ray variables 
'theta1 phi1 theta2 phi2 status' are saved as well. 
The strings 'step', 'time' and 'date' define the corresponding
time information. The value 'none' means that no time information is saved.
\begin{verbatim}
 none  = there will be no indication of time in the logfile 
         (not even the number of steps),
 step  = number of time steps,
 date  = time is given as an array of 7 integers:  year mo dy hr mn sc msc,
 time  = time is given as a real number - elapsed time since the start of
         the run.  Units are determined by satellitevar and unitUSER_t.

 ray   = theta1 phi1 theta2 phi2 status
\end{verbatim}
More than one 'optionalvar' can be listed. They can be put together in any
combination.\\

\noindent
The DnOutput and DtOutput parameters determine the frequency of extracting
values along the satellite trajectories. \\

\noindent
The extracted satellite information is saved into the files named
\begin{verbatim}
PLOTDIR/sat_TRAJECTORYNAME_nTIMESTEP.sat
\end{verbatim}
where TIMESTEP is the number of time steps (e.g. 000925), 
and TRAJECTORYNAME is the name of the trajectory file.\\

\noindent
The default is nSatellite=0, i.e. no satellite data is saved.

Satellite input files contain the trajectory of the satellite.  They should
have to following format:
\begin{verbatim}
#COOR
GSM

#START
 2004  6  24   0   0  58   0  2.9  -3.1 - 3.7  
 2004  6  24   0   1  58   0  2.8  -3.2 - 3.6  
\end{verbatim}

The #COOR command is optional.  It indicates which coordinate system the data
represents.  The default is GSM, but others are possible.

The file containing the satellite trajectory should include data in the 
following order:
\begin{verbatim}
yr mn dy hr min sec msec x y z
\end{verbatim}
with the position variables in units of the body radii or the length scale
normalization.

The maximum number of lines of data allowed in the input file is 50,000.  
However, this can be modified by changing the variable Max_Satellite_Npts 
in the file GM/BATSRUS/ModIO.f90.
</command>

<command name="STEADYSTATESATELLITE" if="$_IsFirstSession">
	<parameter name="SatelliteTimeStart" type="real" default="0" />
	<parameter name="SatelliteTimeEnd" type="real" default="0" />
#STEADYSTATESATELLITE
-86400.0                     SatelliteTimeStart [sec]
86400.0                      SatelliteTimeEnd   [sec]
-3600.0                      SatelliteTimeStart [sec]
3600.0                       SatelliteTimeEnd   [sec]

In the non-time-accurate mode the numerical simulation result
converges to a steady-state solution. In the course of this simulation
mode, the progress in the iteration number is not associated with an
increase in the physical time, and the ultimate solution is a
"snapshot" of the parameter distribution at the time instant set by
the #STARTTIME command. Since time does not run, a satellite position
cannot be determined in terms of the simulation time. Instead, the
parameters along a cut of the satellite trajectory can be saved on
file for a given iteration number.  The trajectory points can be
naturally parameterized by time, so that the cut can be specified with
the choice of the start time, end time, and time interval.

The command #STEADYSTATESATELLITE is required for a steady-state
simulation.  For each of the satellites, the SatelliteTimeStart is a
real value that sets the start of trajectory cut, while
SatelliteTimeEnd sets the end of the trajectory cut. Both are in
seconds with respect to the time given in #STARTTIME. A negative
value means the is time prior to the #STARTTIME.

The DtOutput from the #SATELLITE command specifies the frequency of
the points along the satellite trajectory for the non-time-accurate
mode, while DnOutput keeps to control the iteration number at which
the data at the trajectory cut are written to the satellite output
file.

For more than one satellite (two satellites in the above given
example), the start and end times should be set for all of them.
</command>

<command name="GEOMAGINDICES">
	 <parameter name="nSizeKpWindow" type="integer" min="15" default="180"/>
	 <parameter name="DtOutput" type="real" min="-1" default="60"/>
#GEOMAGINDICES
180			nSizeKpWindow [min]
60.0			DtOutput      [sec]

BATS-R-US can create synthetic geomagnetic indices by first simulating
ground based measurements then processing these data into indices.
This allows for an apples-to-apples comparison of indices created by
the simulation against indices created from observations.  It is also
useful in an operational setting, where quick-look activity indices
are paramount.  #GEOMAGINDICES activates the calculation of such
indices.  Results are written at a time cadence of DtOutput to the
file geoindex_n[iteration].log

At present, only a synthetic version of Kp is available.
nSizeKpWindow, set in minutes and defaulting to 180 (3 hours), sets
the size of the time-history window used in the calculation of Kp.
Standard Kp uses a 3-hour window; versions of Kp used as operational
products use a window as short as 15-minutes.  Note that altering this
window requires a re-scaling of the K-index conversion tables inside
of the code.  As Kp is written to file, so are the individual
K-indices used in the calculation.  Offical Kp averages 13 K values
from 13 mid-latitude magnetometer stations around the globe.
Synthetic Kp from BATS-R-US uses 24 stations at fixed local time
positions and 50 degrees magnetic latitude.

Because Kp requires a time history of geomagnetic activity, special restart
files are saved when #GEOMAGINDICES is used.  If nSizeKpWindow changes between
restarts, however, the files will be rendered unuseable because the time 
history will no longer be valid for the calculation.

#GEOMAGINDICES should be used with the IE command of the same name.
This activates magnetometers in the IE component that are key for
properly capturing the magnetic pertubation from all current systems.
</command>

<command name="MAGNETOMETER">
	<parameter name="NameMagInputFile" type="string" length="100"/>
	<parameter name="DnOutput" type="integer" min="-1" default="-1"/>
	<parameter name="DtOutput" type="real"    min="-1" default="-1"/>
	<rule expr="-f $NameMagInputFile">
		Magnetogram position file $NameMagInputFile must exist
	</rule>
#MAGNETOMETER
magin.dat		NameMagInputFile
-1			DnOutput
60.0			DtOutput

The #MAGNETOMETER command is used for the calculation of the ground perturbations
caused by two current systems: 
field aligned currents in the 'gap' region and magnetopsheric currents.
No ionospheric currents are considered here. To calculate the ionospheric 
current effect, use the same command in the IE section, 
which will output the perturbation results in IE.

The NameMagInputFile parameter gives the file name that contains the
locations on the Earth where the user is interested in calculating 
the ground magnetic perturbations. The file has the following format:
\begin{verbatim}
#COORD
MAG			The coordinate system for the latitude/longitude below

#START
abc	20.0	120.0	The name of the station, latitude, longitude
def 	-30.0	230.0
ghi	85.0	-80.0
\end{verbatim}

The coordinate system accepts MAG (geomagnetic coordinate) or SMG 
(solar magnetic coordinate) so far. The station name can have maximum 3 characters.
The name, latitude, and longitude should be sperated with space in between.

The DnOutput and DtOutput parameters determine the frequency of writing out the
calculated perturbations in number of time steps and time interval, respectively.

The output of the ground-based magnetic perturbations is in GM/IO2/mag_n*.dat, 
in which the location of each station in GSM cartisian coordinates, the 3 components
(northward, eastward, and downward in SM coordiantes) of the magnetic perturbations by 
magnetospheric currents, and the 3 components (northward, eastward, and downward 
in SM coordiantes) of the magnetic perturbations by field-aligned currents are written 
out. The unit of the pertrubation output is nT.
</command>

<command name="SAVEPLOT">
	<parameter name="nPlotFile" type="integer" min="0" max="15"
		default="1" />
	<for name="iPlot" from="1" to="$nPlotFile">
		<parameter name="StringPlot" type="strings" min="3" max="3">
			<part name="plotform" type="string" input="select" 
								required="T">
				<option value="tec" name="TECPLOT"/>
				<option value="hdf" name="HDF5"/>
				<option value="idl" name="IDL" default="T"/>
				<option value="idl_real4" 
					name="IDL single prec"/>
				<option value="idl_real8" 
					name="IDL double prec"/>
				<option value="idl_ascii" name="IDL ascii"/>
			</part>
			<part name="plotarea" type="string" input="select"
								required="T">
				<option name="1D" value="1d/1d_"/>
				<option name="2D" value="2d/2d_"/>
				<option name="3D" value="3d/3d_"/>
				<option name="x=0" />
				<option name="y=0" default="T" />
				<option name="z=0" />
				<option name="sphere" value="sph" />
				<option name="los" />
				<option name="rfr" />
				<option name="line" value="lin" />
				<option name="eq.rays" value="eqr" />
				<option name="cut" />
				<option name="slice" value="slc" 
					if="$plotform =~ /\btec\b/"/>
				<option name="dipole" value="dpl" 
					if="$plotform =~ /\btec\b/"/>
				<option name="block" value="blk" 
					if="$plotform =~ /\btec\b/"/>
				<option name="1D" value="1d/1d_" 
					if="$plotform =~ /\btec\b/"/>
				<option name="ieb" />
				<option name="lcb" />
			</part>
			<part name="plotvar" type="string" required="T"
				input="select">
				<option name="MHD variables"    value="MHD" default="T"/>
				<option name="MHD vars. scaled" value="mhd"/>
				<option name="HD variables"    value="HD"/>
				<option name="HD vars. scaled" value="hd"/>
				<option name="All variables"    value="FUL"/>
				<option name="All vars. scaled" value="ful"/>
				<option name="Raw variables"    value="RAW"/>
				<option name="Raw vars. scaled" value="raw"/>
				<option name="Ray tracing vars."  value="RAY"/>
				<option name="Ray tracing scaled" value="ray"/>
				<option name="Flux variables"    value="FLX"/>
				<option name="Flux vars. scaled" value="flx"/>
				<option name="Solar variables"    value="SOL"/>
				<option name="Solar vars. scaled" value="sol"/>
				<option name="EUV image variables" value="euv"/>
				<option name="Tabular image variable"      value="tbl"/>
				<option name="Radio wave intensity" value="rwi"/>
				<option name="Position variables"    value="POS"  if="$plotarea eq 'lin'" />
				<option name="Position vars. scaled" value="pos"  if="$plotarea eq 'lin'"/>
				<option name="Equatorial rays" value="eqr"  if="$plotarea eq 'eqr'"/>
				<option name="Basic block variables"    value="BBK" />
				<option name="Basic block vars. scaled"	value="bbk" />
				<option name="Set variables"    value="VAR" />
				<option name="Set vars. scaled" value="var"/>
				<option name="Integrated variables"    value="INT" />
				<option name="Integrated vars. scaled" value="int"/>
				<option name="NULL - irrelevant" value="nul"/>
			</part>
		</parameter>
		<parameter name="DnSavePlot" type="integer" min="-1" 
							default="-1"/>
		<parameter name="DtSavePlot" type="real"    min="-1" 
							default="-1.0"/>
		<if expr="$plotarea =~ /\bdpl|cut|slc\b/">
			<parameter name="xMinCut" type="real" />
			<parameter name="xMaxCut" type="real" min="$xMinCut"/>
			<parameter name="yMinCut" type="real" />
			<parameter name="yMaxCut" type="real" min="$yMinCut"/>
			<parameter name="zMinCut" type="real" />
			<parameter name="zMaxCut" type="real" min="$zMinCut"/>
		</if>
		<if expr="$plotarea =~ /\bslc\b/">
			<parameter name="xPoint"  type="real" />
			<parameter name="yPoint"  type="real" />
			<parameter name="zPoint"  type="real" />
			<parameter name="xNormal" type="real" />
			<parameter name="yNormal" type="real" />
			<parameter name="zNormal" type="real" />
		</if>
		<if expr="$plotarea =~ /\bblk\b/">
			<parameter name="xPoint"  type="real" />
			<parameter name="yPoint"  type="real" />
			<parameter name="zPoint"  type="real" />
		</if>
		<parameter name="Radius" type="real" min="0" default="10"
			if="$plotarea =~ /\bsph\b/" />
                <if expr="$plotarea =~ /\blos\b/">
			<parameter name="ObsPosX" type="real" default="-215"/>
			<parameter name="ObsPosY" type="real" default="0"/>
			<parameter name="ObsPosZ" type="real" default="0"/>
			<parameter name="OffsetAngle" type="real" 
					min="-89" max="89" default="0"/>
			<parameter name="rSizeImage" type="real" min="0"
								default="32"/>
			<parameter name="xOffset" type="real" default="0"/>
			<parameter name="yOffset" type="real" default="0"/>
			<parameter name="rOccult" type="real" min="0" 
								default="2"/>
			<parameter name="MuLimbDarkening" type="real" 
						min="0" max="1" default="0.5"/>
			<parameter name="nPix" type="integer" min="2"
								default="200"/>
			<parameter name="NameLosTable" type="string" length="100"
				   if="$plotvar =~ /tbl/i"/>
                </if>
		<if expr="$plotarea =~ /\blin\b/">
			<parameter name="NameLine" type="string" 
			input="select">
				<option name="Advected magnetic field line" 
								value="A" />
				<option name="Magnetic field line" value="B"
								default="T"/>
				<option name="Stream line"  value="U"/>
				<option name="Current line" value="J"/>
			</parameter>
			<parameter name="IsSingleLine" type="logical"
							default="F" />
			<parameter name="nLine" type="integer" min="1" max="20"
							default="1" />
			<for name="i" from="1" to="$nLine">
				<parameter name="xStartLine" type="real"/>
				<parameter name="yStartLine" type="real"/>
				<parameter name="zStartLine" type="real"/>
				<parameter name="IsParallel" type="logical"/>
			</for>
		</if>
		<if expr="$plotarea =~ /\beqr\b/">
			<parameter name="nRadius" type="real" min="1" default="20"/>
			<parameter name="nLon"    type="real" min="1" default="25"/>
			<parameter name="RadiusMin" type="real" min="1" default="3"/>
			<parameter name="RadiusMax" type="real" min="1" default="10"/>
		</if>
		<if expr="$plotarea =~ /\blcb\b/">
			<parameter name="Radius"  type="integer" min="0." default="6."/>
			<parameter name="nLon"    type="real"    min="4"  default="36"/>
		</if>
		<parameter name="DxSavePlot" type="real" min="-1.0" 
							default="-1.0"
	if="($plotform=~/\bidl/ and $plotarea!~/\b(sph|los|rfr|lin|eqr)\b/)" />
		<if expr="$plotvar =~ /\bvar\b/i">
			<parameter name="NameVars" type="string" length="100"/>
			<parameter name="NamePars" type="string" length="100"/>
		</if>
	</for>
#SAVEPLOT
16			nPlotfile
3d  MHD tec		StringPlot ! 3d plot with MHD data
100			DnSavePlot
-1.			DtSavePlot
2d  FUL hdf		StringPlot ! 2d HDF plot with a lot of data
100			DnSavePlot
-1.			DtSavePlot
y=0 VAR idl		StringPlot ! y=0 plane plot with listed variables
-1			DnSavePlot
100.			DtSavePlot
0.25			DxSavePlot ! resolution (for IDL plots)
jx jy jz		NameVars
g rbody			NamePars
cut ray idl_real8	StringPlot ! 3D cut IDL (ONLY!) plot with raytrace info
1			DnSavePlot
-1.			DtSavePlot
-10.			xMinCut    
10.			xMaxCut    
-10.			yMinCut    
10.			yMaxCut    
-10.			zMinCut    
10.			zMaxCut    
-1.			DxSavePlot ! unstructured grid (for IDL plots)
sph flx idl_ascii	StringPlot ! spherical plot
-1			DnSavePlot
100.			DtSavePlot
4.			Radius     ! of spherical surface
los tbl idl_real4       StringPlot ! line of sight plot using table
-1			DnSavePlot
100.			DtSavePlot
-215.			ObsPosX
0.			ObsPosY
0.			ObsPosZ
0.                      OffsetAngle
32.			rSizeImage
0.			xOffset
0.			yOffset
3.			rOccult
0.5			MuLimbDarkening
300			nPix
AiaXrt			NameLosTable
lin mhd idl		StringPlot  ! field line plot
-1			DnSavePlot
10.			DtSavePlot
B			NameLine ! B - magnetic field line, U - stream line
F			IsSingleLine
2			nLine
-2.0			xStartLine
0.0			yStartLine
3.5			zStartLine
F			IsParallel
-1.0			xStartLine
1.0			yStartLine
-3.5			zStartLine
T			IsParallel
dpl MHD tec		StringPlot  ! dipole slice Tecplot (ONLY!) plot
-1			DnSavePlot
10.			DtSavePlot
-10.			xMinCut
 10.			xMaxCut
-10.			yMinCut
 10.			yMaxCut
-10.			zMinCut
 10.			zMaxCut
slc MHD tec		StringPlot  ! general slice Tecplot (ONLY!) plot
-1			DnSavePlot
10.			DtSavePlot
-10.			xMinCut
 10.			xMaxCut
-10.			yMinCut
 10.			yMaxCut
-10.			zMinCut
 10.			zMaxCut
 0.			xPoint
 0.			yPoint
 0.			zPoint
  0.			xNormal
  0.			yNormal
  1.			zNormal
blk MHD tec		StringPlot  ! general block Tecplot (ONLY!) plot
-1			DnSavePlot
10.			DtSavePlot
 5.			xPoint
 1.			yPoint
 1.			zPoint
1d  BBK tec		StringPlot ! 1d plot with BLK data, Tecplot (ONLY!)
1000			DnSavePlot
-1.			DtSavePlot
rfr rwi tec             StringPlot
10                      DnSavePlot
-1.0                    DtSavePlot
150.0                   ObsPosX
145.7                   ObsPosY 
50.0                    ObsPosZ
10MHz, 42.3MHz, 100MHz     StringRadioFrequency
20.0                    X_Size_Image
20.0                    Y_Size_Image
200                     n_Pix_X
200                     n_Pix_Y
eqr eqr idl		StringPlot
1000                    DnSavePlot
-1.                     DtSavePlot
20			nRadius
25			nLon
3.0			RadiusMin
10.0			RadiusMax
ieb nul tec             StringPlot  !IE grid field line plots
1000                    DnSavePlot
-1.                     DtSavePlot
lcb nul tec             StringPlot  !last closed field line plots
1000                    DnSavePlot
-1.                     DtSavePlot
6.			Radius
36			nLon
lcb int tec             StringPlot  !last closed field line plots with integrals stored
1000                    DnSavePlot
-1.                     DtSavePlot
6.			Radius
36			nLon

Default is nPlotFile=0. \\

\noindent
StringPlot must contain the following 3 parts in the following order
\begin{verbatim}
plotform plotarea plotvar

plotform = 'tec', 'hdf', 'idl', 'idl_real4', 'idl_real8', 'idl_ascii'
plotarea = '1d', '2d', '3d' , 'x=0', 'y=0', 'z=0', 'cut', 'dpl', 'slc', 'sph', 'los', 'lin', 'blk', 'rfr', 'eqr', 'ieb', 'lcb'
plotvar  = 'mhd', 'hd', 'ful', 'raw', 'ray', 'flx', 'sol', 'euv', 'sxr', 'tbl', 'pos', 'var', 'bbk' 'rwi' 'int' 'nul' - normalized
plotvar  = 'MHD', 'hd', 'FUL', 'RAW', 'RAY', 'FLX', 'SOL', 'EUV', 'SXR', 'TBL', 'pos', 'VAR', 'BBK' 'RWI' 'INT' 'NUL' - dimensional
\end{verbatim}
NOTES: The plotvar option 'sol' is only valid for plotarea 'los';
       The plotvar option 'euv' is only valid for plotarea 'los';
       The plotvar option 'sxr' is only valid for plotarea 'los';
       The plotvar option 'tbl' is only valid for plotarea 'los';
       the plotvar option 'pos' is only valid for plotarea 'lin'.
       the plotvar option 'rwi' is only valid for plotarea 'rfr'.
\\

\noindent
The plotform string selects the output to be usable for 
Tecplot (tec), VISIT (hdf), or IDL (idl*) visualization software. 
The HDF output works only if the HDF library is installed, 
the appropriate parallel HDF module is loaded and BATSRUS is 
configured with the -hdf flag.
The IDL output can be written as single
precision binary (idl_real4), double precision binary (idl_real8) 
or ASCII file (idl_ascii). The default is 'idl_real4' that can also 
be written simply as 'idl'.

The plotarea string defines the 1, 2, or 3D volume of the plotting area:
\begin{verbatim}
1d    - 1D cut along the X axis (saves tree file)
2d    - 2D cut (like Z=0)       (saves tree file)
3d    - full 3D volume          (saves tree file)
x=0   - full x=0 plane: average for symmetry plane
y=0   - full y=0 plane: average for symmetry plane
z=0   - full z=0 plane: average for symmetry plane
cut   - 3D, 2D or 1D rectangular cut (IDL)/ a 2D rectangular cut (Tecplot)
dpl   - cut at dipole 'equator', uses PLOTRANGE to clip plot
slc   - 2D slice defined with a point and normal, uses PLOTRANGE to clip plot
sph   - spherical surface cut at the given radius
los   - line of sight integrated plot
lin   - one dimensional plot along a field or stream or current line
blk   - 3D single block cell centered data, block specified point location
rfr   - radiotelescope pixel image plot
eqr   - field lines traced from the magnetic equatorial plane
ieb   - field lines traced from a subset of the IE coupled grid
lcb   - last closed field lines
\end{verbatim}
The 1d, 2d and 3d cuts save the AMR tree information into a .tree file.
This can be used for reconstructing the full grid and use the data
with the READAMR library, for example. 

The plotvar string defines the plot variables and the equation parameters.
It also controls whether or not the variables will be plotted in dimensional
values or as non-dimensional values:
\begin{verbatim}
 ALL CAPS  - dimensional
 all lower - dimensionless

 'mhd' - vars: rho Ux Uy Uz E Bx By Bz P Jx Jy Jz
         pars: g rbody
 'hd'  - vars: rho Ux Uy Uz E P
         pars: g rbody
 'ful' - vars: rho Ux Uy Uz E Bx By Bz B1x B1y B1z P Jx Jy Jz
         pars: g rbody
 'raw' - vars: rho rhoUx rhoUy rhoUz E Bx By Bz P b1x b1y b1z divb
         pars: g rbody
 'ray' - vars: bx by bz theta1 phi1 theta2 phi2 status blk
         pars: R_ray
 'flx' - vars: rho rhoUr Br jr pvecr
         pars: g eta
 'var' - vars: READ FROM PARAMETER FILE
         pars: READ FROM PARAMETER FILE
 'sol' - vars: wl pb
         pars: mu
 'euv' - vars: euv171 euv195 euv284
         pars:
 'sxr' - vars: sxr
         pars:
 'tbl' - vars: listed in the LOS table file
         pars:
 'bbk' - vars: dx pe blk blkall
         pars: 
 'rwi' - vars: Intensity
         pars: 
 'int' - vars: 1/B n/B p/B
         pars: 
 'nul' - vars: 
         pars: 
\end{verbatim}
The plot_string is always followed by the plotting frequencies
DnSavePlot and DtSavePlot.\\

\noindent
Depending on StringPlot, further information is read from the parameter file
in this order:
\begin{verbatim}
 PlotRange		if plotarea is 'cut', 'dpl', or 'slc'
 Point			if plotarea is 'slc', or 'blk'
 Normal			if plotarea is 'slc'
 DxSavePlot		if plotform is 'idl' and plotarea is not sph, ion, los
 Radius                 if plotarea is 'sph'
 NameVars		if plotform is 'var'
 NamePars		if plotform is 'var'
\end{verbatim}
The PlotRange is described by 6 coordinates. 
For IDL plots, if the width in one or two 
dimensions is less than the smallest cell size within the plotarea, 
then the plot file will be 2 or 1 dimensional, respectively.
If the range is thin but symmetric about one of the x=0, y=0, or z=0 planes, 
data will be averaged in the postprocessing.\\

For Tecplot (tec) file and 'cut', Plotrange is read but 
only 1 dimension is used.  
Cuts are entire x, y, or z = constant planes (2D only, 1D or 3D cuts are not
implemented.  For x=constant, for example, the y and z ranges 
do not matter as long at they are "wider" than the x range.  The slice will be 
located at the average of the two x ranges.  So, for example to save a plot in
a x=-5 constant plane cut in tec. The following would work for the plot range:
\begin{verbatim}
 -5.01			xMinCut
 -4.99			xMaxCut
 -10.			yMinCut
  10.			yMaxCut
 -10.			zMinCut
  10.			zMaxCut
\end{verbatim}
The 'dpl' and 'slc' Tecplot plots use Plotrange like the IDL plots, and will
clip the cut plane when it exits the defined box.

\noindent
Point is described by the coordinate of any point on the cut plane, often the origin,
or inside of a 3D block. Normal is the coordinate of a vector normal to the plane.  
If the normal in any given coordinate direction is less than 0.01, 
then no cuts are computed for cell edges parallel to that coordinate direction.
For example, the following would result in only computing cuts on cell 
edges parallel to the Z axis.
\begin{verbatim}
  0.0			xNormal
  0.0			yNormal
  1.0			zNormal
\end{verbatim}

\noindent
Possible values for DxSavePlot (for IDL files):
\begin{verbatim}
  any positive value	- fixed resolution
  0.	- fixed resolution based on the smallest cell in the plotting area
 -1.	- unstructured grid will be produced by PostIDL.exe
\end{verbatim}
Radius is the radius of the spherical cut for plotarea='sph'

The line-of-sight (plotarea 'los') plots calculate integrals along the
lines of sight of some quantity and create a 2D Cartesian square
shaped grid of the integrated values. Only the circle enclosed in the
square is actually calculated and the corners are filled in with
zeros.  The image plane always contains the origin of the
computational domain (usually the center of the Sun).  By default the
image plane is orthogonal to the observers position relative to the
origin. The image plane can be rotated around the Z axis with an
offset angle. By default the center of the image is the observer
projected onto the image plane, but the center of the image can be
offset.  Since the central object (the Sun) contains extremely large
values, an occultational disk is used to block the lines of sight
going through the Sun.  The variables which control the direction of
the lines of sight and the grid position and resolution are the
following:

\begin{verbatim}
 ObsPosX,ObsPosY,ObsPosZ - the position of the observer in (rotated) 
                           HGI coordinates (SC,IH and OH) or the GM coordinates
 rSizeImage             - the radius of the LOS image
 xOffset, yOffset       - offset relative to the observer projected onto 
                          the image plane 
 rOccult                - the radius of the occulting disk
 MuLimbDarkening        - the limb darkening parameter for the 'wl' 
                          (white light) and 'pb' (polarization brightness) 
                          plot variables.
 nPix                   - the number of pixels in each direction
\end{verbatim}

For line-of-site Extreme Ultraviolet (EUV) and Soft X-Ray (SXR) plots,
the same parametes are read as for the wl and pb plots (above) but now
the integration is carried out to the surface of the sun so rOccult should
be set to zero. MuLimbDarkening has no effect but needs to be included.

Additionally, because EUV and SXR plots are configured to read in a response
table specific to the EUV or SXR instument (e.g. SOHO EIT, STEREO EUVI,
Yohkoh SXT) the tables for the response need to be read in by additional
lines in the PARAM.in file. This follows the #LOOKUPTABLE command 
syntax e.g:

\begin{verbatim}
#LOOKUPTABLE
euv                     NameTable
load                    NameCommand
SC/Param/los_Eit.dat     NameFile
ascii                   TypeFile

#LOOKUPTABLE
sxr                     NameTable
load                    NameCommand
SC/Param/los_Sxt.dat     NameFile
ascii                   TypeFile
\end{verbatim}

\noindent
The possible values for NameVars with plotarea 'los' 
are listed in subroutine set_plotvar_los in write_plot_los.f90. \\


The radiotelescope pixel image (plotarea 'rfr') plots present the
plasma emissivity integrals along the ray trajectories within a 2D
Cartesian square shaped grid. The radiowave rays with the frequencies 
on the order of tens of MegaHertz undergo significant refraction
when travelling through non-uniform space plasmas; hence the name
'rfr'. The radio wave raytracing is performed by a modification of 
the Boris's algorithm. The image plane center coincides with
the origin of the computational domain (usually the center of the Sun).
The observer's position is specified at an arbitrary point of the
solar system. The image plane is always orthogonal to the straight
line connecting the observer with the center of the sun.
The following variables specify the observer's position, the image 
plane size, the resolution, and the radio frequencies at which 
the plasma emissivity is integrated:
\begin{verbatim}
 ObsPosX,ObsPosY,ObsPosZ - the position of the observer in (rotated) 
                           HGI coordinates (SC, IH and OH) or the GM coordinates
 StringRadioFrequency    - set of frequencies. The number of frequencies
			   determines the number of plots, one for each
			   frequency. A frequency is specified as a number 
			   followed by a frequency unit. The units are
			   Hz, kHz, MHz, GHz, or THz.
 X_Size_Image, Y_Size_Image - X and Y dimensions of the image plane in 
			      solar radii
 n_Pix_X,  n_Pix_Y       - the number of pixels in X and Y directions
\end{verbatim}

\noindent
The only possible values for NameVars with plotarea 'rfr' is 'rwi'. \\ 

\noindent
The possible values for NameVars for other plot areas
are listed in subroutine set_plotvar in write_plot_common.f90.\\

\noindent
The possible values for NamePars are listed in subroutine 
set_eqpar in write_plot_common.f90\\

A plot file is produced by each processor.  This file is ASCII in 'tec'
format and can be either binary or ASCII in 'idl' format as chosen under
the #SAVEBINARY flag.  The name of the files are
\begin{verbatim}
 IO2/plotarea_plotvar_plotnumber_timeinfo_PEnumber.extension
\end{verbatim}
where extension is 'tec' for the TEC and 'idl' for the IDL file formats.
The plotnumber goes from 1 to nplot in the order of the files in PARAM.in.
The 'timeinfo' contains simulation time as hours-minutes-seconds
(for time accurate runs only), and time step number.
Spherical plot area 'sph' creates two files per processor starting with
'spN' and 'spS' for the northern and southern hemispheres, respectively.  

After all processors wrote their plot files, processor 0 writes a small 
ASCII header file named as
\begin{verbatim}
 IO2/plotarea_plotvar_plotnumber_timestep.headextension
\end{verbatim}
where headextension is:
\begin{verbatim}
           'T' for TEC file format
           'S' for TEC and plot_area 'sph' 
           'h' for IDL file format       
\end{verbatim}

\noindent
The line of sight integration produces TecPlot and IDL files directly:
\begin{verbatim}
 IO2/los_plotvar_plotnumber_timestep.extension
\end{verbatim}
where extension is 'dat' for TecPlot and 'out' for IDL file formats.
The IDL output from line of sight integration is always in ASCII format.

</command>

<command name="SAVEPLOTNAME">
	<parameter name="IsPlotName_n" type="logical" default="T" />
	<parameter name="IsPlotName_t" type="logical" default="T" />
	<parameter name="IsPlotName_e" type="logical" default="F" />
#SAVEPLOTNAME
T			IsPlotName_n
T			IsPlotName_t
F			IsPlotName_e

Plot files are named with the preferred set of substrings.
     _n is interation number, ie. _n0000127
     _t is simulation time, ie. _t00000010
     _e is event time, ie. _e20000321-104510-000
</command>

<command name="SAVELOGNAME">
	<parameter name="IsLogName_n" type="logical" default="T" />
	<parameter name="IsLogName_e" type="logical" default="F" />
#SAVELOGNAME
T			IsLogName_n
F			IsLogName_e

Log files are named with the preferred set of substrings.
     _n is interation number, ie. _n000000
     _e is event time, ie. _e20000321-104500
</command>

<command name="SAVEBINARY">
	<parameter name="DoSaveBinary" type="logical" default="T" />
#SAVEBINARY
T			DoSaveBinary   used only for 'idl' plot file

Default is .true. Saves unformatted IO2/*.idl files if true. 
This is the recommended method, because it is fast and accurate.
The only advantage of saving IO2/*.idl in formatted text files is
that it can be processed on another machine or with a different 
(lower) precision. For example PostIDL.exe may be compiled with 
single precision to make IO2/*.out files smaller, while BATSRUS.exe is 
compiled in double precision to make results more accurate.
</command>

<command name="PLOTFILENAME" multiple="T">
	<parameter name="NameMaxTimeUnit" type="string" input="select">
		<option name="date"/>
		<option name="year"/>
		<option name="yr"/>
		<option name="month"/>
		<option name="day"/>
		<option name="hour" default="T"/>
		<option name="hr"/>
		<option name="minute"/>
		<option name="second"/>
		<option name="millisecond"/>
		<option name="microsecond"/>
		<option name="nanosecond"/>
        <option name="timestep"/>
	</parameter>
#PLOTFILENAME
hour			NameMaxTimeUnit

For time accurate runs the plot filenames contain an 8-charcter timestamp 
string. The NameMaxTimeUnit string determines the content of this string.

If the longest time unit is hours or shorter, the string contains the
simulation time. If the time unit is days or longer the string contains
the physical date (set by the #STARTTIME command) and time information.

For NameMaxTimeUnit='hour' the string contains the simulation time 
described by a 4-character string for hours, and two 2-character strings 
for minutes and seconds, respectively. 
For NameMaxTimeUnit='hr' the string contains the simulation time 
described by a 2-character strings for hours, minutes, and seconds
with a decimal point and one decimal digit. For NameMaxTimeUnit='minute'
the first 2 characters describe the minutes, and the rest is seconds
including 3 decimal digits. NameMaxTimeUnit='second' gives
the simulation time up to 100 seconds with 5 decimal digits.
NameMaxTimeUnit='millisecond' ('microsecond', 'nanosecond') give
the simulation time up to 1000 milliseconds (microseconds, nanoseconds)
with 4 decimal digits.

For time unit 'date' the full 14-character date-time string 
(YYYYMMDDHHMMSS) is used.
For time units 'day', 'month', 'yr' and 'year' an 8-character-long substring 
of the date-time string is used.
For NameMaxTimeUnit='year' the time stamp will contain the four digit year,
and the two-digit month and day.
For NameMaxTimeUnit='yr' the last two digits of the year, 
and the month, day and hour are used. 
For NameMaxTimeUnit='month' the month, day, hour, and minute are used.
For NameMaxTimeUnit='day' the day, hour, minute and seconds are used.
For NameMaxTimeUnit='timestep' only the timestep is used.

The #PLOTFILENAME command and the NameMaxTimeUnit parameter are 
saved into the restart header file so that the #PLOTFILENAME command does
not have to be repeated in restarted runs (unless the unit is changed).

The default value is NameMaxTimeUnit='hour'.
</command>

<command name="SAVEINITIAL">
	<parameter name="DoSaveInitial" type="logical" default="F" />
#SAVEINITIAL
T			DoSaveIntial

Save plots and log/satellite files at the beggining of the session.
Default is DoSaveInitial=.false. except for the first time accurate
session (when simulation time is zero) when the initial state 
is always saved.
</command>

<command name="SAVEPLOTSAMR">
	<parameter name="DoSavePlotsAmr" type="logical" default="F" />
#SAVEPLOTSAMR
F			DoSavePlotsAmr

Save plots before each AMR. Default is DoSavePlotsAMR=.false.
</command>

<command name="FLUSH">
	<parameter name="DoFlush" type="logical" default="T"/>

#FLUSH
F			DoFlush

If the DoFlush variable is true, the output is flushed when
subroutine ModUtility::flush_unit is called. This is used in the 
log and satellite files. The flush is useful to see the output immediately, 
and to avoid truncated files when the code crashes,
but on some systems the flush may be very slow. 

The default is to flush the output, i.e. DoFlush=T.
</command>
</commandgroup>
<commandgroup name="AMR PARAMETERS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!  AMR PARAMETERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="AMRINITPHYSICS" if="$_IsFirstSession">
	<parameter name="nRefineLevelIC" type="integer" min="0" default="0" />
#AMRINITPHYSICS
3			nRefineLevelIC

Defines number of physics (initial condition) based AMR-s AFTER the 
geometry based grid refinement was finished.
Only useful if the initial condition has a non-trivial analytic form.
</command>

<command name="AMRREGION" multiple="T">
	<set name="RotateArea" value="0"/>
	<set name="StretchArea"  value="0"/>
        <parameter name="NameRegion" type="string"/>
	<parameter name="Resolution" type="real" min="0"
		if="$_command =~ /RESOLUTION/" />
	<parameter name="nLevel" type="integer" min="0" max="30"
		if="$_command =~ /LEVEL/" />
	<parameter name="StringArea" type="strings" min="1" max="3"
		case="lower">
		<part name="NameArea" type="string" input="select" 
							required="T">
			<option name="all"				/>
			<option name="box"				/>
			<option name="box_gen"				/>
			<option name="brick"				/>
			<option name="brick_gen"			/>
			<option name="brick0"				/>
			<option name="brick_gen0"			/>
			<option name="sphere"				/>
			<option name="sphere0"				/>
			<option name="shell"				/>
			<option name="shell0"				/>
			<option name="cylinderx"			/>
			<option name="cylinderx0"			/>
			<option name="cylindery"			/>
			<option name="cylindery0"			/>
			<option name="cylinderz"			/>
			<option name="cylinderz0"			/>
			<option name="ringx"				/>
			<option name="ringx0"				/>
			<option name="ringy"				/>
			<option name="ringy0"				/>
			<option name="ringz"				/>
			<option name="ringz0"				/>
			<option name="currentsheet"			/>
			<option name="user"				/>
		</part>
		<part name="StretchArea" type="string" input="select"
			required="F"
			if="$NameArea =~ /sphere|shell|cylinder|ring/">
			<option name="stretched" />
		</part>
		<part name="RotateArea" type="string" input="select" 
			required="F" 
			if="$NameArea =~ /box\b|brick0?\b|cylinder|ring/">
			<option name="rotated" />
		</part>
	</parameter>
	<if expr="$NameArea !~ /box|all|initial|currentsheet|user|0/">
		<parameter name="xCenter" type="real" default="0"/>
		<parameter name="yCenter" type="real" default="0"/>
		<parameter name="zCenter" type="real" default="0"/>
	</if>
	<if expr="$NameArea =~ /box/">
		<parameter name="xMinBox" type="real" />
		<parameter name="yMinBox" type="real" />
		<parameter name="zMinBox" type="real" />
		<parameter name="xMaxBox" type="real" />
		<parameter name="yMaxBox" type="real" />
		<parameter name="zMaxBox" type="real" />
	</if>
	<if expr="$NameArea =~ /brick/">
		<parameter name="xSizeBrick" type="real" min="0" />
		<parameter name="ySizeBrick" type="real" min="0" />
		<parameter name="zSizeBrick" type="real" min="0" />
	</if>
	<if expr="$NameArea =~ /sphere/">
		<parameter name="Radius"  type="real" min="0"/>
	</if>
	<if expr="$NameArea =~ /shell/">
		<parameter name="Radius1" type="real" min="0"/>
		<parameter name="Radius2" type="real" min="0"/>
	</if>
	<if expr="$NameArea =~ /cylinder/">
		<parameter name="LengthCylinder" type="real" min="0" />
		<parameter name="Radius"         type="real" min="0" />
	</if>
	<if expr="$NameArea =~ /ring/">
		<parameter name="HeightRing" type="real" min="0" />
		<parameter name="Radius1"    type="real" min="0" />
		<parameter name="Radius2"    type="real" min="0" />
	</if>
	<if expr="$StretchArea =~ /stretched/">
		<parameter name="xStretch" type="real" min="0" default="1"/>
		<parameter name="yStretch" type="real" min="0" default="1"/>
		<parameter name="zStretch" type="real" min="0" default="1"/>
	</if>
	<if expr="$RotateArea =~ /rotated/">
		<parameter name="xRotate" type="real" min="-360" max="360" 
								default="0"/>
		<parameter name="yRotate" type="real" min="-360" max="360" 
								default="0"/>
		<parameter name="zRotate" type="real" min="-360" max="360" 
								default="0"/>
	</if>

#AMRREGION
tailbox			NameRegion
box			NameArea
-64.0			xMinBox
-16.0			yMinBox
-16.0			zMinBox
-32.0			xMaxBox
 16.0			yMaxBox
  0.0			zMaxBox


#AMRREGION
tailbox			NameRegion
brick			NameArea
-48.0			xCenter
  0.0			yCenter
 -8.0			zCenter
 32.0			xSizeBrick
 32.0			ySizeBrick
 16.0			zSizeBrick

#AMRREGION
tailbox			NameRegion
shell0			NameArea
3.5			Radius1
4.5			Radius2

#AMRREGION
tailbox			NameRegion
sphere			NameArea
-10.0			xCenterSphere
 10.0			yCenterSphere
  0.0			zCenterSphere
 20.0			rSphere

#AMRREGION
tailbox			NameRegion
cylinderx		NameArea
-30.0			xCenter
  0.0			yCenter
  0.0			zCenter
 60.0			LengthCylinder
 20.0			rCylinder

#AMRREGION
tailbox			NameRegion
ringz0 rotated		NameArea
  5.0			HeightRing
 20.0			Radius1
 25.0			Radius2
 10.0			xRotate
 10.0			yRotate
  0.0			zRotate

#AMRREGION
tailbox			NameRegion
sphere0 stretched	NameArea
10.0			rSphere
1.0			xStretch
3.0			yStretch
2.0			zStretch

#AMRREGION
tailbox			NameRegion
user			NameArea

The #AMRREGION comand allow us to make a library of areas in the simulation 
domain idenifed by a unique NameRegion to be used with the #AMRCRITERIALEVEL
or #AMRCRITERIARESOLUTION comand to define where a criteria geometricly will 
be evaluated or not. 

For other values of NameArea, the command specifies the shape of the area. 
where the blocks are to be refined. If the desired grid resolution is finer
than the initial resolution, then initially the grid will be refined
to the initial resolution only, but the area will be further refined 
in subsequent pre-specified adaptive mesh refinements (AMRs) during the run 
(see the #AMR command). Once the resolution reaches the
desired level, the AMR-s will not do further refinement. If a grid block
is covered by more than one areas, the area with the finest resolution
determines the desired grid resolution.

All computational blocks that intersect the area and have a coarser
resolution than the resolution set for the area are selected for refinement.
There are the following basic shapes: 
'all', 'box', 'box_gen', 'brick', 'brick_gen', 'sphere', 'shell', 'cylinderx', 
'cylindery', 'cylinderz', 'ringx', 'ringy' and 'ringz'.

The area 'all' refers to the whole computational domain, and it can be
used to set the overall minimum resolution. The area 'box' is a box
aligned with the X, Y and Z axes, and it is given with the coordinates
of two diagonally opposite corners. The area 'brick' has the same shape
as 'box', but it is defined with the center of the brick and the 
size of the brick. The 'box_gen' and 'brick_gen' areas can be used 
for non-Cartesian grids to define a box in the generalized coordinates.
For example a sphere around the origin can be described as a box in 
generalized coordinates with radius going from 0 to R, 
phi going from 0 to 360 degrees and latitude going from -90 to +90 degrees.
Note that angles are given in degrees, and radius is given even if the 
generalized coordinates use its logarithm.

The area 'sphere' is a sphere around an arbitrary point,
which is defined with the center point and the radius of the sphere.
The area 'shell' consists of the volume between two concentric spherical
surfaces, which is given with the center point and the two radii.
The area 'cylinderx' is a cylinder with an axis parallel with the X axis,
and it is given with the center, the length of the axis and the radius,
The areas 'cylindery' and 'cylinderz' are cylinders parallel with the 
Y and Z axes, respectively, and are defined analogously as 'cylinderx'.
The area 'ringx', 'ringy' and 'ringz' are the volumes between 
two cylindrical surfaces parallel with the X, Y and Z axes, respectively.
The ring area is given with the center, the height and the two radii.
Note that all these round shapes can be made elliptical with the 
"stretched" option (see below).

If the area name contains the number '0', the center is taken to be at the 
origin and the center coordinates are not read. Note that the areas 'box'
and 'box_gen' are defined with the corners so the '0' cannot be used for these.

If the word 'stretched' is added after the area name, the area can be 
stretched in the X, Y and Z directions. This allows making
an ellipsoid from a sphere, or an elliptical slab from a cylinder.
Also useful to distort shells and rings.

If the word 'rotated' is added after the area name, the area can be 
rotated by 3 angles around the X, Y and Z axes in this order. Only the
areas 'box', 'brick', 'cylinder*' and 'ring*' can be rotated.

The 'currentsheet' area is defined as the blocks containing a reversal of the 
radial magnetic field. This is mostly useful for the solar corona and 
heliosphere. This special area type cannot be stretched, rotated or centered.

The 'user' area results in a call of the subroutine user_specify_refinement 
defined in the user module. The user can define an arbitrary set of criteria 
for refinement.  Again, stretching, rotation and centering cannot be applied 
to the 'user' area.
</command>

<command name="GRIDRESOLUTION" alias="GRIDLEVEL" multiple="T">
	<set name="RotateArea" value="0"/>
	<set name="StretchArea"  value="0"/>
	<parameter name="Resolution" type="real" min="0"
		if="$_command =~ /RESOLUTION/" />
	<parameter name="nLevel" type="integer" min="0" max="30"
		if="$_command =~ /LEVEL/" />
	<parameter name="StringArea" type="strings" min="1" max="3"
		case="lower">
		<part name="NameArea" type="string" input="select" 
							required="T">
			<option name="initial"		default="T" 	/>
			<option name="all"				/>
			<option name="box"				/>
			<option name="box_gen"				/>
			<option name="brick"				/>
			<option name="brick_gen"			/>
			<option name="brick0"				/>
			<option name="brick_gen0"			/>
			<option name="sphere"				/>
			<option name="sphere0"				/>
			<option name="shell"				/>
			<option name="shell0"				/>
			<option name="cylinderx"			/>
			<option name="cylinderx0"			/>
			<option name="cylindery"			/>
			<option name="cylindery0"			/>
			<option name="cylinderz"			/>
			<option name="cylinderz0"			/>
			<option name="ringx"				/>
			<option name="ringx0"				/>
			<option name="ringy"				/>
			<option name="ringy0"				/>
			<option name="ringz"				/>
			<option name="ringz0"				/>
			<option name="currentsheet"			/>
			<option name="user"				/>
		</part>
		<part name="StretchArea" type="string" input="select"
			required="F"
			if="$NameArea =~ /sphere|shell|cylinder|ring/">
			<option name="stretched" />
		</part>
		<part name="RotateArea" type="string" input="select" 
			required="F" 
			if="$NameArea =~ /box\b|brick0?\b|cylinder|ring/">
			<option name="rotated" />
		</part>
	</parameter>
	<if expr="$NameArea !~ /box|all|initial|currentsheet|user|0/">
		<parameter name="xCenter" type="real" default="0"/>
		<parameter name="yCenter" type="real" default="0"/>
		<parameter name="zCenter" type="real" default="0"/>
	</if>
	<if expr="$NameArea =~ /box/">
		<parameter name="xMinBox" type="real" />
		<parameter name="yMinBox" type="real" />
		<parameter name="zMinBox" type="real" />
		<parameter name="xMaxBox" type="real" />
		<parameter name="yMaxBox" type="real" />
		<parameter name="zMaxBox" type="real" />
	</if>
	<if expr="$NameArea =~ /brick/">
		<parameter name="xSizeBrick" type="real" min="0" />
		<parameter name="ySizeBrick" type="real" min="0" />
		<parameter name="zSizeBrick" type="real" min="0" />
	</if>
	<if expr="$NameArea =~ /sphere/">
		<parameter name="Radius"  type="real" min="0"/>
	</if>
	<if expr="$NameArea =~ /shell/">
		<parameter name="Radius1" type="real" min="0"/>
		<parameter name="Radius2" type="real" min="0"/>
	</if>
	<if expr="$NameArea =~ /cylinder/">
		<parameter name="LengthCylinder" type="real" min="0" />
		<parameter name="Radius"         type="real" min="0" />
	</if>
	<if expr="$NameArea =~ /ring/">
		<parameter name="HeightRing" type="real" min="0" />
		<parameter name="Radius1"    type="real" min="0" />
		<parameter name="Radius2"    type="real" min="0" />
	</if>
	<if expr="$StretchArea =~ /stretched/">
		<parameter name="xStretch" type="real" min="0" default="1"/>
		<parameter name="yStretch" type="real" min="0" default="1"/>
		<parameter name="zStretch" type="real" min="0" default="1"/>
	</if>
	<if expr="$RotateArea =~ /rotated/">
		<parameter name="xRotate" type="real" min="-360" max="360" 
								default="0"/>
		<parameter name="yRotate" type="real" min="-360" max="360" 
								default="0"/>
		<parameter name="zRotate" type="real" min="-360" max="360" 
								default="0"/>
	</if>

#GRIDRESOLUTION
2.0			Resolution
initial			NameArea

#GRIDLEVEL
3			nLevel
all			NameArea

#GRIDLEVEL
4			nLevel
box			NameArea
-64.0			xMinBox
-16.0			yMinBox
-16.0			zMinBox
-32.0			xMaxBox
 16.0			yMaxBox
  0.0			zMaxBox

#GRIDLEVEL
4			nLevel
brick			NameArea
-48.0			xCenter
  0.0			yCenter
 -8.0			zCenter
 32.0			xSizeBrick
 32.0			ySizeBrick
 16.0			zSizeBrick

#GRIDRESOLUTION
1/8			Resolution
shell0			NameArea
3.5			Radius1
4.5			Radius2

#GRIDRESOLUTION
0.5			Resolution
sphere			NameArea
-10.0			xCenterSphere
 10.0			yCenterSphere
  0.0			zCenterSphere
 20.0			rSphere

#GRIDRESOLUTION
1/8			Resolution
cylinderx		NameArea
-30.0			xCenter
  0.0			yCenter
  0.0			zCenter
 60.0			LengthCylinder
 20.0			rCylinder

#GRIDRESOLUTION
1/8			Resolution
ringz0 rotated		NameArea
  5.0			HeightRing
 20.0			Radius1
 25.0			Radius2
 10.0			xRotate
 10.0			yRotate
  0.0			zRotate

#GRIDRESOLUTION
1/4			Resolution
sphere0 stretched	NameArea
10.0			rSphere
1.0			xStretch
3.0			yStretch
2.0			zStretch

#GRIDRESOLUTION
0.15			Resolution
currentsheet		NameArea

#GRIDRESOLUTION
1/8			Resolution
user			NameArea

The #GRIDRESOLUTION and #GRIDLEVEL commands allow to set the grid resolution
or refinement level, respectively, in a given area. The Resolution parameter
refers to the size of the cell in the first direction (Dx or Dr).
The nLevel parameter is an integer with level 0 meaning no refinement relative
to the root block, while level N is a refinement by 2 to the power N.

If NameArea is set to 'initial', it determines the number of grid adaptations
used to initialize the grid. The grid adaptations are done according to the
other GRIDLEVEL and GRIDESOLUTION commands. The default is no refinement initially,
which means that the grid is uniform at the beginning, and it is refined during
the run according to the #AMR or #DOAMR commands.

For other values of NameArea, the command specifies the shape of the area. 
where the blocks are to be refined. If the desired grid resolution is finer
than the initial resolution, then initially the grid will be refined
to the initial resolution only, but the area will be further refined 
in subsequent pre-specified adaptive mesh refinements (AMRs) during the run 
(see the #AMR command). Once the resolution reaches the
desired level, the AMR-s will not do further refinement. If a grid block
is covered by more than one areas, the area with the finest resolution
determines the desired grid resolution.

All computational blocks that intersect the area and have a coarser
resolution than the resolution set for the area are selected for refinement.
There are the following basic shapes: 
'all', 'box', 'box_gen', 'brick', 'brick_gen', 'sphere', 'shell', 'cylinderx', 
'cylindery', 'cylinderz', 'ringx', 'ringy' and 'ringz'.

The area 'all' refers to the whole computational domain, and it can be
used to set the overall minimum resolution. The area 'box' is a box
aligned with the X, Y and Z axes, and it is given with the coordinates
of two diagonally opposite corners. The area 'brick' has the same shape
as 'box', but it is defined with the center of the brick and the 
size of the brick. The 'box_gen' and 'brick_gen' areas can be used 
for non-Cartesian grids to define a box in the generalized coordinates.
For example a sphere around the origin can be described as a box in 
generalized coordinates with radius going from 0 to R, 
phi going from 0 to 360 degrees and latitude going from -90 to +90 degrees.
Note that angles are given in degrees, and radius is given even if the 
generalized coordinates use its logarithm.

The area 'sphere' is a sphere around an arbitrary point,
which is defined with the center point and the radius of the sphere.
The area 'shell' consists of the volume between two concentric spherical
surfaces, which is given with the center point and the two radii.
The area 'cylinderx' is a cylinder with an axis parallel with the X axis,
and it is given with the center, the length of the axis and the radius,
The areas 'cylindery' and 'cylinderz' are cylinders parallel with the 
Y and Z axes, respectively, and are defined analogously as 'cylinderx'.
The area 'ringx', 'ringy' and 'ringz' are the volumes between 
two cylindrical surfaces parallel with the X, Y and Z axes, respectively.
The ring area is given with the center, the height and the two radii.
Note that all these round shapes can be made elliptical with the 
"stretched" option (see below).

If the area name contains the number '0', the center is taken to be at the 
origin and the center coordinates are not read. Note that the areas 'box'
and 'box_gen' are defined with the corners so the '0' cannot be used for these.

If the word 'stretched' is added after the area name, the area can be 
stretched in the X, Y and Z directions. This allows making
an ellipsoid from a sphere, or an elliptical slab from a cylinder.
Also useful to distort shells and rings.

If the word 'rotated' is added after the area name, the area can be 
rotated by 3 angles around the X, Y and Z axes in this order. Only the
areas 'box', 'brick', 'cylinder*' and 'ring*' can be rotated.

The 'currentsheet' area is defined as the blocks containing a reversal of the 
radial magnetic field. This is mostly useful for the solar corona and 
heliosphere. This special area type cannot be stretched, rotated or centered.

The 'user' area results in a call of the subroutine user_specify_refinement 
defined in the user module. The user can define an arbitrary set of criteria 
for refinement.  Again, stretching, rotation and centering cannot be applied 
to the 'user' area.
</command>

<command name="AMRLEVELS">
	<parameter name="MinBlockLevel" type="integer" min="-1" default="0" />
	<parameter name="MaxBlockLevel" type="integer" min="-1" default="99" />

#AMRLEVELS
0			MinBlockLevel
99			MaxBlockLevel

Set the minimum/maximum levels that can be affected by AMR.  The usage is as
follows:
\begin{verbatim}
MinBlockLevel .ge.0 Cells can be coarsened up to the listed level but not
                      further.
MinBlockLevel .lt.0 The current grid is ``frozen'' for coarsening such that
                      blocks are not allowed to be coarsened to a size
                      larger than their current one.
MaxBlockLevel .ge.0 Any cell at a level greater than or equal to
                      MaxBlockLevel is unaffected by AMR (cannot be coarsened
                      or refined).
MaxBlockLevel .lt.0 The current grid is ``frozen'' for refinement such that
                      blocks are not allowed to be refined to a size
                      smaller than their current one.
\end{verbatim}
This command has no effect when DoAutoRefine is .false. in the #AMR command.

Note that the user can set either #AMRLEVELS or #AMRRESOLUTION but not
both.  If both are set, the final one in the session will set the values
for AMR.
</command>

<command name="AMRRESOLUTION">
	<parameter name="DxCellMin" type="real" min="-1" default="0"     />
	<parameter name="DxCellMax" type="real" min="-1" default="99999" />

#AMRRESOLUTION
0.			DxCellMin
99999.			DxCellMax

Serves the same function as AMRLEVELS. The DxCellMin and DxCellMmax
parameters are converted into MinBlockLevel and MaxBlockLevel 
when they are read.
Note that MinBlockLevel corresponds to DxCellMax and MaxBlockLevel
corresponds to DxCellMin.  See details above.

This command has no effect when DoAutoRefine is .false. in the #AMR command.

Note that the user can set either #AMRLEVELS or #AMRRESOLUTION but not
both.  If both are set, the final one in the session will set the values
for AMR.
</command>

<command name="DOAMR">
	 <parameter name="DoAmr" type="logical" default="F"/>
	 <if expr="$DoAmr">
	    <parameter name="DnAmr" type="integer" min="-1" default="-1" />
	    <parameter name="DtAmr" type="real" min="-1.0" default="-1.0" />
	    <parameter name="IsStrictAmr" type="logical" default="T" />
	 </if>
#DOAMR
T                       DoAmr (the rest is only read if true)
1                       DnAmr
-1.0                    DtAmr
T                       IsStrictAmr

DoAmr is telling if you do AMR based on geometrical description or 
AMR criteria decided during the simulation every DnAmr step or DtAmr 
intervals. NOTE: DtAmr is not implemented by 7 Aug 2011.
For both DtAmr and DnAmr negative numbers will be ignored. If IsStrictAmr 
is true, we demand that the number of cells indicated by criteria or 
percentage should be refined or coarsened, otherwise the code stops.
If IsStrictAmr is false, the code will continue with the maximum of 
available blocks. 

For pure geometry based AMR the IsStrictAmr=F will causes the code to 
skip the complete AMR if there are not enough blocsk.

Default is DoAmr false and IsStrictAmr true.
</command>

<command name="AMRLIMIT"> 
	 <parameter name="PercentCoarsen" type="real" min="0" default="0" />
	 <parameter name="PercentRefine" type="real" min="0" default="0" />
	 <parameter name="DiffCriteriaLevel" type="real" min="0" 
	 	    			     		 default="1e-8" />
#AMRLIMIT
40.                     PercentCoarsen
30.                     PercentRefine
999999                  MaxBlockAll
1e-8                    DiffCriteriaLevel

Setting up percentage refinement and coarsening using the criteria given by
AMRCRITERIA or AMRCRITERIALEVEL. MaxBlockAll set max for total number of 
blocks if both _nProc and MaxBlock are set. DiffCriteriaLevel give the deviation
of the criteria that should have the same AMR treatment. 
</command>

<command name="AMR">
	<parameter name="DnRefine" type="integer" min="-1" default="-1" />
	<if expr="$DnRefine>0">
		<parameter name="DoAutoRefine" type="logical" default="F" />
		<if expr="$DoAutoRefine">
			<parameter name="PercentCoarsen" type="real" 
				min="0" max="100" default="20" />
			<parameter name="PercentRefine" type="real" 
				min="0" max="100" default="20" />
			<parameter name="MaxTotalBlocks" type="integer"
				min="1" default="99999" />
		</if>
	</if>
#AMR
2001			DnRefine
T			DoAutoRefine   ! read if DnRefine is positive
0.			PercentCoarsen ! read if DoAutoRefine is true
0.			PercentRefine  ! read if DoAutoRefine is true
99999			MaxTotalBlocks ! read if DoAutoRefine is true

This command is kept for backwards compatibility. The #DOAMR and #AMRLIMIT
commands offer more control.

The DnRefine parameter determines the frequency of adaptive mesh refinements
in terms of total steps nStep.

When DoAutoRefine is false, the grid is refined by one more level
based on the areas and resolutions defined by the 
#GRIDLEVEL and #GRIDRESOLUTION commands.
If the number of blocks is not sufficient for this pre-specified refinement, 
the code stops with an error.

When DoAutoRefine is true, the grid is refined or coarsened 
based on the criteria given in the #AMRCRITERIA command.
The number of blocks to be refined or coarsened are determined by
the PercentRefine and PercentCoarsen parameters. These percentages
are approximate only, because the constraints of the block adaptive
grid may result in more or fewer blocks than prescribed.
The total number of blocks will not exceed the smaller of the 
MaxTotalBlocks parameter and the total number of blocks available on all 
the PE-s (which is determined by the number of PE-s and 
the MaxBlocks parameter in ModSize.f90).

Default for DnRefine is -1, i.e. no run time refinement.
</command>

<command name="AMRCRITERIA">
	<parameter name="nRefineCrit" type="integer" min="0" max="3"
								default="0" />
	<for from="1" to="$nRefineCrit">
		<parameter name="TypeRefine" type="string" case="lower"
			input="select">
			<option name="grad T"		value="gradt"        />
			<option name="grad P"		value="gradp"        />
			<option name="grad log(Rho)"	value="gradlogrho"   />
			<option name="grad log(p)" 	value="gradlogp"     />
			<option name="grad E"		value="grade"	     />
			<option name="curl U" 		value="curlu"        />
			<option name="curl B"		value="curlB/curlb"  />
			<option name="div U"		value="divu"	     />
			<option name="divB"		value="divb"	     />
			<option name="rCurrents" value="rcurrents"	     />
			<option name="Transient" value="transient" />
			<option name="User defined" value="user" />
		</parameter>
		<parameter name="CoarsenLimit" type="real" min="0" max="1"
							   default="0.5"/>
		<parameter name="RefineLimit" type="real" min="0" max="1"
							  default="0.5"/>
		<if expr="$TypeRefine=~/transient/">
			<parameter name="TypeTransient" type="string"
				case="lower" input="select">
				<option name="Rho_dot"   value="rho_dot"
								default="T"/>
				<option name="P_dot"     value="p_dot"/>
				<option name="T_dot"     value="t_dot"/>
				<option name="RhoU_dot"  value="rhou_dot"/>
				<option name="Rho_2nd_1" value="rho_2nd_1"/>
				<option name="Rho_2nd_2" value="rho_2nd_2"/>
			</parameter>
			<parameter name="UseSunEarth" type="logical" 
								default="F"/>
			<if expr="$UseSunEarth">
				<parameter name="xEarth"   type="real"/>
				<parameter name="yEarth"   type="real"/>
				<parameter name="zEarth"   type="real"/>
				<parameter name="InvD2Ray" type="real"/>
			</if>
		</if>
	</for>
#AMRCRITERIA
3			nRefineCrit (1 to3)
gradP			TypeRefine
0.2			CoarsenLimit
0.8			RefineLimit 
user			TypeRefine
0.5			CoarsenLimit
0.5			RefineLimit 
Transient		TypeRefine
Rho_dot			TypeTransient ! Only if 'Transient' or 'transient'
T			UseSunEarth   ! Only if 'Transient'
0.00E+00		xEarth        ! Only if UseSunEarth
2.56E+02 		yEarth        ! Only if UseSunEarth
0.00E+00		zEarth        ! Only if UseSunEarth
5.00E-01		InvD2Ray      ! Only if UseSunEarth

Note: "#AMRCRITERIALEVEL" gives even more control.

This command defines the criteria to select blocks for refinement or
coarsening when the #AMR command is used with DoAutoRefine=T parameter. 
Up to 3 criteria can be used. Refinement is done if ANY
of the criteria demand it, and the block can be refined
(a block cannot be refined if the refinement level would exceed
the maximum level or too many blocks would be created.

Coarsening is done if ALL the criteria allow it and the block
can be coarsened (a block cannot be coarsened if the block level
is already at the minimum level, or too many blocks would be coarsened). 

The CoarsenLimit and RefineLimit parameters set the coarsening and 
refinement thresholds for the NORMALIZED (divided by the largest value) 
criteria. When the BATL library is not used the criteria are sorted by
their value and a certain per cent of the blocks with the largest/lowest
criteria get refined/coarsened, as determined by the 
PercentCoarsen and PercentRefine parameters of the #AMR command.

The default settings currently depend on the component used,
but it is best to set the criteria explicitly if the #AMR command
is used with DoAutoRefine=T, because the defaults may change, and 
they are not optimal for most applications.

If nRefineCrit is set to zero, the blocks are not ordered. 
This can be used to refine or coarsen
all the blocks limited by the minimum and maximum levels only
(see commands #AMRLEVELS and #AMRRESOLUTION). If nRefineCrit is 1, 2, or 3
then the criteria can be chosen from the following list:
\begin{verbatim}
  'gradT'		- gradient of temperature
  'gradP'		- gradient of pressure
  'gradlogrho'		- gradient of log(rho)
  'gradlogP'		- gradient of log(P)
  'gradE'		- gradient of electric field magnitude
  'curlV','curlU' 	- magnitude of curl of velocity
  'curlB'		- magnitude of current
  'divU', 'divV'	- divergence of velocity
  'divB'		- div B
  'Rcurrents'		- refinement near Rcurrents value
  'user'                - criteria defined in the user module
\end{verbatim}
All the names can also be spelled with all small case letters.\\

\noindent
The possible choices for TypeTransient:
\begin{verbatim}
  'P_dot'
  'T_dot'
  'Rho_dot'
  'RhoU_dot'
  'B_dot'
  'Rho_2nd_1'
  'Rho_2nd_2'
\end{verbatim}
Also, (xEarth,yEarth,zEarth) are the coordinates of the Earth. InvD2Ray is
a factor that defines how close to the ray Sun-Earth to refine the grid.
Note that the AMR occurs in a cylinder around the ray.
Example for InvD2Ray =
\begin{verbatim}
   1 - refine_profile = 0.3679 at distance Rsun/10 from the ray
   2 - refine_profile = 0.0183 at distance Rsun/10 from the ray
   3 - refine_profile = 0.0001 at distance Rsun/10 from the ray
\end{verbatim}
</command>

<command name="AMRCRITERIALEVEL" alias="AMRCRITERIARESOLUTION">
	<parameter name="nRefineCrit" type="integer" min="0" default="0" />
	<for from="1" to="$nRefineCrit">
	     <parameter name="StringRefine" type="strings" min="1" max="2">
		<part name="TypeRefine" type="string" case="lower"
		      input="select">
			<option name="grad T"		value="gradt"        />
			<option name="grad P"		value="gradp"        />
			<option name="grad log(Rho)"	value="gradlogrho"   />
			<option name="grad log(p)" 	value="gradlogp"     />
			<option name="grad E"		value="grade"	     />
			<option name="curl U" 		value="curlu"        />
			<option name="curl B"		value="curlb"  	     />
			<option name="J2"		value="j2"  	     />
			<option name="div U"		value="divu"	     />
			<option name="divB"		value="divb"	     />
			<option name="rCurrents"	value="rcurrents"    />
			<option name="error"            value="error"        />
			<option name="transient"        value="transient"    />
			<option name="User defined"     value="user" 	     />
		</part>
		<part name="TypeTransient" type="string" input="select"
		      	   required="$TypeRefine =~ /transient/" >
			<option name='Rho_dot' 	default="T"/>
			<option name='RhoU_dot'		   />
			<option name='P_dot'	    	   />
			<option name='T_dot'		   />
			<option name='Rho_2nd_1'	   />
			<option name='Rho_2nd_2'	   />
		</part>
		<part name="NameStateVar" type="string" length="10"
		      	   required="$TypeRefine =~ /error/" />
	    </parameter>
	    <parameter name="CoarsenLimit"      type="real"    min="0" /> 
	    <parameter name="RefineLimit"       type="real"    min="0" />
	    <parameter name="MaxRefinmentLevel" type="integer" min="0"/>
	</for>
	<parameter name="SmallError" type="real" default="1.0e-8"
		   if="$NameStateVar =~ /./" />
	<parameter name="UseSunEarth" type="logical" default="F"
		   if="$TypeTransient =~ /./" />
	<if expr="$UseSunEarth">
		<parameter name="xEarth"   type="real"/>
		<parameter name="yEarth"   type="real"/>
		<parameter name="zEarth"   type="real"/>
		<parameter name="InvD2Ray" type="real"/>
	</if>

#AMRCRITERIALEVEL
4                       nCriteria 
J2 +tail -nearbody      TypeCriteria
0.1                     CoarsenLimit
0.75                    RefineLimit
1                       MaxLevel
J2 +teail -nearbody     TypeCriteria
1.0			CoarsenLimit
2.0			RefineLimit
2			MaxLevel
Level                   TypeCriteria
2                       RefineTo
3                       CoursenFrom
dx  +nearbody                   TypeCriteria
0.5                       RefineTo
0.25                       CoursenFrom
error Bx -nearbody	TypeCriteria
0.025			CoarsenLimit
0.1			RefineLimit
2			MaxLevel
transient P_dot		TypeCriteria
1.0	  		CoarsenLimit
2.0			RefineLimit
1			MaxLevel
1.0e-2                  SmallError    ! Only if there are any 'error' crit
T                       UseSunEarth   ! Only if there are any 'transient' crit
0.00E+00                xEarth        ! Only if UseSunEarth is true
2.56E+02                yEarth        ! Only if UseSunEarth is true
0.00E+00                zEarth        ! Only if UseSunEarth is true
5.00E-01                InvD2Ray      ! Only if UseSunEarth is true

The #AMRCRITERIALEVEL or #AMRCRITERIARESOLUTION command defines the 
criteria to select blocks for refinement or coarsening when the #DOAMR 
command is used with DoAmr=T parameter. In one seesion youu can only have one
#AMRCRITERIALEVE or #AMRCRITERIARESOLUTION. #AMRCRITERIARESOLUTION is equvilent
to #AMRCRITERIALEVE but works on cell resolution (dx) instead of levels.

The number of criteria is given by the nCriteria parameter.
Up to 3 different types of criteria (given by TypeCriteria) can be used. 
But there can be multiple criteria for the same TypeCriteria. 

The various criteria types define a positive real number for every grid block.
This number is compared with the CoarsenLimit and RefineLimit values.
The MaxLevel parameter defines the maximum grid level to which a given
criterion can refine to.

Refinement is done if ANY of the criteria demand it, and the block 
can be refined. A block cannot be refined if the refinement level would exceed
the maximum grid level or too many blocks would be created.

Coarsening is done if ALL the criteria allow it and the block
can be coarsened. A block cannot be coarsened if the block level
is already at the minimum level or it has a neighbor block that is
and remains finer. 

TypeCriteria can be chosen from the following list:
\begin{verbatim}
  'gradT'		- gradient of temperature
  'gradP'		- gradient of pressure
  'gradlogrho'		- gradient of log(rho)
  'gradlogP'		- gradient of log(P)
  'gradE'		- gradient of electric field magnitude
  'curlV','curlU' 	- magnitude of curl of velocity
  'curlB'		- magnitude of current
  'J2'                  - square of current
  'divU', 'divV'	- divergence of velocity
  'divB'		- div B
  'Rcurrents'		- refinement near Rcurrents value
  'user'                - criteria defined in the user module
  'dx'                  - refinment based on max dx in a block
  'Level'               - refinment based on the level of a block
\end{verbatim}
For TypeRefine "transient TypeTransient" there are the following posibileties 
for TypeTransient:
\begin{verbatim}
  'P_dot'		- time derivative of pressure
  'T_dot'		- time derivative of temperature
  'Rho_dot'		- time derivative of density
  'RhoU_dot'		- time derivative of momentum
  'B_dot'		- time derivative of magnetic field
  'Rho_2nd_1'
  'Rho_2nd_2'
  'meanUB'
\end{verbatim}

After the Typcriteria we can define which area we want the criteria to act on,
minus(-) exclude the area to be evaluated and positiv(+) tell that a criteria
will only evaluated in that area. If you start with a negativ area, its asumed that
you want the criteria to act upon all areas but the negative one.The areas can 
be list of multiple areas. The ares is defined by the #AMRREGION comand. 
If no area is spesified all of the simulation domain is asumed (all).

The UseSunEarth logical is only read if there are any "transient" type
criteria. If UseSunEarth is set to true then the xEarth, yEarth, zEarth
parameters are read, and these define the coordinates of the Earth 
in the heliocentric coordinate system. The InvD2Ray parameter is
a factor that defines how close to the Sun-Earth line the grid is refined.
Note that the AMR occurs in a cylinder around the ray.

For TypeRefine "error StateVarName" the criteria is a numerical error 
estimate for the state varable StateVarName. 
The error estimation is based on the second and first derivatives:
\begin{verbatim}
                          d^2 U
                         -------
                          dx^2 
    E  =  ----------------------------------------
           1     dU      SmallError
          ---  ------  + ---------- *U  + Epsilon 
          DX     dx         DX^2
\end{verbatim}
The SmallError parameter gives a relative error with respect to the mean value 
of the state variable. 

The default setting is nCriteria = 0.
This can be used to refine or coarsen
all the blocks limited by the minimum and maximum levels only
(see commands #AMRLEVELS and #AMRRESOLUTION).

</command>

</commandgroup>
<commandgroup name="SCHEME PARAMETERS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!  SCHEME PARAMETERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="SCHEME">
	<parameter name="nOrder" type="integer" input="select">
	    <option name="1st order"  value="1"/>
	    <option name="TVD2"       value="2" default="T"/>
	    <option name="FIVOL4"     value="4"/>
	    <option name="MP5"        value="5"/>
	</parameter>
	<parameter name="TypeFlux" type="string" input="select" case="upper">
	    <option name="Rusanov" value="RUSANOV" default="T"/>
	    <option name="Linde"   value="LINDE"  />
	    <option name="Sokolov" value="SOKOLOV"/>
	    <option name="HLLD"                   />
	    <option name="Roe"     value="ROE"    />
	    <option name="RoeOld"  value="ROEOLD" />
	    <option name="Godunov" value="GODUNOV"/>
	    <option name="Simple"  value="SIMPLE" />
	</parameter>
	<if expr="$nOrder != 1 and $TypeFlux ne 'SIMPLE'">
	    <parameter name="TypeLimiter" type="string" input="select">
		<option name="minmod"  		 	/>
		<option name="mc"	default="T"	/>
		<option name="mc3"			/>
		<option name="beta"			/>
	    </parameter>
	    <parameter name="LimiterBeta" type="real" min="1" max="2"
			default="1.2" if="$TypeLimiter ne 'minmod'"/>
	</if>
#SCHEME
4			nOrder (1, 2, 4 or 5)
Rusanov			TypeFlux
mc3			TypeLimiter ! Only read for Order>1 and flux not Simple
1.2			LimiterBeta ! Only read if TypeLimiter is NOT 'minmod'

The nOrder parameter determines the spatial and temporal accuracy of
the scheme. 
The spatially first order scheme uses a one-stage time integration,
while the spatially second order MUSCL scheme either uses 
an explicit two-stage Runge-Kutta or an implicit three-level BDF2
time discretization. 
The 4th order finite volume scheme (FIVOL4) 
uses the classical 4th order Runge-Kutta scheme for time integration.
The spatially 5th order MP5 scheme uses the 3rd order Runge-Kutta scheme.
Note that the time discretization scheme can be modified 
with the #TIMESTEPPING, #RUNGEKUTTA or #RK commands after the #SCHEME command.
\noindent
Possible values for TypeFlux:
\begin{verbatim}
 'Rusanov'     - Rusanov or Lax-Friedrichs flux
 'Linde'       - Linde's HLLEL flux
 'Sokolov'     - Sokolov's Local Artificial Wind flux
 'Roe'         - Roe's approximate Riemann flux (new)
 'RoeOld'      - Roe's approximate Riemann flux (old)
 'HLLD'        - Miyoshi and Kusano's HLLD flux
 'Godunov'     - Godunov flux with exact Riemann solver
 'Simple'      - Physical fluxes are applied without any Riemann solver.
\end{verbatim}
The Godunov flux is only implemented for (multi-material) hydrodynamics.
The Roe and HLLD schemes are implemented for ideal MHD only 
(single fluid, non-relativistic, no Hall term).
The new and old Roe schemes differ in some details of the algorithm,
the new Roe scheme is somewhat more robust in magnetospheric applications.
The Simple solver is for testing purposes only at this point.

No limiter is used by the 1st order scheme. The second order TVD scheme
uses a TVD limiter everywhere. The FIVOL4 and MP5 schemes use
the second order TVD scheme at resolution changes, but in
the uniform part of the grid they use their own limiter.
Possible values for TypeLimiter:
\begin{verbatim}
 'minmod'      - minmod limiter is the most robust and diffusive limiter
 'mc'          - monotonized central limiter with a beta parameter
 'mc3'         - Koren's third order limiter with a beta parameter
 'beta'        - beta limiter is less robust than the mc limiter for 
                 the same beta value
\end{verbatim}
Possible values for LimiterBeta (for limiters othen than minmod)
are between 1.0 and 2.0: 
\begin{verbatim}
  LimiterBeta = 1.0 is the same as the minmod limiter
  LimiterBeta = 1.5 is a typical value for the mc/mc3 limiters
  LimiterBeta = 1.2 is the recommended value for the beta limiter
  LimiterBeta = 2.0 for the beta limiter is the same as the superbee limiter
\end{verbatim}

IMPORTANT: the number of ghost cell layers have to be sufficient for the
selected scheme! The 1st and 2nd order schemes work with 2 layers.
The MP5 scheme needs 3 layers. The FIVOL4 scheme needs 3 to 5 layers
(see the #SCHEME4 command).

The default is the second order Rusanov scheme with the minmod limiter.
</command>

<command name="SCHEME4" if="$_IsFirstSession">
	<parameter name="UseVolumeIntegral4" type="logical" default="F"/>
	<parameter name="UseFaceIntegral4"   type="logical" default="F"/>
        <parameter name="UseLimiter4"        type="logical" default="F"/>
#SCHEME4
F			UseVolumeIntegral4
F			UseFaceIntegral4
F			UseLimiter4

This command has to be used in the first session, because it determines
the size of various arrays that are allocated at the beginning of the run.
The command reads three parameters used by the 4th order finite volume 
scheme FIVOL4, which can be activated in any session by setting
nOrder=4 in the #SCHEME command.

If UseVolumeIntegral4 is true then the cell averaged variables 
are converted into cell centered variables and back as needed. 
This requires an extra ghost cell layer.
Currently this option only works for Cartesian grids and
with cell based boundary conditions (no inner body).

If UseFaceIntegral4 is true, then the face averaged face values 
and face fluxes are converted to face centered variables
and back as needed. This option can only be used on 2D and 3D
Cartesian grids and with cell based boundary conditions (no inner body).

If UseLimiter4 is true then the truely 4th order limiter is used,
however this requires an extra ghost cell layer, and the improvement
is marginal at best.

If all 3 logicals are true and nOrder is set to 4 in the #SCHEME
command then the fully 4th order accurate FIVOL4 scheme is used.
This, however, requires extra ghost cell layers and extra face flux
calculations. In practice the fully 4th order FIVOL4 scheme is much 
more expensive but not much more accurate than the simplified shceme 
with all three logicals set to false.

IMPORTANT: the number of ghost cell layers set with Config.pl -ng=..
has to be sufficient for the selected scheme! 
The FIVOL4 scheme needs 3 to 5 layers.
The minimum 3 layers are needed if both UseVolumeIntegral4 and UseLimiter4
are false. If one of these logicals is true, 4 layers are required.
If both are true then the maximum 5 ghost cells layers are needed.

The default is false for all 3 logicals.
</command>


<command name="FLATTENING">
	 <parameter name="UseFlattening" type="logical" default="T"/>
	 <if expr="$UseFlattening">
	 	<parameter name="UseDuFlat" type="logical" default="F"/>
	 	<parameter name="FlatDelta" type="real"
			   min="0" max="1" default="0.33"/>
		<parameter name="FlatRatioMin" type="real"
			   min="0" max="1" default="0.75"/>
		<parameter name="FlatRatioMax" type="real" 
			   min="$FlatRatioMin" max="1" default="0.85"/>
	</if>

#FLATTENING
T		UseFlattening (rest of parameters are read if true)
F		UseDuFlat
0.33		FlatDelta
0.75		FlatRatioMin
0.85		FlatRatioMax

This command controls the parameters of Phil Collela's flattening 
algorithm used by the 4th order scheme (nOrder=4 in the #SCHEME command). 
The flattening scheme uses a linear combination of the first order and the 4th
order accurate face values. Near strong shocks it switches to the first
order scheme, elsewhere it uses the 4th order accurate face value.

If the UseFlattening parameter is true, the flattening scheme is switched on.

The UseDuFlat parameter determines if the velocity gradient is used as
a condition for flattening. The "official" algorithm uses this check,
in some cases it seems to be better not to use it, and it is not clear
if there is any advantage using it.

The FlatDelta parameter determines the threshold for the relative 
pressure jump. If pR and pL are the pressures in the i+1 and i-1 cells,
then the flattening is applied only if abs(pR - pL) is greater than 
FlatDelta*min(pR, pL).

The FlatRatioMin parameter determines the lower threshold for the shock width
ratio = abs(p(i+2) - p(i-2))/abs(pR - pL). If the ratio is less than 
FlatRatioMin, no flattening is applied. 

The FlatRatioMax parameter determines the upper threshold for the shock width
ratio. If the ratio is above FlatRatioMax, the first order scheme is used.
If the ratio is between the FlatRatioMin and FlatRatioMax values, the
1st order and 4th order face values are linearly combined with a 
weight (Ratio - FlatRatioMin)/(FlatRatioMax - FlatRatioMin).

In the actual scheme, the flattening parameters are calculated for all 
dimensions and all cells first, and then the minimum is taken over 
a 3 point stencil in each dimension, and then a minimum is taken over 
the dimensions. See Miller and Colella 2005, APJS, 160, 199.

The default values are shown in the example.
</command>

<command name="NONCONSERVATIVE">
	<parameter name="UseNonConservative" type="logical" default="T"/>
#NONCONSERVATIVE
T		UseNonConservative

For Earth the default is using non-conservative equations 
(close to the body).
</command>

<command name="CONSERVATIVECRITERIA">
	<parameter name="nConservCrit" type="integer" min="0" max="3"
                                                             default="1"/>
	<for from="1" to="$nConservCrit">
		<parameter name="TypeConservCrit" type="string" case="lower" 
		input="select">
			<option name="radius"	value="r/radius" default="T"/>
			<option name="parabola"	value="parabola/paraboloid" />
			<option name="p"				    />
			<option name="grad P"	value="gradp"		    />
		</parameter>
		<parameter name="rConserv" type="real" min="$rBody"
			default="6"  if="$TypeConservCrit =~ /^r|radius$/i"/>
		<parameter name="xParabolaConserv" type="real" min="0"
			default="6"  if="$TypeConservCrit =~ /^parabol/i"/>
		<parameter name="yParabolaConserv" type="real" min="0"
			default="36" if="$TypeConservCrit =~ /^parabol/i"/>
		<parameter name="pCoeffConserv" type="real" min="0"
			default = "0.05" if="$TypeConservCrit =~ /^p$/i"/>
		<parameter name="GradPCoeffConserv" type="real" min="0"
			default = "0.1" if="$TypeConservCrit =~ /gradp/i"/>
	</for>

#CONSERVATIVECRITERIA
3		nConservCrit
r		TypeConservCrit
6.		rConserv             ! read if TypeConservCrit is 'r'
parabola        TypeConservCrit
6.		xParabolaConserv     ! read if TypeConservCrit is 'parabola'
36.		yParabolaConserv     ! read if TypeConservCrit is 'parabola'
p		TypeConservCrit
0.05		pCoeffConserv	     ! read if TypeConservCrit is 'p'
GradP		TypeConservCrit
0.1		GradPCoeffConserv    ! read if TypeConservCrit is 'GradP'

Select the parts of the grid where the conservative vs. non-conservative
schemes are applied. The number of criteria is arbitrary, although 
there is no point applying the same criterion more than once.

If no criteria is used, the whole domain will use conservative or
non-conservative equations depending on UseNonConservative set in
command #NONCONSERVATIVE.

The physics based conservative criteria ('p' and 'GradP')
select cells which use the non-conservative scheme if ALL of them are true:
\begin{verbatim}
 'p'      - the pressure is smaller than fraction pCoeffConserv of the energy
 'GradP'  - the relative gradient of pressure is less than GradPCoeffConserv
\end{verbatim}
 The geometry based criteria are applied after the physics based criteria 
 (if any) and they select the non-conservative scheme if ANY of them is true:
\begin{verbatim}
 'r'        - radial distance of the cell is less than rConserv
 'parabola' - x less than xParabolaConserv - (y**2+z**2)/yParabolaConserv
\end{verbatim}
For the GM component with a planet the default values are nConservCrit = 1 
with TypeConservCrit = 'r' and rConserv=6. If there is no planet
(PLANET="NONE") or for the EE, SC, IH and OH components, the default is to
have no conservative criteria: nConservCrit = 0.
</command>

<command name="UPDATECHECK">
	<parameter name="UseUpdateCheck" type="logical" default="T" />
	<if expr="$UseUpdateCheck">
		<parameter name="RhoMinPercent" type="real" min="0" max="100"
			default="40" />
		<parameter name="RhoMaxPercent" type="real" min="0"
			default="400" />
		<parameter name="pMinPercent" type="real" min="0" max="100"
			default="40" />
		<parameter name="pMaxPercent" type="real" min="0"
			default="400" />
	</if>
#UPDATECHECK
T			UseUpdateCheck
40.			RhoMinPercent
400.			RhoMaxPercent
40.			pMinPercent
400.			pMaxPercent

Note that the "update-check" algorithm controlled by this command 
does not work together with high order Runge-Kutta schemes (see the #RK
command) because the RK method combines the intermediate stages for the
final update. Use the time step control method (see #TIMESTEPCONTROL
and related commands) in combination with RK time stepping.
In general, for time accurate simulations the time step control method 
has more flexibility and it is likely to be more effective and efficient 
than this update-check method.

If UseUpdateCheck is true, the local or global time step will be adjusted
so that the density and pressure does not decrease or increase by more than 
the given percentages in a single timestep. For example with the default 
settings, 
if density is 1.0 initially and it would change below 0.6 or above 5.0, 
the (local) time step will be reduced so that the final density remains
inside the prescribed bounds.

Default values are shown for the non-Runge-Kutta time integration schemes.
For Runge-Kutta schemes UseUpdateCheck is forced to be false.
</command>

<command name="CONTROLTIMESTEP" alias="TIMESTEPCONTROL">
	<parameter name="UseTimeStepControl" type="logical" default="F"/>
#CONTROLTIMESTEP
T			UseTimeStepControl

#TIMESTEPCONTROL
T			UseTimeStepControl

Setting UseTimeStepControl=T switches on the new time step control scheme
that controls the time step based on the relative change in selected set
of variables. The variables can be selected with the #CONTROLVAR command.
The various thresholds in the relative increase and decrease of these 
variables can be set by the #CONTROLINCREASE and #CONTROLDECREASE commands.
The #CONTROLFACTOR command determines how much the time step changes
when the various thresholds are reached.

Currently this scheme only works in time accurate mode.

The default is UseTimeStepControl false.
</command>

<command name="CONTROLINIT">
	<parameter name="TimeStepControlInit" type="real" min="0" max="1"
		   default="1"/>
#CONTROLINIT
0.01			TimeStepControlInit

Set the initial reduction factor applied to the time step or Cfl number.
The factor should be positive and it should typically not more than 1.

The default value is 1, i.e. there is no initial reduction applied.
</command>

<command name="CONTROLVAR">
	<parameter name="NameVarControl"  type="string" length="100" 
			case="lower" default="rho p"/>
#CONTROLVAR
rho p			NameVarControl

The NameVarControl string contains the list of variables that are monitored
to control the time step. The variable names, separated by spaces, 
should be chosen from the NameVar_V(1:nVar) array in the equation module. 
The names are not case sensitive. Typically only the positive variables,
like density and pressure, should be monitored. 

Note that this command is only effective if the time step control is switched 
on by th #CONTROLTIMESTEP command.

The default is the control density and pressure as shown by the example.
</command>

<command name="CONTROLDECREASE">
	<parameter name="RejectStepLevel" type="real" min="0" max="1"
								default="0.3"/>
	<parameter name="ReduceStepLevel" type="real" min="0" max="1"
								default="0.6"/>
	<parameter name="IncreaseStepLevel" type="real" min="0" max="1"
								default="0.8"/>
#CONTROLDECREASE
0.3			RejectStepLevel
0.6			ReduceStepLevel
0.8			IncreaseStepLevel

This command sets thresholds for the relative decrease in the control
variables in the time step control scheme. The relative decrease is 
defined as D = min(VarNew/VarOld) where the minimum is taken over all cells 
in the computational domain and all the control variables. 

If D is below the RejectStepLevel threshold, the time step is rejected, 
and it will be redone with a smaller time step/CFL number.

If D is above RejectStepLevel but below the ReduceStepLevel then the 
time step is accepted, but the next time step/CFL number will be reduced.

If D is above RejectStepLevel but below IncreaseStepLevel, the time
step is accepted and there is no change in the time step/CFL number.

If is above the IncreaseStepLevel threshold, then the time step/CFL number
is increased, but it will never exceed the original value.

This command is only effective if the time step control is switched on with
the #CONTROLTIMESTEP command. The control variables are selected by the
#CONTROLVAR command, the factors that change the time step or the CFL number
are set by the #CONTROLFACTOR command.

Default values are shown.
</command>

<command name="CONTROLINCREASE">
	<parameter name="RejectStepLevel"   type="real" min="1" default="3.0"/>
	<parameter name="ReduceStepLevel"   type="real" min="1" default="1.5"/>
	<parameter name="IncreaseStepLevel" type="real" min="1" default="1.2"/>
#CONTROLINCREASE
3.0			RejectStepLevel
1.5			ReduceStepLevel
1.2			IncreaseStepLevel

This command sets thresholds for the relative increase in the control
variables in the time step control scheme. The relative increase is 
defined as I = max(VarNew/VarOld) where the maximum is taken over all cells 
in the computational domain and all the control variables. 

If I is above the RejectStepLevel threshold, the time step is rejected, 
and it will be redone with a smaller time step/CFL number.

If I is below RejectStepLevel but above the ReduceStepLevel then the 
time step is accepted, but the next time step/CFL number will be reduced.

If I is below ReduceStepLevel but above IncreaseStepLevel, the time
step is accepted and there is no change in the time step/CFL number.

If I is below the IncreaseStepLevel threshold, then the time step/CFL number
is increased, but it will never exceed the original value.

This command is only effective if the time step control is switched on with
the #CONTROLTIMESTEP command. The control variables are selected by the
#CONTROLVAR command, and the factors that change the time step or the 
CFL number are set by the #CONTROLFACTOR command.

Default values are shown.
</command>

<command name="CONTROLFACTOR">
	<parameter name="RejectStepFactor" type="real" min="0" max="1"
							default="0.5"/>
	<parameter name="ReduceStepFactor" type="real" min="0" max="1"
							default="0.95"/>
	<parameter name="IncreaseStepFactor" type="real" min="1"
							default="1.05"/>
#CONTROLFACTOR
0.5			RejectStepFactor
0.95			ReduceStepFactor
1.05			IncreaseStepFactor

This command sets how much the time step/CFL number is changed by the
time step control scheme. 

If the update is rejected then the next time step/CFL factor is 
multiplied by RejectStepFactor. 

If the update is accepted but the time step needs to be reduced, 
then the next time step/CFL factor is multiplied by ReduceStepFactor. 

If the update is accepted and the relative changes in the control variables 
are within the range determined by the IncreaseStepLevel parameters of the 
#CONTROLDECREASE and #CONTROLINCREASE commands, then the time step/CFL number
is multiplied by IncreaseStepFactor, but the original values cannot be 
exceeded.

This command is only effective if the time step control is switched on with
the #CONTROLTIMESTEP command. The control variables are selected by the
#CONTROLVAR command.

Default values are shown.
</command>

<command name="MULTISPECIES">
	<parameter name="DoReplaceDensity" type="logical" default="T"/>
	<parameter name="SpeciesPercentCheck" type="real" min="0" max="100"
							default="1.0" />
#MULTISPECIES
T			DoReplaceDensity
1.0			SpeciesPercentCheck

This command is only useful for multispecies equations.
If the DoReplaceDensity is true, the total density is replaced with
the sum of the species densities. The SpeciesPercentCheck parameter
determines if a certain species density should or should not be
checked for large changes. If SpeciesPercentCheck is 0, all species
are checked, if it is 1, then only species with densities reaching
or exceeding 1 per cent are checked for large changes (see the
#UPDATECHECK command).

Default values are shown.
</command>

<command name="NEUTRALFLUID">
	<parameter name="DoConserveNeutrals" type="logical" default="T"/>
	<parameter name="TypeFluxNeutral" type="string" input="select">
		<option name="default"  default="T"/>
		<option name="Rusanov"/>
		<option name="Linde"  />
	</parameter>
#NEUTRALFLUID
F		DoConserveNeutrals
Linde		TypeFluxNeutral (default, Rusanov or Linde)

If DoConserveNeutrals is false, the pressure equation is used 
for neutrals even where the energy equation is used for the ions.
If DoConserveNeutrals is true, the neutrals do the same as ions.
The neutral fluid uses the flux function set by TypeFluxNeutral.
The default is to use the same as the ion fluid if possible. 
Currently only the Rusanov and Linde schemes are available for
the neutrals. If the ion fluid uses any other flux function,
the neutrals will use the Linde scheme. 

Default values are DoConserveNeutrals=T and TypeFluxNeutral=default.
</command>

<command name="MULTIION">
	<parameter name="LowDensityRatio" type="real" min="0" max="1"
		default="0.0001" />
	<parameter name="LowPressureRatio" type="real" min="0" max="1"
		default="1e-10" />
	<parameter name="DoRestrictMultiIon" type="logical" default="F" />
	<if expr="$DoRestrictMultiIon">
		<parameter name="MachNumberMultiIon" type="real" min="1"
			default="9" />
		<parameter name="ParabolaWidthMultiIon" type="real" min="0"
			default="30" />
	</if>
#MULTIION
0.0001			LowDensityRatio
1e-10			LowPressureRatio
T			DoRestrictMultiIon
3.0			MachNumberMultiIon (read if DoRestrictMultiIon)
30.0			ParabolaWidthMultiIon (read if DoRestrictMultiIon)

This command is useful for multiion simulations. Since the numerical schemes
cannot handle zero densities or temperatures, it is necessary to have all the
ions present in the whole computational domain. The parameters of this
command determine how the code behaves in regions where one of the ions
is dominant.

The LowDensityRatio parameter determines the relative density of the minor 
ion fluids in regions where essentially only one ion fluid is present. 

The LowPressureRatio parameter is used to keep the pressures of the minor
fluids above a fraction of the total pressure.

If DoRestrictMultiIon is true, the first ion fluid is set to be dominant
in the region determined by the MachNumberMultiIon and ParabolaWidthMultiIon
parameters. The current parametrization tries to find the region occupied
by the solar wind outside the bow shock. The region is identified as
the velocity being negative and the hydrodynamic Mach number in the X 
direction is being larger than MachNumberMultiIon and the point being
outside the paraboloid determined by the 
$y^2 + z^2 + x*ParabolaWidthMultiIon = 0$ equation.

The defaults are LowDensityRatio=0.0001, LowPressureRatio=1e-10, and
DoRestrictMultiIon=false.
</command>

<command name="MHDIONS">
	<parameter name="DoAddRho"  type="logical" default="F"/>
	<parameter name="DoAddRhoU" type="logical" default="T"/>
#MHDIONS
F			DoAddRho
T			DoAddRhoU

This command determines how the total MHD fluid and the individual ion fluids
are reconciled after each time step. If both DoAddRho and DoAddRhoU are true,
then the density and momentum of individual ion fluids are added up
and the MHD solution is overwritten. This is mostly useful for testing 
purposes, because in this case it is better not to solve for the total fluid
at all. 

If DoAddRho is false then the density obtained by  the MHD scheme is used
to adjust the densities of the ion fluids.
They are scaled such that their sum matches the total fluid.

If DoAddRhoU is false, the same scaling is done for the three components 
of the ion momenta as long as all ion velocities have the same signs! 
If the signs are mixed, the total momentum is replaced by the sum of the 
ion momenta. The procedure is done separately for the X, Y and Z components 
of the momenta.

Default values are shown.
</command>

<command name="MULTIIONSTATE">
	<parameter name="UseSingleIonVelocity"    type="logical" default="F"/>
	<parameter name="UseSingleIonTemperature" type="logical" default="F"/>
#MULTIIONSTATE
T			UseSingleIonVelocity
F			UseSingleIonTemperature

This command allows to enforce uniform ion velocities and/or temperatures
in multi-ion simulations. When both logicals are true, the multi-ion 
simulation should become equivalient with a singlefluid multi-species 
simulation. This is useful for testing.

When UseSingleIonVelocity is true, the ion velocities are set to the
velocity of the total fluid $u=\sum_s(\rho_s u_s)/\sum_s\rho_s$ 
as if there was an infinitely strong friction force between the ion fluids.

When UseSingleIonTemperature is true, the ion temperatures are set to the
temperature of the total fluid $k_B T = \sum_s p_s/\sum_s(\rho_s/M_s)$ 
as if there was an infinitely fast energy exchange between the ion fluids.

Default values are false for both parameters.
</command>

<command name="COLLISION">
	<parameter name="CollisionCoefDim" type="real" min="-1" />
	<parameter name="TauCutOffDim" type="real" min="-1" default="1000"/>
	<if expr="$TauCutOffDim&gt;0">
		<parameter name="uCutOffDim" type="real" min="-1" 
			default="100"/>
		<parameter name="nPowerCutOff" type="integer" min="1" max="3"
			default="2" />
	</if>
#COLLISION
-1.0                            CollisionCoefDim
1.0e3                           TauCutOffDim [s]
100.0                           uCutOffDim [km/s] read if TauCutOffDim positive
2                               nPowerCutOff read if TauCutOffDim positive

This command is only useful for multiion simulations. It determines the
parameters for physical collisions and artificial friction. 

If the CollisionCoefDim parameter is negative the ion-ion collisions are
neglected. This is typically a very good approximation in the low density
plasma of space physics. The collisions may be important in the ionosphere
of unmagnetized planets. For positive value the collision rate is taken
to be CollisionCoefDim$*n/T^{1.5}$ where $T$ is the temperature measured in 
Kelvin, $n$ is the number density measured in $/cm^{-3}$ and the 
resulting rate is in units of $1/s$.
Note that this feature is implemented but it has not been tested yet.

If the TauCutOffDim parameter is negative the relative velocity of the
ion fluids (especially parallel to the magnetic field) can become very
large. In reality the streaming instability limits the relative speed. 
Instead of trying to model the effect of the streaming instability,
in the current implementation we apply a simple friction term.
If TauCutOffDim is positive, it gives the time rate of the friction.

The uCutOffDim determines the speed difference (in input units, 
typically km/s), at which the friction term becomes large. 
Setting uCutoffDim = -1.0 switches to a physics based cut-off
velocity which is defined as B/sqrt[rho1*rho2/(rho1+rho2)]
where B is the magnetic field magnitude, and rho1 and rho2 are 
the densities of the two ion fluids in normalized units.

The nPowerCutOff is the exponent applied
to the square of the velocity difference. The friction force is
applied between all pairs of ion fluids, and it is

$(1/TauCutOffDim)\min(\rho_i, \rho_j)(u_j-u_i)
     [(u_i-u_j)^2/uCutOffDim^2]^{nPowerCutOff}$.

where i and j are the indexes of two different ion fluids and u is
the velocity vector.
Note that the friction force is proportional to the smaller of the 
two densities so that the acceleration of the minor ion fluid is independent
of the density of the major ion fluid.

The default values are CollisionCoefDim=-1 and TauCutOffDim=-1, ie. 
neither collision, nor friction are applied.
</command>

<command name="MESSAGEPASS" alias="OPTIMIZE">
	<parameter name="TypeMessagePass" type="string" input="select">
		<option value="opt"  name="opt: FACES ONLY"/>
		<option value="all"  name="all: ALL GHOST CELLS"
				     		    	  default="T"/>
	</parameter>
#MESSAGEPASS
all			TypeMessagePass

Possible values for TypeMessagePass:
\begin{verbatim}
'all'	   - fill in all ghost cells (corners, edges and faces)
'opt'      - fill in face ghost cells only 
\end{verbatim}
The default value is 'all', because there are many schemes that require
the ghost cells at the edges and corners (viscosity, resistivity, Hall MHD, 
radiative diffusion, accurate resolution change algorithm, etc.). 
These will automatically change to the 'all' option even if the user sets
"opt", which is only recommended for advanced users.
</command>

<command name="RESOLUTIONCHANGE">
	<parameter name="UseAccurateReschange"  type="logical" default="F" />
	<parameter name="UseTvdReschange"       type="logical" default="T" />
	<parameter name="BetaLimiterResChange"  type="real" min="1" max="2"
						default="2" />
	<parameter name="nFaceLimiterResChange" type="integer" min="0"
						default="2" />
	<rule expr="not($UseAccurateReschange and $UseTvdReschange)">
		Cannot have both UseAccurateReschange and UseTvdReschange true.
	</rule>
#RESOLUTIONCHANGE
F		UseAccurateResChange
T		UseTvdResChange
2.0		BetaLimiterResChange
2		nFaceLimiterResChange

If UseAccurateResChange is true, then a second order accurate, upwind and 
oscillation free scheme is used at the resolution changes. 
It requires message passing edge ghost cells (this is switched on 
automatically) which may effect the performance slightly.

If UseTvdResChange is true, then an almost second order and partially 
downwinded TVD limited scheme is used at the resolution changes. 
This scheme does not require message passing of the edge ghost cells.
Only one of UseAccurateResChange and UseTvdResChange can be true.

If BetaLimiterResChange is set to a value smaller than the BetaLimiter
parameter in the #SCHEME command, then the limiter will use this
BetaLimiterResChange parameter at and near grid resolution changes.
The smallest value is 1.0 that corresponds to the minmod limiter,
the maximum value is 2.0 that means that the same limiter is applied
at the resolution change as anywhere else. Recommended values are 1.0 to 1.2
combined with BetaLimiter=1.5 in the #SCHEME command.

The nFaceLimiterResChange determines how many faces around the resolution
change itself are affected. If nFaceLimiterResChange is 0, the limiter using
BetaLimiterResChange is applied at the face at the resolution change itself.
If nFaceLimiterResChange is 1 or 2, the limiter is applied at 3 or 5 faces
altogether. The recommended value is 2. 

Default values are shown, ie. the TVD reschange algorithm is used, and 
the limiter applied at the resolution changes is the same as everywhere else,
because BetaLimiterResChange is set to 2.
</command>

<command name="RESCHANGE">
	<parameter name="UseAccurateReschange" type="logical" default="F" />
#RESCHANGE
T		UseAccurateResChange

This command is kept for backwards compatibility.
See description at the #RESOLUTIONCHANGE command.
</command>

<command name="TVDRESCHANGE">
	<parameter name="UseTvdReschange" type="logical" default="T" />
#TVDRESCHANGE
T		UseTvdResChange

This command is kept for backwards compatibility.
See description at the #RESOLUTIONCHANGE command.
</command>

<command name="LIMITER">
	<parameter name="UseLogRhoLimiter" type="logical" default="F" />
	<parameter name="UseLogPLimiter" type="logical" default="F" />
	<parameter name="UseRhoRatioLimiter" type="logical" default="F" />
	<parameter name="NameVarLimitRatio" type="string" length="100" 
		if="$UseScalarRhoLimiter" />

#LIMITER
F		UseLogRhoLimiter
F		UseLogPLimiter
T		UseRhoRatioLimiter
Xe Be Pl	NameVarLimitRatio (read if UseRhoRatioLimiter)

The spatially second order scheme uses a limited reconstruction to obtain
face values from the cell center values. The order of the scheme and the
type of the limiter can be set in the #SCHEME command. This command 
provides additional options to the limiting procedure.

If UseLogRhoLimiter is true, the logarithm of the density is limited instead
of the density itself. This can reduce numerical diffusion in regions where
the density changes exponentially with distance (e.g. in the solar corona).

If UseLogPLimiter is true, the logarithm of pressure is limited instead of
the pressure itself. 

If UseRhoRatioLimiter is true, then parameter NameVarLimitRatio is 
read and the variables listed in NameVarLimitRatio (the variable 
names are defined in ModEquation) are divided by the total density before 
the limiter is applied and then multiplied back by the density at the 
face after the limiting is completed. This modification is useful for the 
high energy density simulations of the CRASH project for the level set 
functions or for the internal energy associated with ionization.

Default values are false for all variables, which results in the limited 
reconstruction procedure directly applied to the original primitive variables
(velocity and pressure).
</command>

<command name="CLIMIT">
	<parameter name="UseClimit" type="logical" default="F"/>
	<if expr="$UseClimit">
		<parameter name="ClimitDim" type="real" min="0" 
							default="3000"/>
		<parameter name="rClimit" type="real" default="6"/>
	</if>
#CLIMIT
T			UseClimit (rest of parameters are read if true)
3000.0			ClimitDim [km/s]
6.0			rClimit

If UseClimit is true, the wave speeds used in the numerical diffusive fluxes
are limited by the value of ClimitDim (in I/O units, typically km/s) 
within the sphere of radius rClimit (typically in units of planetery radii). 
This scheme cannot be used with a fully explicit time integration, because
it will not be stable! One should use the fully or part implicit scheme
(see the #IMPLICIT command). In contrast with the Boris correction (see
the #BORIS command), this scheme is fully consistent with the governing 
equations in time accurate mode as well. It can be combined with 
the Roe scheme too unlike the Boris correction. The limiting scheme
cannot be combined with the HLLD scheme (neither can be the Boris correction
at this point).

A reasonable set of values are shown above. Much smaller velocity limit
will result in slow convergence for the implicit solver. The radial limit is 
not very crucial, but it should be set large enough to cover the whole region
where the wave speed may exceed it and the reduced diffusion is important.

Default is UseClimit false.
</command>

<command name="BORIS">
	<parameter name="UseBorisCorrection" type="logical" default="F"/>
	<parameter name="BorisClightFactor" type="real" min="0" max="1"
					default="1" if="$UseBorisCorrection" />
#BORIS
T			UseBorisCorrection
1.0			BorisClightFactor !Only if UseBorisCorrection is true

Default is boris_correction=.false.
Use semi-relativistic MHD equations with speed of light reduced by
the BorisClightFactor. Set BorisClightFactor=1.0 for true semi-relativistic
MHD. Gives the same steady state as normal MHD analytically, but there
can be differences due to discretization errors. 
You can use either Boris or BorisSimple but not both.
</command>

<command name="BORISSIMPLE">
	<parameter name="UseBorisSimple" type="logical" default="F"/>
	<parameter name="BorisClightFactor" type="real" min="0" max="1"
					default="1" if="$UseBorisSimple" />
#BORISSIMPLE
T			UseBorisSimple
0.05			BorisClightFactor !Only if UseBorisSimple is true

Default is UseBorisSimple=.false. 
Use simplified semi-relativistic MHD with speed of light reduced by the
BorisClightFactor. This is only useful with BorisClightFactor less than 1.
Should give the same steady state as normal MHD, but there can be a
difference due to discretization errors.
You can use either Boris or BorisSimple but not both.
</command>

<command name="USEB0">
	<parameter name="UseB0" type="logical" default="F"/>
#USEB0
F		UseB0

If UseB0 is true, the magnetic field is split into an analytic B0 and
a numerical B1 field. The B0 field may be a (rotating) dipole of a planet, 
or the potentialf field solution for the corona. B1 is not small relative
to B0 in general. The default value depends on the application.
</command>

<command name="USECURLB0">
	<parameter name="UseCurlB0" type="logical" default="F"/>
	<parameter name="rCurrentFreeB0" type="real" min="0" default="2.5"
	    if="$UseCurlB0" />

#USECURLB0
T		UseCurlB0
2.5		rCurrentFreeB0 (read if UseCurlB0 is true)

If UseCurlB0 is true then the B0 field has non-zero curl.
The B0 field of planets has zero curl, but the potential field source surface
model (PFSS) for the corona has a finite curl beyond the source surface, 
where the field is forced to become radial. 

The rCurrentFreeB0 parameter is set to the radius within which the B0 field
has no curl (i.e. it is current free).

The default is UseCurlB0 false.
</command>

<command name="DIVB">
	<parameter name="UseDivbSource"    type="logical" default="T"/>
	<parameter name="UseDivbDiffusion" type="logical" default="F"/>
	<parameter name="UseProjection"    type="logical" default="F"/>
	<parameter name="UseConstrainB"    type="logical" default="F"/>
	<rule 
	expr="not($UseProjection and ($UseDivbSource or $UseDivbDiffusion or $UseConstrainB))">
		If UseProjection is true, all others should be false.
	</rule>
	<rule
	expr="not($UseConstrainB and ($UseDivbSource or $UseDivbDiffusion or $UseProjection))">
		If UseConstrainB is true, all others should be false.
	</rule>
#DIVB
T			UseDivbSource
F			UseDivbDiffusion
F			UseProjection
F			UseConstrainB

Default values are shown above.
If UseProjection is true, all others should be false.
If UseConstrainB is true, all others should be false.
At least one of the options should be true unless the hyperbolic cleaning
is used. The hyperbolic cleaning can be combined with UseDivbSource only.
</command>

<command name="DIVBSOURCE">
	<parameter name="UseB0Source"       type="logical" default="T"/>
#DIVBSOURCE
T			UseB0Source

Add extra source terms related to the non-zero divergence and curl of B0.
Default is true.
</command>

<command name="HYPERBOLICDIVB">
	<parameter name="UseHyperbolicDivb" type="logical" default="T"/>
	<if expr="$UseHyperbolicDivb">
		<parameter name="SpeedHypDim" type="real" min="0" default="1"/>
		<parameter name="HypDecay" type="real" min="-1" max="0.5"
						default="0.1"/>
	</if>	
#HYPERBOLICDIVB
T			UseHyperbolicDivb
400.0			SpeedHypDim
0.1			HypDecay

This command sets the parameters for hyperbolic/parabolic cleaning. The command
(and the hyperbolic cleaning method) can only be used of there is a hyperbolic
scalar named Hyp in the equation module. The SpeedHypDim parameter sets the 
propagation speed for div B errors in dimensional units. Do not use a speed
that limits the time step (ie. exceeds the fastest wave speed). The HypDecay
parameter is for the parabolic cleaning. If HypDecay is less than zero, no
parabolic cleaning is applied. If it is positive, the scalar field is
modified as Hyp=Hyp*(1-HypDecay) after every update. This corresponds to
a point implicit evaluation of a parabolic diffusion of the Hyp scalar.

Default values are UseHyperbolicDivb true, the speed SpeedHyp is 1.0 in
the normalized units, and HypDecay=0.1.
</command>

<command name="PROJECTION">
	<parameter name="TypeProjectIter" type="string" input="select">
		<option name="Conjugate Gradients" value="cg" default="T"/>
		<option name="BiCGSTAB" value="bicgstab" 		/>
	</parameter>
	<parameter name="TypeProjectStop" type="string" input="select">
		<option name="Relative norm" value="rel" default="T"	/>
		<option name="Maximum error" value="max"		/>
	</parameter>
	<parameter name="RelativeLimit" type="real" min="0" max="1"
							default="0.1" />
	<parameter name="AbsoluteLimit" type="real" min="0"
							default="0.0" />
	<parameter name="MaxMatvec" type="integer" min="1" default="50" />
#PROJECTION
cg			TypeProjectIter:'cg' or 'bicgstab' for iterative scheme
rel			TypeProjectStop:'rel' or 'max' error for stop condition
0.1			RelativeLimit
0.0			AbsoluteLimit 
50			MaxMatvec (upper limit on matrix.vector multipl.)

Default values are shown above.\\

\noindent
For symmetric Laplacian matrix TypeProjectIter='cg' (Conjugate Gradients)
should be used, as it is faster than BiCGSTAB. In current applications
the Laplacian matrix is always symmetric.\\

\noindent 
The iterative scheme stops when the stopping condition is fulfilled:
\begin{verbatim}
  TypeProjectStop = 'rel': 
       stop if ||div B||    &lt; RelativeLimit*||div B0||
  TypeProjectStop = 'max' and RelativeLimit is positive:
       stop if max(|div B|) &lt; RelativeLimit*max(|div B0|)
  TypeProjectStop = 'max' and RelativeLimit is negative: 
       stop if max(|div B|) &lt; AbsoluteLimit
\end{verbatim}
  where {\tt ||.||} is the second norm, and B0 is the magnetic
  field before projection. In words 'rel' means that the norm of the error
  should be decreased by a factor of RelativeLimit, while 
  'max' means that the maximum error should be less than either
  a fraction of the maximum error in div B0, or less than the constant 
  AbsoluteLimit.

  Finally the iterations stop if the number of matrix vector
  multiplications exceed MaxMatvec. For the CG iterative scheme
  there is 1 matvec per iteration, while for BiCGSTAB there are 2/iteration.

 In practice reducing the norm of the error by a factor of 10 to 100 in 
 every iteration works well.

 Projection is also used when the scheme switches to constrained transport.
 It is probably a good idea to allow many iterations and require an
 accurate projection, because it is only done once, and the constrained
 transport will carry along the remaining errors in div B. An example is

#PROJECTION
cg			TypeProjIter
rel			TypeProjStop
0.0001			RelativeLimit
0.0			AbsoluteLimit 
500			MaxMatvec

</command>

<command name="CORRECTP">
	<parameter name="pRatioLow" type="real" min="0" max="1"
							default="0.01"/>
	<parameter name="pRatioHigh" type="real" min="$pRatioLow" max="1"
							default="0.1"/>
#CORRECTP
0.01			pRatioLow
0.1			pRatioHigh

Default values are shown. 

The purpose of the correctP subroutine is to remove any discrepancies between
pressure stored as the primitive variable P and the pressure calculated 
from the total energy E. Such discrepancies can be caused by the 
constrained transport scheme and by the projection scheme which modify 
the magnetic energy. The algorithm is the following:
\begin{verbatim}
Define the rato of thermal and total energies q = eThermal/e and

If              q &lt; pRatioLow   then E is recalculated from P
If pRatioLow  &lt; q &lt; pRatioHigh  then both P and E are modified depending on q
If pratioHigh &lt; q               then P is recalculated from E
\end{verbatim}
The second case is a linear interpolation between the first and third cases.
</command>

<command name="RAYTRACE">
	<parameter name="UseRaytrace" type="logical" default="T"/>
	<if expr="$UseRaytrace">
		<parameter name="UseAccurateTrace" type="logical" default="F"/>
		<parameter name="DtExchangeRay" type="real" 
			min="0.01" max="60" default="0.1" />
		<parameter name="DnRaytrace" type="integer" 
			min="1" default="1" />
	</if>

#RAYTRACE
T			UseRaytrace (rest is read if true)
T			UseAccurateTrace
0.1			DtExchangeRay [sec]
1			DnRaytrace

Raytracing (field-line tracing) is needed to couple the GM with the IM or RB 
components. It can also be used to create plot files with open-closed 
field line information. There are two algorithms implemented for integrating 
rays and for tracing rays.

By default UseRaytrace oarameter is true if there is magnetic field in the 
equation module. The parameter can be set to false to save memory allocation.

If UseAccurateTrace is false (default), the block-wise algorithm is used,
which interpolates at block faces. This algorithm is fast, but less 
accurate than the other algorithm. If UseAccurateTrace is true, 
the field lines are followed all the way. It is more accurate but 
potentially slower than the other algorithm.

In the accurate tracing algorithms, when the ray exits the domain that belongs 
to the PE, its information is sent to the other PE where the ray continues. 
The information is buffered for sake of efficiency and to synchronize
communication. The frequency of the information exchanges 
(in terms of CPU seconds) is given by the DtExchangeRay parameter. 
This is an optimization parameter for speed. Very small values of DtExchangeRay
result in many exchanges with few rays, while very large values result
in infrequent exchanges thus some PE-s may become idle (no more work to do).
The optimal value is problem dependent. A typically acceptable value is 
DtExchangeRay = 0.1 seconds (default).

The DnRaytrace parameter contains the minimum number of iterations between
two ray tracings. The default value 1 means that every new step requires
a new trace (since the magnetic field is changing). A larger value implies
that the field does not change significantly in that many time steps.
The ray tracing is always redone if the grid changes due to an AMR.

Default values are UseAccurateIntegral = .true. (if there is magnetic field), 
UseAccurateTrace = .false., DtExchangeRay = 0.1 and DnRaytrace=1.
</command>

<command name="RAYTRACELIMIT">
	<parameter name="RayLengthMax" type="real" default="100"/>

#RAYTRACELIMIT
50			RayLengthMax

RayLengthMax provides the maximum length in planet radius for tracing a ray. 
This avoid tracing extremely long field lines that are not used later.
The default is 100 planet radius.
</command>

<command name="IE">
	<parameter name="DoTraceIE" type="logical" default="F"/>

#IE
T                       DoTraceIE

DoTraceIE will activate accurate ray tracing on closed fieldlines for
coupling with the IE module.  If not set, then only Jr is sent.  If set, then
Jr as well as 1/B, average rho, and average p on closed fieldlines are passed.
</command>

<command name="IECOUPLING">
	<parameter name="UseIonoVelocity" type="logical" default="F"/>
	<if expr="$UseIonoVelocity">
		<parameter name="rCoupleUiono" type="real" min="1" 
							default="4"/>
		<parameter name="TauCoupleUiono" type="real" min="0" 
							default="10"/>
	</if>

#IECOUPLING
T			UseIonoVelocity (rest of parameters read if true)
4.0			rCoupleUiono
10.0			TauCoupleUiono

This command sets parameters for a new experimental coupling of
the velocity from IE to GM. 

The rCoupleUiono paramter determines the radius within which the GM
velocity is effected.
The TauCoupleUiono parameter determine how fast the GM velocity
should be nudged towards the E x B drift plus corotation.

The IE potential and the resulting velocity are updated every time IE->GM 
coupling occurs, but the nudging towards the velocity is done in every GM 
time step. When GM is not run in time accurate mode, the orthogonal (to B)
velocity is set as

uOrth' = uOrth + (uIonoOrth - uOrth)/(TauCoupleUiono+1)

Therefore the larger TauCoupleUiono is the slower the adjustment will be.
It takes approximately 2*TauCoupleUiono time steps to get the orthogonal
velocity close to what the ionosphere would prescribe.
In time accurate mode, the nudging is based on physical time:

uOrth' = uOrth + min(1.0, dt/TauCoupleUiono)*(uIonoOrth - uOrth)

where dt is the time step. It takes about 2*TauCoupleUiono seconds
to get uOrth close to uIonoOrth. If the time step dt exceeds TauCoupleIm, 
uOrth is set in a single step.

By default the coupling is switched off.
</command>

<command name="IM">
	<parameter name="TauCoupleIm" type="real" min="1"/>
	<parameter name="DoImSatTrace" type="logical" default="F" />

#IM
20.0			TauCoupleIm
F			DoImSatTracing

Same as command IMCOUPLING, except it only reads the first and second
parameters of #IMCOUPLING.

The default value is TauCoupleIm=20.0, which corresponds to typical nudging
and DoImSatTrace false.
</command>

<command name="MULTIFLUIDIM">
	<parameter name ="DoMultiFluidIMCoupling" type="logical" default="F"/>

#MULTIFLUIDIM
F			DoMultiFluidIMCoupling

If DoMultiFluidIMCoupling is true, the information exchanged between GM and IM 
is in multi-fluid mode: GM gives IM four more variables (density_Hp, 
density_Op, pressure_Hp, pressure_Op) in addition to one-fluid MHD paramters,
and IM passes GM the same four more variables.

The default value is DoMultiFluidIMCoupling = false, MHD variables are 
exchanged between GM and IM.
</command>


<command name="IMCOUPLING">
	<parameter name="TauCoupleIm" type="real" min="1"/>
	<parameter name="DoImSatTrace" type="logical" default="F" />
	<parameter name="DoCoupleImPressure" type="logical" default="T"/>
	<parameter name="DoCoupleImDensity"  type="logical" default="F"/>
	<parameter name="DoFixPolarRegion"   type="logical" default="F"/>
	<if expr="$DoFixPolarRegion">
		<parameter name="rFixPolarRegion" type="real" min="1" 
							default="5"/>
		<parameter name="PolarNDim" type="real" min="0" default="20"/>
		<parameter name="PolarTDim" type="real" min="0" default="1e5"/>
	</if>
#IMCOUPLING
20.0			TauCoupleIm
F			DoImSatTrace
T			DoCoupleImPressure
F			DoCoupleImDensity
T			DoFixPolarRegion (rest read if true)
5.0			rFixPolarRegion
20.0            	PolarNDim [amu/cc] for fluid 1
100000.0        	PolarTDim [K]      for fluid 1
2.0        		PolarNDim [amu/cc] for fluid 2
20000.0        		PolarTDim [K]      for fluid 2

This command sets various parameters for the GM-IM coupling.

The TauCoupleIm parameter determine how fast the GM pressure p 
(and possibly density rho) 
should be nudged towards the IM pressure pIm (and density dIM). 
The RCM pressure and denstiy are updated every time IM->GM coupling occurs,
but the nudging towards these values is done in every GM time step.
When GM is not run in time accurate mode, the pressure is set as

p' = (p*TauCoupleIm + pIm)/(TauCoupleIm+1)

Therefore the larger TauCoupleIm is the slower the adjustment will be.
It takes approximately 2*TauCoupleIm time steps to get p close to pIm.
In time accurate mode, the nudging is based on physical time:

p' = p + min(1.0, dt/TauCoupleIm)*(pIm - p)

where dt is the time step. It takes about 2*TauCoupleIm seconds
to get p close to pIm. If the time step dt exceeds TauCoupleIm, 
p' = pIm is set in a single step.
The default value is TauCoupleIm=20.0, which corresponds to typical nudging.

The DoImSatTrace logical sets whether the IM component receives the locations 
of the satellites in GM mapped down along the magnetic field lines. The IM
component then can produce satellite output files with IM data.

The DoCoupleImPressure logical sets whether GM pressure is driven by IM 
pressure. Default is true, and it should always be true (except for testing), 
because pressure is the dominant variable in the IM to GM coupling.

The DoCoupleImDensity logical sets whether the GM density is driven 
by IM density. The default value is false. This is a new feature in the 
IM-GM coupling, which is not fully tested.

The DoFixPolarRegion logical decides if we try to fix the pressure 
(and density) values in the open field line region. The pressure/density 
tends to diffuse 
numerically from the closed field line region (nudged by IM) into the
polar region that should not be affected by IM. This can cause unphysically
fast outflow from the polar region. If DoFixPolarRegion is set to true, 
the pressure (and density) are nudged toward the values given 
in the #POLARBOUNDARY command in the open field line region within
radius defined by rFixPolarRegion and where the flow points outward.
This is a very new feature that hasn't been tested in real runs yet.

If DoFixPolarRegion is true then the following parameters are also read:

The rFixPolarRegion radius (given in planetary radii) sets the outer
limit for nudging the pressure (density) in the open field line region
towards the PolarNDim and PolarTDim values. For multi-fluid MHD,
the PolarNDim and PolarTDim parameters are read for each fluid.

The default is to couple the IM pressure only and no fix is applied 
in the polar region.

</command>

</commandgroup>
<commandgroup name="PHYSICS PARAMETERS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!  PHYSICS PARAMETERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="GAMMA" if="$_IsFirstSession">
	<parameter name="Gamma" type="real" min="1" default="1.6666666667"/>
#GAMMA
1.6666666667		Gamma

The adiabatic index (ratio of the specific heats for fixed pressure
and volume. The default value is 5.0/3.0, which is valid for
monoatomic gas or plasma.
</command>

<command name="PLASMA">
	<parameter name="FluidMass"  type="real" min="0" default="1"/>
	<parameter name="IonCharge"  type="real"         default="1"/>
	<parameter name="ElectronTemperatureRatio" type="real" min="0" 
								default="0"/>
#PLASMA
1.0		FluidMass [amu]
1.0		IonCharge [e]
0.0		ElectronTemperatureRatio

For single fluid, single species MHD the FluidMass parameter determines the 
average mass of ions (and strongly coupled neutrals) in atomic mass units (amu).
This parameter is only used if there are no species (UseMultiSpecies=.false.
in ModEquation). The number density is n=rho/FluidMass.
For a pure hydrogen plasma FluidMass=1.0, while for a mix of 90 per cent 
hydrogen and 10 per cent helium FluidMass=1.4.

The IonCharge parameter gives the average ion charge in units of the proton
charge. For a fully ionized hydrogen plasma AverageIonCharge=1.0,
for a fully ionized helium plasma IonCharge=2.0, while
for a 10 per cent ionized hydrogene plasma IonCharge=0.1.

For multifluid MHD/HD the command reads the mass of all fluids (ions and neutrals),
and the charges of all ion fluids. For example for proton and double ionized helium 
and neutral oxygen molecule fluids:

#PLASMA
1.0             FluidMass H+ [amu]
4.0             FluidMass He++ [amu]
32.0		FluidMass O2 [amu]
1.0             IonCharge H+ [e]
2.0		IonCharge He++ [e]
0.2             ElectronTemperatureRatio

The ElectronTemperatureRatio determines the ratio of electron
and ion temperatures. The ion temperature Te = T * ElectronTemperatureRatio
where T is the ion temperature. The total pressure p = n*k*T + ne*k*Te,
so T = p/(n*k+ne*k*ElectronTemperatureRatio). If the electrons and ions are
in temperature equilibrium, ElectronTemperatureRatio=1.0.
For multi-fluid MHD the ElectronTemperatureRatio is interpreted as
electron pressure ratio. The electron pressure is taken as 
pE = ElectronTemperatureRatio*sum(pIon_I). Note that one can also
solve the electron pressure equation if 'Pe' is present in the 
equation module.

In a real plasma all these values can vary in space and time,
but in a single fluid/species MHD description using these constants is
the best one can do. In multispecies MHD the number density can
be determined accurately as n = sum(RhoSpecies_V/(ProtonMass*MassSpecies_V)).

The default ion/molecular masses are given in the equation module.
The default ion charges are always 1.
The default electron temperature ratio is zero, i.e. the electron
pressure is assumed to be negligible relative to the (total) ion pressure. 
This default is backwards compatible with previous versions of the code.

</command>

<command name="LOOKUPTABLE" multiple="T">
	<parameter name="NameTable" type="string" length="100"/>
	<parameter name="NameCommand" type="string" case="lower" 
	    input="select">
		<option value="load" default="T"/>
		<option value="use"/>
		<option value="use param"/>
		<option value="save"/>
		<option value="save param"/>
		<option value="make"/>
		<option value="make param"/>
		<option value="param"/>
	</parameter>
	<if expr="$NameCommand =~ /load|save|use/">
		<parameter name="NameFile" type="string" length="100"/>
		<parameter name="TypeFile" type="string" input="select">
			<option value="real8"  default="T"/>
			<option value="real4"/>
			<option value="ascii"/>
		</parameter>
	</if>
	<if expr="$NameCommand =~ /param/">
	        <parameter name="NameTableParam" type="string" length="100"/>
		<for from="1" to="count_split($NameTableParam)">
		     <parameter name="TableParam" type="real"/>
		</for>
	</if>
	<if expr="$NameCommand =~ /make|save|use/">
		<parameter name="StringDescription" type="string" 
							  length="100"/>
		<parameter name="NameVar"   type="string" length="100"/>
		<parameter name="nIndex1"   type="integer" min="2"/>
		<parameter name="Index1Min" type="real"/>
		<parameter name="Index1Max" type="real" min="$Index1Min"/>
		<parameter name="nIndex2"   type="integer" min="2"/>
		<parameter name="Index2Min" type="real"/>
		<parameter name="Index2Max" type="real" min="$Index1Min"/>
	</if>

#LOOKUPTABLE
p(rho,e)			NameTable
use param			NameCommand (use, load, save, make, param)
table1.out			NameFile (read this unless "make")
ascii				TypeFile (read this unless "make")
zXe zBe nPl			NameTableParam (if NameCommand has "param")
54.0				TableParam number of protons in Xenon
4.0				TableParam number of protons in Beryllium
4.0				TableParam number of elements in plastic
p(rho,e) for ionized plasma	Description (read this and rest unless "load")
logrho logp pXe pBe pPl		NameVar  
100				nIndex1
1e-6				Index1Min
1e+6				Index1Max
50				nIndex2
0.001				Index2Min
100.0				Index2Max

Tables are identified by the NameTable string that should be unique for 
the table and must agree with the name used in the ModUser module.
The NameCommand tells if we should "load" the table from a file, 
"make" the table using some algorithm defined in the ModUser module, 
or make the table and then "save" it into a file. The "use" option is
the same as "load" if the table file already exists, otherwise it is
the same as "save". 

If NameCommand contains "param" and the table is not loaded from a file, 
then the NameTableParam variable and the TableParam values of table 
parameters are read from the input file and stored into the table.

The file name and file type ("ascii", "real4" or "real8") of the table 
are read when NameCommand contains "load", "save", or "use". 

The rest of the parameters are read for commands "make", "save" or "use".
The NameVar string contains the space separated list of the names of 
the two indexes and the one or more returned value(s). If the index name starts
with a "log", a logarithmic index is assumed (ie. the table will be uniform
in the logarithm of the index value). The nIndex1 defines the number of 
columns in the table, Index1Min and Index1Max the smallest and largest values
for the first index, respectively. The nIndex2, Index2Min, Index2Max define
the number and range of the second index.

This command can occur multiple times. By default no lookup tables are used.
</command>

<command name="UNIFORMSTATE" if="$_IsFirstSession">
	<parameter name="Var1"  type="real"	/>
	<parameter name="Var2"  type="real" />

#UNIFORMSTATE
0.125		Var1
1.0		Var2
-0.5		...
0.0		
1.0		

The #UNIFORMSTATE command sets up a uniform initial state. This uniform
state can be perturbed or modified by the user module.
The command sets the primitive variables in the order defined in 
the equation module. 
</command>

<command name="SHOCKTUBE" if="$_IsFirstSession">
	<parameter name="Var1Left"  type="real"	/>
	<parameter name="Var2Left"  type="real" />
	<parameter name="Var1Right"  type="real" />
	<parameter name="Var2Right"  type="real" />

#SHOCKTUBE
1.		Var1Left
0.		Var2Left
0.		...
0.		
0.75		
1.		
0.		
1.		
0.125		Var1Right
0.		Var2Right
0.		...
0.		
0.75
-1.		
0.		
0.1		

The #SHOCKTUBE command can be used to set up a shocktube problem.
The left and right state values are given in terms of the primitive
variables as defined in the equation module. 
The shock can be shifted and rotated by the #SHOCKPOSITION command.

By default the initial condition is uniform, and the
values are determined by the #SOLARWIND command. The user module
can be used to set up more complicated initial conditions.
</command>

<command name="SHOCKPOSITION" if="$_IsFirstSession">
	<parameter name="ShockPosition" type="real" default="0"/>
	<parameter name="ShockSlope" type="real" input="select">
		<option value="0.0"  name="no rotation" default="T"	/>
		<option value="0.25" name="1/4"				/>
		<option value="0.3333333333333333333" name="1/3"	/>
		<option value="0.5"  name="1/2"				/>
		<option value="1"					/>
		<option value="2"					/>
		<option value="3"					/>
		<option value="4"					/>
	</parameter>
#SHOCKPOSITION
5.0			ShockPosition
1/2			ShockSlope

The ShockPosition parameter sets the position where the shock,
ie. the interface between the left and right states given by
the #SHOCKTUBE command, intersects the X axis. 
When ShockSlope is 0, the shock normal points in the X direction.
Otherwise the shock is rotated around the Z axis, and the tangent of 
the rotation angle is given by ShockSlope. Possible values are
\begin{verbatim}
  ShockSlope = 0., 1/4, 1/3, 1/2, 1., 2., 3., 4.
\end{verbatim}
because these angles can be accurately represented
on the grid. The default values are zero, ie. the shock is in the
X=0 plane.
</command>

<command name="SOLARWIND" if="$_IsFirstSession">
	<parameter name="SwNDim"   type="real" min="-1"	default="5"	/>
	<parameter name="SwTDim"   type="real" min="-1"	default="100000." />
	<parameter name="SwUxDim"  type="real"		default="-400"	/>
	<parameter name="SwUyDim"  type="real"		default="0"	/>
	<parameter name="SwUzDim"  type="real"		default="0"	/>
	<parameter name="SwBxDim"  type="real"		default="0"	/>
	<parameter name="SwByDim"  type="real"		default="0"	/>
	<parameter name="SwBzDim"  type="real"		default="-5"	/>
#SOLARWIND
5.0			SwNDim  [n/cc]
100000.0		SwTDim  [K]   
-400.0			SwUxDim [km/s]
0.0			SwUyDim [km/s]
0.0			SwUzDim [km/s]
0.0			SwBxDim [nT]  
0.0			SwByDim [nT]  
-5.0			SwBzDim [nT]  

This command defines the solar wind parameters for the GM component.
The default values are all 0.0-s.
</command>

<command name="SOLARWINDFILE" alias="UPSTREAM_INPUT_FILE">
	<parameter name="UseSolarWindFile" type="logical" default="F"/>
	<if expr="$UseSolarWindFile">
		<parameter name="NameSolarWindFile" type="string" 	
			length="100"/>
	</if>
	<rule expr="-f $NameSolarWindFile">
		Solar wind file $NameSolarWindFile must exist
	</rule>
#SOLARWINDFILE
T			UseSolarWindFile (rest of parameters read if true)
IMF.dat                 NameSolarWindFile

Default is UseSolarWindFile = .false.

Read IMF data from file NameSolarWindFile if UseSolarWindFile is true.
The data file contains all information required for setting the upstream
boundary conditions. Parameter TypeBcWest should be set to 'vary' for
the time dependent boundary condition.

If the #SOLARWIND command is not provided then the first time read from
the solar wind file will set the normalization of all variables
in the GM component. Consequently either the #SOLARWIND command or
the #SOLARWINDFILE command with UseSolarWindFile=.true.
is required by the GM component.

The input files are strutured similar to the PARAM.in file.  There are 
{\tt #commands} that can be  inserted as well as the data.
The file containing the upstream conditions should include data in the 
following order:
\begin{verbatim}
yr mn dy hr min sec msec bx by bz vx vy vz dens temp
\end{verbatim}
The units of the variables should be:
\begin{verbatim}
Magnetic field (b)     nT
Velocity (v)           km/s
Number Density (dens)  cm^-3
Temperature (Temp)     K
\end{verbatim}

The input files  can have the following optional commands at the beginning
\begin{verbatim}
#REREAD      Reread the file if the simulation runs beyond the final time

#COOR
GSM          The coordinate system of the data: GSM (default) or GSE

#VAR
rho ux uy uz bx by bz p pe

#PLANE       The input data represents values on a tilted plane
20.0         Angle to rotate in the XY plane [deg]
15.0         Angle to rotate in the XZ plane [deg]

#POSITION    Y-Z Position of the satellite (also origin of plane rotation)
20.0         Y location
30.0         Z location

#SATELLITEXYZ  3D Position of the satellite
65.0         X location
0.0          Y location
0.0          Z location

#ZEROBX
T            Bx is ignored and set to zero if true

#TIMEDELAY
3600.0       A constant delay added to the time in the file [s]
\end{verbatim}
The #REREAD command tells BATS-R-US to reread the solarwind file 
when the simulation goes past the time of the last data in the current file.
The default behavior is to keep using the last data point.

The #VAR command allows reading an extended set of variables, 
e.g. densities of multiple species, electron pressure, etc.

Finally, the data should be preceded by a {\tt #START}.  The beginning of 
a typical solar wind input file might look like:
\begin{verbatim}
#COOR
GSM

#START
 2004  6  24   0   0  58   0  2.9  -3.1 - 3.7  -300.0  0.0  0.0  5.3  2.00E+04
 2004  6  24   0   1  58   0  3.0  -3.2 - 3.6  -305.0  0.0  0.0  5.4  2.01E+04
\end{verbatim}

The maximum number of lines of data allowed in the input file is 50,000.  
However, this can be modified by changing the variable Max_Upstream_Npts 
in the file GM/BATSRUS/get_solar_wind_point.f90. 
</command>

<command name="BODY" alias="MAGNETOSPHERE" if="$_IsFirstSession">
	<parameter name="UseBody" type="logical" default="F"/>
	<if expr="$UseBody">
		<parameter name="rBody" type="real" min="0" default="3"/>
		<parameter name="rCurrents" type="real" min="-1" default="4"
			if="$NameComp eq 'GM'"/>
		<parameter name="BodyNDim" type="real" min="0" default="1"/>
		<parameter name="BodyTDim" type="real" min="0" default="1000"/>
	</if>
#BODY
T			UseBody (rest of parameters read if true)
3.0			rBody (user units)
4.0			rCurrents (only read for GM component)
1.0			BodyNDim (/cc) for fluid 1
10000.0			BodyTDim (K)   for fluid 1
0.01			BodyNDim (/cc) for fluid 2
300.0			BodyTDim (K)   for fluid 2

If UseBody is true, the inner boundary is a spherical surface
with radius rBody. The rBody is defined in units of the planet/solar
radius. It can be 1.0, in which case the simulation extends all the
way to the surface of the central body. In many cases it is more
economic to use an rBody larger than 1.0. 

The rCurrents parameter defines where the currents are calculated for
the GM-IE coupling. This only matters if BATSRUS is running as GM
and it is coupled to IE.

The BodyNDim and BodyTDim parameters define the number density and temperature
inside the body. For multifluid MHD the number density and temperature
are given for all the fluids. The exact effect of these parameters depends 
on the settings in the #INNERBOUNDARY command.

The default values depend on the component: 
For GM rBody=3, rCurrents=4, BodyNDim = 5/cc and BodyTDim = 25000 K. 
For SC/IH/OH: rBody=1, BodyNDim = 1.5e8/cc, BodyTDim = 2.8e6 K.
The rBody and rCurrents are given in normalized units (usually
planetary or solar radii).
</command>

<command name="GRAVITY" if="$_IsFirstSession">
	<parameter name="UseGravity" type="logical" default="F" />
	<parameter name="iDirGravity" type="integer" input="select"
							if="$UseGravity">
		<option name="central mass" value="0" default="T"	/>
		<option name="X direction"  value="1"			/>
		<option name="Y direction"  value="2"			/>
		<option name="Z direction"  value="3"			/>
	</parameter>
	<parameter name="GravitySi" type="real" default="-10.0"
							if="$iDirGravity&gt;0"/>

#GRAVITY
T			UseGravity (rest of parameters read if true)
3			iDirGravity(0 - central, 1 - X, 2 - Y, 3 - Z direction)
10.0			GravitySi [m/s^2] (read if iDirGravity is not 0)

If UseGravity is false, the gravitational force of the central body
is neglected. If UseGravity is true and iDirGravity is 0, the
gravity points towards the origin and the gravitational force is
determined by the mass of the central body. If iDirGravity is 1, 2 or 3,
the gravitational force is parallel with the X, Y or Z axes, respectively,
and the gravitational acceleration is given by the GravitySi parameter.

Default values depend on problem_type.

When a second body is used the gravity direction for the second body
is independent of the GravityDir value.  Gravity due to the second body
is radially inward toward the second body.
</command>

<command name="RESISTIVITY">
	<parameter name="UseResistivity" type="logical" default="F"	/>
	<if expr="$UseResistivity">
		<parameter name="TypeResistivity" type="string" case="lower"
			input="select" >
			<option name="constant" default="T"/>
			<option name="spitzer"             />
			<option name="anomalous"           />
			<option name="user"                />
		</parameter>
		<if expr="$TypeResistivity =~ /spitzer/">
			<parameter name="CoulombLogarithm" type="real" 
							default="20" />
		</if>
		<if expr="$TypeResistivity =~ /constant/">
			<parameter name="Eta0Si" type="real" min="0.0" 
							default="1.0E+11"/>
		</if>
		<if expr="$TypeResistivity =~ /anomalous/">
			<parameter name="Eta0Si" type="real" min="0.0" 
							default="1.0E+9"/>
			<parameter name="Eta0AnomSi" type="real"
						default="2E+09"	/>
			<parameter name="EtaMaxAnomSi" type="real"
						default="2E+10"	/>
			<parameter name="jCritAnomSi" type="real" min="0"
						default="1.0E-9"/>
		</if>
		<if expr="$TypeResistivity =~ /user/">
			<parameter name="Eta0Si" type="real" min="0.0" 
							default="1.0"/>
		</if>
	</if>
#RESISTIVITY
T		UseResistivity (rest of parameters read only if set to true)
anomalous	TypeResistivity
1.0E+9		Eta0Si       [m2/s] (read except for Spitzer resistivity)
2.0E+9		Eta0AnomSi   [m2/s] (read for anomalous resistivity only)
2.0E+10		EtaMaxAnomSi [m2/s] (read for anomalous resistivity only)
1.0E-9		jCritAnomSi  [A/m2] (read for anomalous resistivity only)

The true SI units of resistivity are Ohm m = $N m^2 / (A^2 s)$. 
In BATSRUS, however, we use "normalized" units, so that the magnetic
permeability $[N/A^2]$ disappers from the equations. So what is 
described here as "resistivity", is really eta/mu_0 which has units of $[m^2/s]$,
same as (magnetic) diffusion. Since the normalized current is defined as curl B
(instead of curl B/mu0), the electric field is E = -u x B + eta * J in the
normalized units.

If UseResistitivy is false, no resistivity is included.
If UseResistivity is true, then one can select a constant resistivity,
the classical Spitzer resistivity, 
anomalous resistivity with a critical current, or a user defined resistivity.

For TypeResistivity='Spitzer' the resistivity is very low in space plasma.
The only parameter read is the CoulombLogarithm parameter with 
typical values in the range of 10 to 30.

For TypeResistivity='constant' the resistivity is uniformly set to 
the parameter Eta0Si.

For TypeResistivity='anomalous' the anomalous resistivity is 
Eta0Si + Eta0AnomSi*(j/jCritAnomSi-1) limited by 0 and EtaMaxAnomSi.
Here j is the absolute value of the current density in SI units.
See the example for the order of the parameters.

For TypeResistivity='user' only the Eta0Si parameter is read and it
can be used to scale the resistivity set in subroutine user_set_resistivity
in the ModUser module. Other parameters should be read with 
subroutine user_read_inputs of the ModUser file.

The default is UseResistivity=.false.
</command>

<command name="RESISTIVITYOPTIONS">
	<parameter name="UseResistiveFlux" type="logical" default="T"/>
	<parameter name="UseJouleHeating"  type="logical" default="T"/>
	<parameter name="UseHeatExchange"  type="logical" default="T"/>
#RESISTIVITYOPTIONS
T			UseResistiveFlux
T			UseJouleHeating
F			UseHeatExchange

Switch off negligible resistivity effects for sake of computational speed.
If UseResistiveFlux is false, the resistive terms in the induction equation
are neglected. If UseJouleHeating is false and non-conservative equations
are used then the Joule heating is neglected in the electron/ion pressure
equation. If UseHeatExchange is false, the heat exchange between electron
and ion pressures is neglected. 

The defaults are true for all three logicals.
</command>

<command name="RESISTIVEREGION" alias="RESISTIVITYREGION">
	 <parameter name="rZeroResist" type="real" min="-1" default="-1"/>
	 <parameter name="rFullResist" type="real" min="$rZeroResist" default="1e30"/>

#RESISTIVEREGION
4.0		rZeroResist
5.0		rFullResist

Mask the resistivity (set by the #RESISTIVITY command) depending on the
radial coordinate r. For r less than rZeroResist the resistivity is zero.
For r greater than rFullResist the full value of resistivity is used.
Between these two value the resistivity is linearly ramped up from zero
to the full value. This command can be used to reduce resistivity 
where the field aligned currents are calculated 
(set by the rCurrents parameter of the #BODY command), but still
apply resistivity where reconnection happens.

The default values are rZeroResist=-1 and rFullResist=1e30, 
so there is no masking applied.
</command>

<command name="HALLRESISTIVITY">
	<parameter name="UseHallResist" type="logical" default="F"/>
	<if expr="$UseHallResist">
		<parameter name="HallFactorMax" type="real" min="0" 
			default="1"/>
		<parameter name="HallCmaxFactor" type="real" min="0" max="1" 
			default="1"/>
	</if>

#HALLRESISTIVITY
T		UseHallResist (rest of parameters read only if true)
1.0		HallFactorMax
0.5		HallCmaxFactor

If UseHallResist is true the Hall resistivity is used.

The off-diagonal Hall elements of the resistivity tensor
are multiplied by HallFactorMax. If HallFactorMax is 1 then the 
physical Hall resistivity is used (but also see the #HALLREGION command).
Note that a physically consistent way of changing the strength of the 
Hall effect is changing the ion mass and/or charge with the #PLASMA command.

If HallCmaxFactor is 1.0, the maximum propagation speed takes into
account the full whistler wave speed. If it is 0, the wave speed
is not modified. For values betwen 1 and 0 a fraction of the whistler
wave speed is added. The full speed is needed for the stability
of the one or two-stage explicit scheme 
(unless the whistler speed is very small and/or the diagonal part of 
the resistivity tensor is dominant). 
For 3 and 4-stage explicit schemes (see the #RK command) and also
for the implicit time stepping the HallCmaxFactor can be reduced, 
possibly all the way to zero to minimize the discretization errors.

Default is UseHallResist false.
</command>

<command name="HALLREGION">
	<parameter name="NameHallRegion" type="string" input="select">
		<option name="all"  default="T"	/>
		<option name="sphere0"		/>
		<option name="box0"		/>
		<option name="sphere"		/>
		<option name="box"		/>
	</parameter>
	<if expr="$NameHallRegion ne 'all' and $NameHallRegion !~ /0/">
		<parameter name="x0Hall" type="real" default="0"/>
		<parameter name="y0Hall" type="real" default="0"/>
		<parameter name="z0Hall" type="real" default="0"/>
	</if>
	<if expr="$NameHallRegion =~ /sphere/">
		<parameter name="rSphereHall" type="real" min="0" default="1"/>
		<parameter name="DrSphereHall" type="real" min="0"
								default="0"/>
	</if>
	<if expr="$NameHallRegion =~ /box/">
		<parameter name="xSizeBoxHall" type="real" min="0" 
								default="1"/>
		<parameter name="DxSizeBoxHall" type="real" min="0"
								default="0"/>
		<parameter name="ySizeBoxHall" type="real" min="0" 
								default="1"/>
		<parameter name="DySizeBoxHall" type="real" min="0"
								default="0"/>
		<parameter name="zSizeBoxHall" type="real" min="0" 
								default="1"/>
		<parameter name="DzSizeBoxHall" type="real" min="0"
								default="0"/>
	</if>

#HALLREGION
box			NameHallRegion
10.0			x0Hall        (only read for region sphere or box)
0.0			y0Hall        (only read for region sphere or box)
0.0			z0Hall        (only read for region sphere or box)
8.0			xSizeBoxHall  (only read for region box)
1.0			DxSizeBoxHall (only read for region box)
6.0			ySizeBoxHall  (only read for region box)
1.0			DySizeBoxHall (only read for region box)
4.0			zSizeBoxHall  (only read for region box)
1.0			DzSizeBoxHall (only read for region box)

The NameHallRegion parameter determines the region where the Hall effect
is taken into account. Possible values are "all", "box", "sphere",
"box0" and "sphere0".

For value "all" the Hall effect is used everywhere
in the computational domain. For "box" and "sphere" the region is inside
a box or sphere, respectivrly, centered around the X0Hall, Y0Hall, Z0Hall.
If NameHallRegion = "box0" or "sphere0", the region is centered around 
the origin. 

For NameHallRegion "sphere" or "sphere0" the rSphereHall
and DrSphereHall parameters are read. The first determines the radius
of the sphere, the second the thickness of the shell where the hall
effect increases from 0 to its full value linearly. This smoothing
is useful to avoid artifacts due to a sudden change in the Hall coefficient.

For NameHallRegion "box" or "box0" the 3 sizes and 3 smoothing widths 
are read as shown in the example.

The default value is "all", ie. the Hall effect is applied everywhere
if the Hall effect is switched on in the #HALLRESISTIVITY command.
</command>

<command name="BIERMANNBATTERY">
	 <parameter name="UseBiermannBattery" type="logical" default="F"/>

#BIERMANNBATTERY
T		UseBiermannBattery

If UseBiermannBattery is true then the Biermann battery term in the
generalized Ohm's law is used, otherwise it is switched off.

If the Hall term is used in combination with the electron pressure
equation then the Biermann battery term is switched on by default.
In that case the BIERMANNBATTERY command is not needed.

Default is UseBiermannBattery false.
</command>

<command name="MINIMUMDENSITY">
	<parameter name="RhoMinDim" type="real" min="-1" default="-1"/>

#MINIMUMDENSITY
0.001		RhoMinDim [amu/cc] for fluid 1
-1.0		RhoMinDim [amu/cc] for fluid 2

Provide minimum density(s) for the ion/neutral fluid(s). If the minimum
density is positive, the density is kept above this limit for that fluid.
The minimum density is given in the input/output units for density,
which varies from application to application.
A negative value indicates that no minimum density is applied for that fluid.

By default no minimum density limit is applied.
</command>

<command name="MINIMUMPRESSURE">
	<parameter name="pMinDim" type="real" min="-1" default="-1"/>

#MINIMUMPRESSURE
0.001		pMinDim [nPa] for fluid 1
-1.0		pMinDim [nPa] for fluid 2

Provide minimum pressure(s) for the ion/neutral fluid(s). If the minimum
pressure is positive, the pressure is kept above this limit for that fluid.
The minimum pressure is given in the input/output units for pressure,
which varies from application to application.
A negative value indicates that no minimum pressure is applied for that fluid.

By default no minimum pressure limit is applied.
</command>

<command name="ELECTRONPRESSURE">
	 <parameter name="PeMinSi" type="real" min="-1" default="-1"/>

#ELECTRONPRESSURE
1.1e5			PeMinSi

Provide the minimum electron pressure threshold in SI units. 
Currently the minimum electron pressure is only used in ModRadDiffusion. 
The default value is -1, i.e. no threshold is applied.
</command>

<command name="ANISOTROPICPRESSURE">
	 <parameter name="UseConstantTau" type="logical" default="F"/>
	 <if expr="$UseConstantTau">
	 	 <parameter name="TauInstabilitySi" type="real" default="-1"/>
	 </if>
	 <parameter name="TauGLobalSi" type="real" default="-1"/>
		
#ANISOTROPICPRESSURE
T			UseConstantTau 
10			TauInstabilitySi (only read if UseConstantTau is true)
100			TauGlobalSi

Set parameters for the pressure relaxation term.

If UseConstantTau is set to false, use the growth-rate based relaxation time. 
This is the default and also recommended.

If UseConstantTau is set to true, TauInstabilitySi provides the relaxation time 
in seconds to restrict the pressure anisotropy in unstable regions. Within the 
time, the parallel pressure is pushed towards plasma instability limits. 
The default value is -1, i.e, do not apply the pressure relaxation due to
instabilities. If applied, a typical value for magnetospheric simulations 
is 10 seconds.
 
TauGlobalSi provides the global pressure relaxation time in seconds 
applied in the whole domain. Within the time, the parallel pressure 
is pushed towards the total scalar pressure. In the presence of both 
the instability and global relaxation, the one that changes pressure 
more will be used for the pressure relaxation term.
The default value for TauGlobalSi is -1, i.e. do not apply the global 
relaxation. The example shows a recommended value for magnetospheric simulations.

When UseConstantTau = T and TauInstabilitySi = -1, the pressure relaxation 
term is not applied, thus TauGlobalSi is meaningless in this case.


</command>

<command name="EXTRAINTERNALENERGY">
	 <parameter name="ExtraEintMinSi" type="real" default="0"/>

#EXTRAINTERNALENERGY
-1e3			ExtraEintMinSi

Provide the minimum extra internal energy density threshold in SI units. 
The extra internal energy density is the difference between true 
internal energy density and the p/(gamma-1) of the ideal gas. 
Using a large enough gamma (e.g. 5/3) can guarantee that the 
difference is always non-negative. The default value is zero. 
</command>

<command name="RADIATION">
	<parameter name="UseRadDiffusion" type="logical" default="F"/>
	<if expr="$UseRadDiffusion">
		<parameter name="UseRadFluxLimiter" type="logical" 
								default="F"/>
		<parameter name="TypeRadFluxLimiter" type="string" 
			case="lower" input="select" if="$UseRadFluxLimiter">
			<option name="larsen"  default="T" />
			<option name="sum"	   	   />
			<option name="max"		   />
		 </parameter>
		<parameter name="TradMinSi" type="real" min="0" default="300"/>
	 </if>

#RADIATION
T		UseRadDiffusion    (rest of parameters read only if true)
T		UseRadFluxLimiter 
larsen		TypeRadFluxLimiter (read only if UseRadFluxLimiter is true)
300.0		TradMinSi

If UseRadDiffusion is true the radiation hydrodynamics with
radiation nonequilibrium diffusion approximation is used.

If the UseRadDiffusion is set to true, then optionally a non-linear 
flux limiter can be invoked via UseRadFluxLimiter set to true. 
This limits the radiation diffusion flux so that it does not 
exceed the optically thin streaming limit, the speed of light. 
The type of flux limiter can be selected by setting TypeRadFluxLimiter.

If TypeRadFluxLimiter="sum", then Wilson's sum flux limiter is used.
If TypeRadFluxLimiter="max", then Wilson's max flux limiter is used.
For TypeRadFluxLimiter="larsen" the square-root flux limiter of Larsen is used.

The TradMinSi parameter sets a minimum temperature in Kelvins 
for the radiation. This helps avoiding negative radiation temperature due
to numerical errors. A recommended value is 300K.

The default for UseRadFluxLimiter is false.
</command>

<command name="HEATFLUXLIMITER">
	<parameter name="UseHeatFluxLimiter" type="logical" default="F"/>
	<if expr="$UseHeatFluxLimiter">
		<parameter name="HeatFluxLimiter" type="real" min="0"
							default="0.06"/>
	</if>
#HEATLUXLIMITER
T			UseHeatFluxLimiter
0.06			HeatFluxLimiter

If UseHeatFluxLimiter is set to false, the original Spitzer-Harm formulation
for the collisional isotropic electron thermal heat conduction is used as set
by the #SEMIIMPLICIT command.

If UseHeatFluxLimiter is set to true, this isotropic heat conduction is
modified to correct the heat conduction coefficient if the electron
temperature length scale is only a few collisonal mean free paths of the
electrons or smaller. The flux limited heat conduction that is used in
this case is the threshold model.

If we define the free streaming flux as  F_fs = n_e*k_B*T_e*v_th,
where v_th = sqrt(k_B*T_e/m_e) is a characteristic thermal velocity, then
the threshold model limits the heat conduction flux F = -kappa*grad(Te),
with heat conduction coefficient kappa, by
   F = -min(kappa, f*F_fs / |grad(Te)|) * grad(Te)
Here, f is the heat flux limiter.

A possible application of interest for the heat flux limiter is
laser-irradiated plasmas. For this limiter to work properly, the
thermodynamic quanties in the user_material_properties subroutine in the
ModUser module need to be defined (see ModUserCrash for an example).

The default for UseHeatFluxLimiter is false.
</command>

<command name="LASERPULSE">
	<parameter name="UseLaserHeating" type="logical" default="F"/>
	<if expr="$UseLaserHeating">
		<parameter name="IrradianceSi" type="real" min="0"/>
		<parameter name="tPulse" type="real" min="0"/>
		<parameter name="tRaise" type="real" min="0"/>
		<parameter name="tDecay" type="real" min="0"/>
	</if>

#LASERPULSE
T		UseLaserHeating (rest of parameters are read if true)
3.8e10		IrradianceSI [J/s]
1.0e-10		tPulse [s]
1.0e-11		tRaise [s]
1.0e-11		tDecay [s]

This command is used for CRASH applications and it requires a CRASH related
user file.

Read parameters for the laser pulse. The irradiance determines the energy
per second. The length, rise, and decay times are given by the other three
parameters. The laser heating is switched off by default.
</command>

<command name="LASERBEAMS">
	<parameter name="TypeBeam" type="string" case="lower" input="select">
		<option name="rz" default="T"/>
		<option name="3d"            />
	</parameter>
	<if expr="$TypeBeam =~ /rz/">
	  <parameter name="nRayPerbeam" type="integer" min="1" default="30"/>
	</if>
	<if expr="$TypeBeam =~ /3d/">
	  <parameter name="TypeBeamCoordinates" type="string"
	  	     				case="lower" input="select">
                <option name="polar"     default="T"/>
                <option name="cartesian"            />
	  </parameter>
	  <if expr="$ypeBeamCoordinates =~ /polar/">
	    <parameter name="nRayR" type="integer" min="1" default="900"/>
	    <parameter name="nRayPhi" type="integer" min="1" default="4"/>
	  </if>
	  <if expr="$ypeBeamCoordinates =~ /cartesian/">
	    <parameter name="nRayY" type="integer" min="1" default="50"/>
	    <parameter name="nRayZ" type="integer" min="1" default="50"/>
	  </if>
	</if>
	<parameter name="rBeam" type="real" min="0"/>
	<parameter name="xBeam" type="real"/>

#LASERBEAMS
rz		TypeBeam
30		nRayPerBeam
438.0		rBeam
-290.0		xBeam

This command is used for CRASH applications and it requires a CRASH related
user file. This command should be used together with the  #LASERPULSE command.

The TypeBeam determines the geometry of the beams. Currently all beam
definition are only available for rz-geoemrty.

For TypeBeam=rz, each beam consists of 2*nRayPerBeam+1 rays. 
The rays are parallel and are up to 1.5 rBeam away from the central ray.
The xBeam determines the starting X position of the rays.

For TypeBeam=3d in rz-geometry there is the option for a beam definition on
a polar or cartesian grid (The grid is defined orthogonal to the initial ray
propagation direction). On a polar grid the rays locations are defined on
a uniform grid with nRayR rays in the radial direction from 0 to 1.5*rBeam and
nRayPhi+1 rays in the angle direction from 0 to pi. Due to symmetry properties
in the laser beams the angle from pi to 2*pi are not needed.
On a cartesian grid the ray locations are defined on a 2*nRayY+1 by nRayZ+1
uniform grid. The y-direction ranges from -1.5*rBeam to 1.5*rBeam. Due to
symmetry in each beam the z-direction is limited between 0 and 1.5*rBeam.

</command>

<command name="LASERBEAM" multiple="T">
	<parameter name="SlopeDeg" type="real"/>
	<parameter name="yBeam"    type="real"/>
	<parameter name="AmplitudeRel" type="real" min="0"/>

#LASERBEAM
10.0		SlopeDeg
0.0		yBeam
1.0		AmplitudeRel

This command is used for CRASH applications and it requires a CRASH related
user file. This command should be used together with the  #LASERPULSE command.

The SlopeDeg parameter determines the direction of the beam relative to the
X axis. The yBeam has to do with the Y coordinate of the initial positions.
The AmplitudeRel gives the relative intensity of the beam.
</command>

<command name="LASERBEAMPROFILE">
         <parameter name="SuperGaussianOrder" type="real"/>

#LASERBEAMPROFILE
4.2             SuperGaussianOrder

This command is used for CRASH applications and it requires a CRASH related
user file. This command should be used together with the  #LASERPULSE command.

The SuperGaussianOrder parameter determines the profile of each laser beam.
The irradiance profile of the beam is of the form
exp[ - (r / rBeam)**SuperGaussianOrder],
where r is the distance to the tilted central ray of the beam and rBeam is
defined by the #LASERBEAMS command. The default value for SuperGaussianOrder
is 4.2
</command>

<command name="MASSLOADING">
	<parameter name="UseMassLoading" type="logical" default="F"/>	
	<parameter name="DoAccelerateMassLoading" type="logical" default="F"/>
#MASSLOADING
F			UseMassLoading
F			DoAccelerateMassLoading
</command>

<command name="HEATCONDUCTION">
	 <parameter name="UseHeatConduction"    type="logical" default="F"/>
	 <if expr="$UseHeatConduction">
                <parameter name="TypeHeatConduction" type="string" case="lower"
                        input="select" >
                        <option name="spitzer" default="T"/>
                        <option name="user"               />
                </parameter>
	 </if>

#HEATCONDUCTION
T			UseHeatConduction
spitzer			TypeHeatConduction

If UseHeatConduction is false, no heat conduction is included.
If UseHeatConduction is true, then one can select the collisional
heat conduction of Spitzer or a user defined heat conduction.
Both heat conduction formulations are field-aligned and are only applied
to the electrons.

For TypeHeatConduction='spitzer' a spatially uniform Coulomb logarithm
of 20 is assumed, resulting in a heat conduction coefficient of
\begin{verbatim}
9.2e-12 W m^-1 K^-7/2.
\end{verbatim}
Fully ionized hydrogen plasma is assumed.

For TypeHeatConduction='user' the heat conduction coefficient of the
field-aligned heat conduction is read from the user_material_properties
subroutine in the ModUser module. Optional parameters should be read with
subroutine user_read_inputs of the ModUser file.

The default is UseHeatConduction=.false.

</command>

<command name="IONHEATCONDUCTION">
	 <parameter name="UseIonHeatConduction"    type="logical" default="F"/>
	 <if expr="$UseIonHeatConduction">
                <parameter name="TypeIonHeatConduction" type="string" case="lower"
                        input="select" >
                        <option name="spitzer" default="T"/>
                        <option name="user"               />
                </parameter>
	 </if>

#IONHEATCONDUCTION
T			UseIonHeatConduction
spitzer			TypeIonHeatConduction

If UseIonHeatConduction is false, no proton heat conduction is included.
If UseIonHeatConduction is true, then one can select the classical
Coulomb-mediated ion heat conduction or a user defined heat conduction.
Both heat conduction formulations are field-aligned and are only applied to
the protons.

For TypeIonHeatConduction='spitzer' a spatially uniform Coulomb logarithm
of 20 is assumed, resulting in a heat conduction coefficient of
\begin{verbatim}
2.6e-13 W m^-1 K^-7/2
\end{verbatim}
for protons.

For TypeIonHeatConduction='user' the heat conduction coefficient of the
field-aligned heat conduction is read from the user_material_properties
subroutine in the ModUser module. Optional parameters should be read with
subroutine user_read_inputs of the ModUser file.

The default is UseIonHeatConduction=.false.

</command>

<command name="HEATFLUXREGION">
	 <parameter name="UseHeatFluxRegion"  type="logical" default="F"/>
	 <if expr="$UseHeatFluxRegion">
	     <parameter name="rCollisional"   type="real" />
	     <parameter name="rCollisionless" type="real" />
         </if>

#HEATFLUXREGION
T                       UseHeatFluxRegion
5.0                     rCollisional
10.0                    rCollisionless

If UseHeatFluxRegion is false, both the electron and ion heat conduction
(as set by the #HEATCONDUCTION and #IONHEATCONDUCTION commands), are
applied everywhere.

If UseHeatFluxRegion is true, both the electron and ion heat conduction
are applied between the inner boundary (either Sun or planet) and
rCollisional. Beyond r=rCollisional, both the electron and ion heat
conduction coefficients are multiplied by
\begin{verbatim}
exp(-((r-rCollisional)/(rCollisionless-rCollisional))**2)
\end{verbatim}

The default is UseHeatFluxRegion=.false.

</command>

<command name="SECONDBODY" if="$_IsFirstSession">
	<parameter name="UseBody2" type="logical" default="F"/>
	<if expr="$UseBody2">
		<parameter name="rBody2" type="real" min="0"
							default="0.1"/>
		<parameter name="xBody2" type="real" min="$xMin" max="$xMax"
							default="-40"/>
		<parameter name="yBody2" type="real" min="$yMin" max="$yMax"
							default="0" />
		<parameter name="zBody2" type="real" min="$zMin" max="$zMax"
							default="0" />
		<parameter name="rCurrents2" type="real" min="$rBody2"
							default="1.3*$rBody2"/>
		<parameter name="RhoDimBody2" type="real" min="0"
							default="5" />
		<parameter name="tDimBody2" type="real" min="0"
							default="25000"/>
		<parameter name="UseOrbit" type="logical" default="F"/>
		<parameter name="OrbitPeriod" type="real" min="0"
			default="100.0" if="$UseOrbit"/>
	</if>

#SECONDBODY
T			UseBody2   ! Rest of the parameters read if .true.
0.01			rBody2 
-40.			xBody2
0.			yBody2
0.			zBody2
0.011                   rCurrents2  !This is unused currently 
5.0			RhoDimBody2 (/ccm) density for fixed BC for rho_BLK
25000.0			TDimBody2 (K) temperature for fixed BC for P_BLK
T			UseOrbit
365.25			OrbitPeriod [days]

Defines the radius, (initial) position, surface density and temperature, 
and orbit period (if any) of a second body. The second body may also 
have magnetic field given by the #DIPOLEBODY2 command.
This command should appear before the #INNERBOUNDARY command when using
a second body.
Default is UseBody2=.false.  
</command>

<command name="DIPOLEBODY2" if="$_IsFirstSession">
	<parameter name="BdpDimBody2x" type="real" />
	<parameter name="BdpDimBody2y" type="real" />
	<parameter name="BdpDimBody2z" type="real" />

#DIPOLEBODY2
0.0			BdpDimBody2x [nT]
0.0			BdpDimBody2y [nT]
-1000.0			BdpDimBody2z [nT]

The BdpDimBody2x, BdpDimBody2y and BdpDimBody2z variables contain
the 3 components of the dipole vector in the GSE frame.
The absolute value of the dipole vector is the equatorial field strength
in nano Tesla.

Default is no dipole field for the second body.
</command>

</commandgroup>

<commandgroup name="CORONA SPECIFIC COMMANDS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!! CORONA SPECIFIC COMMANDS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

<command name="MAGNETOGRAM">
	<parameter name="UseMagnetogram" type="logical" default="F"	/>
	<if expr="$UseMagnetogram">
		<parameter name="rMagnetogram" type="real" 
						default="1.0" />
		<parameter name="rSourceSurface" type="real" 
						default="2.5" />
		<parameter name="HeightInnerBc" type="real" 
						default="0.0" />
		<parameter name="NameHarmonicsFile" type="string" 
						length="100" />
		<parameter name="nHeaderLine" type="integer" min="0"
						default="12" />
		<parameter name="PhiShift" type="real" 
						default="-1.0" />
		<parameter name="UnitB" type="real" 
						default="3.0" />
	</if>
#MAGNETOGRAM
T			UseMagnetogram (rest of parameters read if true)
1.0			rMagnetogram
2.5			rSourceSurface
0.0			HeightInnerBc
Param/CORONA/CR1935_WSO.dat    NameHarmonicsFile
12			nHeaderLine
-1.0			PhiShift
0.01			UnitB

If UseMagnetogram=T then read the harmonics file for the coronal 
magnetic field and use it to set B0 to the potential field solution. 

rMagnetogram and rSourceSurface are the photosphere and source surface 
heliocentric radii, respectively. B0 becomes radial at rSourceSurface
(typically taken to be 2.5 solar radii).

HeightInnerBc is the height above the photosphere of the boundary surface, 
non-zero values for this parameter are not recommended to unexperienced users. 

NameHarmonicsFile is the name of the file containing the harmonics.
nHeaderLine is the number of header lines in the harmonics file. 

PhiShift is the offset in the longitude (calculated as the diffference in 
lonigitude of the magnetogram central meridian and 180 degrees. PhiShift=0 
means that the synoptic map is averaged over the whole Carrington rotation. 
With PhiShift = -1.0 the code calculates the actual value for PhiShift by
exctracting the central meridian coordinate from the harmonics file. 

UnitB may be used both as a fudge-factor to upscale the (usually reduced) 
observational data and to accomodate data measured in the units
different from Gauss. 
Wilcox data (in micro-Tesla) may be only used with UnitB=0.01-0.03.

Default is UseMagnetogram=F.
 
</command>

<command name="READPOTENTIALFIELD">
	<parameter name="UseMagnetogram" type="logical" default="F"/>
	<if expr="$UseMagnetogram">
	     <parameter name="NamePotentialFieldFile" type="string" 
	     		length="100" default="potentialfield.out"/>
	     <parameter name="HeightInnerBc" type="real" min="0" default="0"/>
	     <parameter name="UnitB" type="real" min="0" default="3"/>
	</if>

#READPOTENTIALFIELD
T                       UseMagnetogram (rest of parameters are read if true)
potentialfield.out      NamePotentialFieldFile
0.0                     HeightInnerBc
3.0                     UnitB

If UseMagnetogram=T then read the potential field from a file.

NamePotentialFieldFile provides the name of the file containing the 3D
potential field solution, typically produced by the FDIPS code.

HeightInnerBc is the height above the photosphere of the boundary surface,
non-zero values for this parameter are not recommended to unexperienced users.

UnitB may be used both as a fudge-factor to upscale the (usually reduced)
observational data and to accomodate data measured in the units
different from Gauss.
Wilcox data (in micro-Tesla) may be only used with UnitB=0.01-0.03.

</command>

<command name="LDEM">
	<parameter name="UseLdem" type="logical" default="F"	/>
	<if expr="$UseLdem">
		
		<parameter name="NameLdemFile" type="string" 
						length="100" />
		<parameter name="iRadiusLdem" type="integer" min="0"
						default="12" />
	</if>

#LDEM
F			UseLdem (rest of parameters read if true)
LDEM_moments.out	NameLdemFile
1			iRadiusLdem

If UseLdem=T then read the LDEM moments file for the coronal density and temperature.

NameLdemFile is the name of the file containing the Ldem moments.

iRadiusLdem gives the index of the desired radius at which data is extracted.
The Ldem moments data is ordered into concentric spherical shells of increasing
radius,  ranging from 1.035Rs to 1.255Rs, in increaments of 0.01Rs. The user can
select the desired radius by varying the iRadiusLdem parameter. The minimal accepted 
value of iRadiusLdem is 1, corresponding to 1.035Rs. iRadiusLdem=2 corresponds to 
1.045Rs, and so forth.

Default is UseLdem=F, iRadiusLdem=1
 
</command>

<command name="EMPIRICALSW">
	<parameter name="NameModelSW" type="string" input="select">
		<option name="none" default="T"/>
		<option name="WSA"/>
	</parameter>

#EMPIRICALSW
WSA             NameModelSW

Depending on the expansion factors, calculated using the magnetogram field,
for NameModelSW=WSA the spatial distribution of varied gamma is calculated.
Through the Bernoulli integral the solar wind at 1AU should fit the WSA
solar wind semi-empirical model, with the prescribed distribution of the
varied gamma. Default value is NameModelSW=none.
</command>

<command name="WSACOEFF">
    <parameter name="ConstantSpeed"   type="real" min="0" default="240"/>
    <parameter name="ModulationSpeed" type="real" min="0" default="675"/>
    <parameter name="PowerIndex1"     type="real" min="0" default="4.5"/>
    <parameter name="Coeff1"          type="real"         default="1.0"/>
    <parameter name="coeff2"          type="real"         default="0.8"/>
    <parameter name="Angle"           type="real" min="0" default="2.8"/>
    <parameter name="PowerIndex2"     type="real" min="0" default="1.25"/>
    <parameter name="PowerIndex3"     type="real" min="0" default="3.0"/>
    <parameter name="LowerBound"      type="real" min="0" default="0.0"/>
    <parameter name="UpperBound"      type="real" min="$LowerBound" 
							default="9999.0"/>
#WSACOEFF
240.0		ConstantSpeed [km/s]
675.0		ModulationSpeed [km/s]
4.5  		PowerIndex1
1.0  		Coeff1
0.8  		Coeff2
2.8  		Angle [deg]
1.25 		PowerIndex2
3.0  		PowerIndex3
0.0  		LowerBound
9999.0		UpperBound

Read in various parameters for the Wang-Sheely-Arge model. The exact meaning
of the parameters should be obtained from publications on the WSA model.
Default values are show. 
</command>

<command name="CORONALHEATING">
	<parameter name="TypeCoronalHeating" type="string" case="lower"
		input="select" >
		<option name="none"      default="T"/>
		<option name="exponential"          />
		<option name="unsignedflux"         />
		<option name="NonWKB"               />
		<option name="alfvenwavedissipation"/>
		<option name="turbulentcassade"/>
	</parameter>
	<if expr="$TypeCoronalHeating =~ /exponential/">
		<parameter name="DecayLengthExp" type="real" 
						default="0.7" />
		<parameter name="HeatingAmplitudeCgs" type="real" 
						default="6.07E-7" />
	</if>
	<if expr="$TypeCoronalHeating =~ /unsignedflux/">
		<parameter name="DecayLength" type="real" 
						default="1.0"/>
		<parameter name="HeatNormalization" type="real" 
						default="1.0"/>
	</if>
	<if expr="$TypeCoronalHeating =~ /alfvenwavedissipation/">
		<parameter name="LperpTimesSqrtBSi" type="real" 
						default="7.5E4"/>
		<parameter name="Crefl" type="real" 
						default="0.04"/>
	</if>

#CORONALHEATING
exponential	TypeCoronalHeating
0.0575		DecayLengthEXP      [Rsun] 	  (read for exp heating only)
7.285E-05	HeatingAmplitudeCgs [ergs/cm^3/s] (read for exp heating only)

#CORONALHEATING
unsignedflux	TypeCoronalHeating
0.0575		DecayLength	  [Rsun] (read for unsignedflux heating only)
1.0		HeatNormalization [none] (read for unsignedflux heating only)

#CORONALHEATING
alfvenwavedissipation	TypeCoronalHeating
7.5E4			LperpTimesSqrtBSi (read for alfvenwavedissipation only)
0.04			Crefl             (read for alfvenwavedissipation only)


If UseCoronalHeating is false, no CoronalHeating is included.
If UseCoronalHeating is true, then one can select a simple exponential scale 
height heating model or B weighted heating model normalized to the amount of 
unsigned flux measured at the soalr surface (Abbett 2007). Each model applies a 
cell based source term to the Energy equation.

For TypeCoronalHeating='exponential' coronal heating is applied using an
exponential scale height model. DecayLengthExp is the e-folding length in
units of Solar Radii and HeatingAmplitudeCgs is the heating rate at r=1.0

For TypeCoronalHeating='unsignedflux' the coronal heating term is calculated
using the unsigned flux model presented in (Abbett 2007). DecayLengthExp is 
the e-folding length in units of Solar Radii to limit the range of influence 
of this function. Because the total power in X-Ray emission is not well
constrained to total heating power in the corona, the term HeatNormalization 
is used to uniformly multiply the heating rate by this factor (default 1.0).

For TypeCoronalHeating='NonWKB' coronal heating is applied using the wave
dissapation model of Cranmer 2010. No additional input parameters are needed.

For TypeCoronalHeating='alfvenwavedissipation' coronal heating is applied
using an anisotropic formulation of the Kolmogorov-type dissipation.

The default is TypeCoronalHeating="none"
</command>

<command name="LONGSCALEHEATING">
	<parameter name="DoChHeat" type="logical" default="F"	/>
	<if expr="$DoChHeat">
		<parameter name="HeatChCgs" type="real" 
						default="5.0E-7" />
		<parameter name="DecayLengthCh" type="real" 
						default="0.7" />
	</if>
#LONGSCALEHEATING
T		DoChHeat (rest of parameters read only if set to true)
7.285E-05	HeatChCgs	[ergs/cm^3/s]
0.0575		DecayLengthCh	[Rsun]

If DoChHeat is false, no long scale height heating is included.
If DoChHeat is true, one supplies parameters for a simple exponential scale 
height heating model like that in the CORONALHEATING command. HeatChCgs sets
the base heating rate ar r=1.0 [Rsun] and DecayLengthCh is the e-folding length
in units of Solar Radii.
The idea is to use this commmand in conjunction with any short scale height
heating model selected by the CORONALHEATING command.

The default is DoChHeat=.false.
</command>

<command name="ACTIVEREGIONHEATING">
	<parameter name="UseArComponent" type="logical" default="F"	/>
	<if expr="$UseArComponent">
		<parameter name="ArHeatFactorCgs" type="real" 
						default="4.03E-5" />
		<parameter name="ArHeatB0" type="real" 
						default="30.0" />
		<parameter name="DeltaArHeatB0" type="real" 
						default="5.0" />
	</if>
#ACTIVEREGIONHEATING
T		UseArComponent (rest of parameters read only if set to true)
4.03E-05	ArHeatFactorCgs	[ergs/cm^3/s]
30.0		ArHeatB0	[Gauss]
5.0		DeltaArHeatB0	[Gauss]

If UseArComponent is false, no ActiveRegion heating component is used.
If UseArComponent is true, one supplies parameters for a linear B weighted 
heating model used to supply strong heating to regions of high magnetic field
strength. This model multiplies ArHeatFactorCgs by the cell magnetic field 
strength in gauss to determine a heating rate. ArHeatB0 is the central field
strength for the tanh transition function that selects between the exponential 
heating model supplied by the CORONALHEATING command and the ArHeating term.
DeltaArHeatB0 is the width of this transition function. 
This transition function has values: approx 0.1 at b0-deltab0, 0.5 at b0,
and approx 0.9 at b0+deltab0.

This heating is ONLY applied when CORONALHEATING is set to the exponential
heating model at the moment.

The default is UseArComponent=.false.
</command>
<command name="OPENCLOSEDHEAT">
	<parameter name="DoOpenClosedHeat" type="logical" default="F"	/>

#OPENCLOSEDHEAT
T               DoOpenClosedField

If DoOpenClosedHeat=.true., then the heating function or the turbulent heating
rate are modulated from closed to open magnetic field. Exponential heating 
function as well as the unsigned flux model function are switched off in the 
open field region. With the Cranmer heating function, the reflection 
coefficient in the closed field region is set to one, intensifying the 
heating.

Default is DoOpenClosedField = .false.
</command>

<command name="RADIATIVECOOLING">
	 <parameter name="UseRadCooling" type="logical" default="F" />
#RADIATIVECOOLING
T			UseRadCooling

Switches the radiation cooling on and off. For coronal solar plasma the
emissivity calculated in the "coronal" approximation (optically thin plasma
with no radiation-induced excitations and ionization). The radiation loss rate
is approximated using CHIANTI tables or approximate interpolation formula (see
comments in src/ModRadiativeCooling.f90). Default value for UseRadCooling is
.false.

</command>

<command name="TRANSITIONREGION">
	 <parameter name="DoExpandTransitionRegion" type="logical" 
								default="F"/>
	<parameter name="TeTransitionRegionSi" type="real" 
							default="3.0E+5" />
	<parameter name="DeltaTeModSi" type="real"      default="1.0E+4" 
					if="$DoExtendTransitionRegion"/>

#TRANSITIONREGION
T                    DoExpandTransitionRegion
3.0E+5               TeTransitionRegionSi
1.0E+4               DeltaTeSi  (read if DoExtendTransitionRegion is true)

The artificial expansion of the transition region is needed to resolve the 
Transition Region (TR) which is an extremely thin region in reality. 
To achieve the expansion, at temperatures below TeTransitionRegionSi the heat
conduction coefficient is artificially enhanced and the radiation loss
rate is modified accordingly. The profile of temperature and density
in this case are maintained to be the same as in the actual transition
region, however, the spatial scale becomes much longer, so that the TR
may be modelled with feasible grid resolution. 

If DoExpandTransitionRegion is false, the #TRANSITIONREGION command 
can be used to set the temperature of the top of the transition region.
Then the special boundary condition (REB - radiation energy balance)
is used at the "coronal base", while the temperature is fixed at 
Te=TeTopTransitionRegion.

Default value is DoExpandTransitionRegion = .false.
</command>
</commandgroup>

<commandgroup name="HELIOSPHERE SPECIFIC COMMANDS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!! HELIOSPHERE SPECIFIC COMMANDS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="THINCURRENTSHEET">
	 <parameter name="DoThinCurrentSheet" type="logical" default="F"/>

#THINCURRENTSHEET
F			DoThinCurrentSheet

The thin current sheet option is based on the thin current sheet method of
the ENLIL code. Numerical reconnection of magnetic field about the
heliospheric current sheet is avoided by reversing the field direction in one
hemisphere (the hemisphere for which the radial magnetic is negative). This
method assumes that there is no guide field, which would otherwise start to
reconnection. It is only intended for inner and outer heliosphere simulations,
assuming no coronal mass ejections are present.

This method requires an equation model that contains the SignB variable.
This variable is used to track where the field is reversed and where the
current sheet is located by using a level set method for the sign.

Default value is DoThinCurrentSheet = .false.
</command>

<command name="HELIOUPDATEB0" if="$NameComp ne 'GM'">
	<parameter name="DtUpdateB0" type="real" min="-1" default="0.0001"/>

#HELIOUPDATEB0
-1.0			DtUpdateB0 [s]

Set the frequency of updating the B0 field for the solar corona.
A negative value means that the B0 field is not updated.
</command>

<command name="HELIODIPOLE" if="$NameComp ne 'GM'">
	<parameter name="HelioDipoleStrength" type="real" />
	<parameter name="HelioDipoleTilt" type="real" min="-90" max="90" 
								default="0"/>

#HELIODIPOLE
-3.0                    HelioDipoleStrength [G]
 0.0                    HelioDipoleTilt     [deg]

Variable HelioDipoleStrength defines the equatorial field strength in Gauss,
while HelioDipoleTilt is the tilt relative to the ecliptic North 
(negative sign means towards the planet) in degrees.

Default value is HelioDipoleStrength = 0.0.
</command>

<command name="HELIOBUFFERGRID" if="$_IsFirstSession and $NameComp =~ /IH|OH/">
	<parameter name="rBuffMin"   type="real" min="1" default="19"/>
	<parameter name="rBuffMax"   type="real" min="1" default="21"/>
	<parameter name="nThetaBuff" type="integer" min="18" default="45"/>
	<parameter name="nPhiBuff"   type="integer" min="36" default="90"/>
#HELIOBUFFERGRID
19.0		rBuffMin
21.0		rBuffMax
45		nThetaBuff
90		nPhiBuff

Define the radius and the grid resolution for the uniform 
spherical buffer grid which passes information 
from the SC(IH) component to the IH(OH) component. The resolution should
be similar to the grid resolution of the coarser of the SC(IH) and IH(OH) grids.  The buffer grid will only be used if 'buffergrid' is chosed for TypeBcInner in the #INNERBOUNDARY command of the target (IH or OH) component.
This command can only be used in the first session by the IH(OH) component. 
Default values are shown above.
</command>
</commandgroup>

<commandgroup name="WAVE SPECIFIC COMMANDS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!! WAVE SPECIFIC COMMANDS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

<command name="ADVECTWAVES">
	<parameter name="DoAdvectnWaves" type="logical" default="T"/>

#ADVECTWAVES
T                   DoAdvectWaves

If DoAdvectWaves = .true. the waves are advected in the energy dimension.
This term may be very small and it can be switched off for purposes of
testing or comaparison with other codes that do not have this term.

The default is false.
</command>

<command name="ALFVENWAVES">
	<parameter name="UseAlfvenWaves" type="logical" default="F"/>

#ALFVENWAVES
T                   UseAlfvenWaves

If UseAlfvenWaves = .true. the waves are separated into
two sets, one of them ('plus') propagate parallel to the magnetic
field, the second one ('minus') is for waves propagating anti-parallel
to the field. The propagation speed with respect to the background
plasma is $\pm V_A=\pm|B|/\sqrt{\rho}$.  </command>

</commandgroup>

<commandgroup name="SCRIPT COMMANDS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!! SCRIPT COMMANDS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="INCLUDE">
	<parameter name="NameIncludeFile" type="string" length="100" 
		default="Param/" />

#INCLUDE
Param/SSS_3000		NameIncludeFile

Include a library file from Param/ or any file from anywhere else.
</command>

</commandgroup>
<!--
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!! GLOBAL RULES !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-->
<rule expr="$MaxImplBlock>1 or not $UsePartImplicit or not $MaxImplBlock">
	Part implicit scheme requires more than 1 implicit block!
</rule>

<rule expr="$MaxImplBlock==$MaxBlock or not $UseFullImplicit">
	Full implicit scheme should be used with equal number of 
	explicit and implicit blocks!
</rule>

<rule expr="-d $NameRestartOutDir or not $_IsFirstSession">
	Output restart directory $NameRestartOutDir should exist!
</rule>

<rule expr="-d $NamePlotDir or not $_IsFirstSession">
	Plot directory $NamePlotDir should exist!
</rule>

</commandList>
